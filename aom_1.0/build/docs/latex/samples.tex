This S\+DK includes a number of sample applications. Each sample documents a feature of the S\+DK in both prose and the associated C code. The following samples are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_decode_to_md5}{decode\+\_\+to\+\_\+md5} Frame by frame M\+D5 checksum.
\item \hyperlink{example_decode_with_drops}{decode\+\_\+with\+\_\+drops} Drops frames while decoding.
\item \hyperlink{example_simple_decoder}{simple\+\_\+decoder} Simplified decoder loop.
\item \hyperlink{example_lossless_encoder}{lossless\+\_\+encoder} Simplified lossless encoder.
\item \hyperlink{example_set_maps}{set\+\_\+maps} Set active and R\+OI maps.
\item \hyperlink{example_simple_encoder}{simple\+\_\+encoder} Simplified encoder loop.
\item \hyperlink{example_twopass_encoder}{twopass\+\_\+encoder} Two-\/pass encoder loop.
\item \hyperlink{example_scalable_encoder}{scalable\+\_\+encoder} Scalable encoder loop.
\item \hyperlink{example_aom_cx_set_ref}{aom\+\_\+cx\+\_\+set\+\_\+ref} Set encoder reference frame.
\item \hyperlink{example_lightfield_encoder}{lightfield\+\_\+encoder} Lightfield encoder example.
\item \hyperlink{example_lightfield_tile_list_decoder}{lightfield\+\_\+tile\+\_\+list\+\_\+decoder} Lightfield tile list decoder example.
\item \hyperlink{example_lightfield_decoder}{lightfield\+\_\+decoder} Lightfield decoder example.
\item \hyperlink{example_lightfield_bitstream_parsing}{lightfield\+\_\+bitstream\+\_\+parsing} Lightfield bitstream parsing example.
\end{DoxyItemize}

In addition, the S\+DK contains a number of utilities. Since these utilities are built upon the concepts described in the sample code listed above, they are not documented in pieces like the samples are. Their source is included here for reference. The following utilities are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_aomdec}{aomdec} Full featured decoder.
\item \hyperlink{example_aomenc}{aomenc} Full featured encoder. 
\end{DoxyItemize}\hypertarget{example_decode_to_md5}{}\subsection{decode\+\_\+to\+\_\+md5}\label{example_decode_to_md5}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Frame-by-frame MD5 Checksum}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This example builds upon the simple decoder loop to show how checksums}
16 \textcolor{comment}{// of the decoded output can be generated. These are used for validating}
17 \textcolor{comment}{// decoder implementations against the reference implementation, for example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// MD5 algorithm}
20 \textcolor{comment}{// -------------}
21 \textcolor{comment}{// The Message-Digest 5 (MD5) is a well known hash function. We have provided}
22 \textcolor{comment}{// an implementation derived from the RSA Data Security, Inc. MD5 Message-Digest}
23 \textcolor{comment}{// Algorithm for your use. Our implmentation only changes the interface of this}
24 \textcolor{comment}{// reference code. You must include the `md5\_utils.h` header for access to these}
25 \textcolor{comment}{// functions.}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Processing The Decoded Data}
28 \textcolor{comment}{// ---------------------------}
29 \textcolor{comment}{// Each row of the image is passed to the MD5 accumulator. First the Y plane}
30 \textcolor{comment}{// is processed, then U, then V. It is important to honor the image's `stride`}
31 \textcolor{comment}{// values.}
32 
33 \textcolor{preprocessor}{#include <stdio.h>}
34 \textcolor{preprocessor}{#include <stdlib.h>}
35 \textcolor{preprocessor}{#include <string.h>}
36 
37 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
38 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
39 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
40 \textcolor{preprocessor}{#include "common/tools\_common.h"}
41 \textcolor{preprocessor}{#include "common/video\_reader.h"}
42 
43 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_image\_md5(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
44   \textcolor{keywordtype}{int} plane, y;
45   MD5Context md5;
46 
47   MD5Init(&md5);
48 
49   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
50     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
51     \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
52     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = plane ? (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} + 1) >> 1 : img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
53     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = plane ? (img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} + 1) >> 1 : img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
54 
55     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
56       MD5Update(&md5, buf, w);
57       buf += stride;
58     \}
59   \}
60 
61   MD5Final(digest, &md5);
62 \}
63 
64 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(FILE *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
65   \textcolor{keywordtype}{int} i;
66 
67   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) fprintf(stream, \textcolor{stringliteral}{"%02x"}, digest[i]);
68 \}
69 
70 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
71 
72 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
73   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
74   exit(EXIT\_FAILURE);
75 \}
76 
77 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
78   \textcolor{keywordtype}{int} frame\_cnt = 0;
79   FILE *outfile = NULL;
80   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
81   AvxVideoReader *reader = NULL;
82   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
83   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
84 
85   exec\_name = argv[0];
86 
87   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
88 
89   reader = aom\_video\_reader\_open(argv[1]);
90   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
91 
92   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
93     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
94 
95   info = aom\_video\_reader\_get\_info(reader);
96 
97   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
98   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
99 
100   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
101 
102   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
103     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder"});
104 
105   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
106     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
107     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
108     \textcolor{keywordtype}{size\_t} frame\_size = 0;
109     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
110         aom\_video\_reader\_get\_frame(reader, &frame\_size);
111     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
112       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame"});
113 
114     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
115       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16];
116 
117       get\_image\_md5(img, digest);
118       print\_md5(outfile, digest);
119       fprintf(outfile, \textcolor{stringliteral}{"  img-%dx%d-%04d.i420\(\backslash\)n"}, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
120               ++frame\_cnt);
121     \}
122   \}
123 
124   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
125   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
126 
127   aom\_video\_reader\_close(reader);
128 
129   fclose(outfile);
130   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
131 \}
\end{DoxyCodeInclude}
 \hypertarget{example_decode_with_drops}{}\subsection{decode\+\_\+with\+\_\+drops}\label{example_decode_with_drops}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Decode With Drops Example}
13 \textcolor{comment}{// =========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example utility which drops a series of frames, as specified}
16 \textcolor{comment}{// on the command line. This is useful for observing the error recovery}
17 \textcolor{comment}{// features of the codec.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Usage}
20 \textcolor{comment}{// -----}
21 \textcolor{comment}{// This example adds a single argument to the `simple\_decoder` example,}
22 \textcolor{comment}{// which specifies the range or pattern of frames to drop. The parameter is}
23 \textcolor{comment}{// parsed as follows:}
24 \textcolor{comment}{//}
25 \textcolor{comment}{// Dropping A Range Of Frames}
26 \textcolor{comment}{// --------------------------}
27 \textcolor{comment}{// To drop a range of frames, specify the starting frame and the ending}
28 \textcolor{comment}{// frame to drop, separated by a dash. The following command will drop}
29 \textcolor{comment}{// frames 5 through 10 (base 1).}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 5-10}
32 \textcolor{comment}{//}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Dropping A Pattern Of Frames}
35 \textcolor{comment}{// ----------------------------}
36 \textcolor{comment}{// To drop a pattern of frames, specify the number of frames to drop and}
37 \textcolor{comment}{// the number of frames after which to repeat the pattern, separated by}
38 \textcolor{comment}{// a forward-slash. The following command will drop 3 of 7 frames.}
39 \textcolor{comment}{// Specifically, it will decode 4 frames, then drop 3 frames, and then}
40 \textcolor{comment}{// repeat.}
41 \textcolor{comment}{//}
42 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 3/7}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Extra Variables}
46 \textcolor{comment}{// ---------------}
47 \textcolor{comment}{// This example maintains the pattern passed on the command line in the}
48 \textcolor{comment}{// `n`, `m`, and `is\_range` variables:}
49 \textcolor{comment}{//}
50 \textcolor{comment}{//}
51 \textcolor{comment}{// Making The Drop Decision}
52 \textcolor{comment}{// ------------------------}
53 \textcolor{comment}{// The example decides whether to drop the frame based on the current}
54 \textcolor{comment}{// frame number, immediately before decoding the frame.}
55 
56 \textcolor{preprocessor}{#include <stdio.h>}
57 \textcolor{preprocessor}{#include <stdlib.h>}
58 \textcolor{preprocessor}{#include <string.h>}
59 
60 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
61 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
62 \textcolor{preprocessor}{#include "common/tools\_common.h"}
63 \textcolor{preprocessor}{#include "common/video\_reader.h"}
64 
65 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
66 
67 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
68   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <N-M|N/M>\(\backslash\)n"}, exec\_name);
69   exit(EXIT\_FAILURE);
70 \}
71 
72 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
73   \textcolor{keywordtype}{int} frame\_cnt = 0;
74   FILE *outfile = NULL;
75   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
76   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
77   AvxVideoReader *reader = NULL;
78   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
79   \textcolor{keywordtype}{int} n = 0;
80   \textcolor{keywordtype}{int} m = 0;
81   \textcolor{keywordtype}{int} is\_range = 0;
82   \textcolor{keywordtype}{char} *nptr = NULL;
83 
84   exec\_name = argv[0];
85 
86   \textcolor{keywordflow}{if} (argc != 4) die(\textcolor{stringliteral}{"Invalid number of arguments."});
87 
88   reader = aom\_video\_reader\_open(argv[1]);
89   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
90 
91   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
92     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
93 
94   n = (int)strtol(argv[3], &nptr, 0);
95   m = (int)strtol(nptr + 1, NULL, 0);
96   is\_range = (*nptr == \textcolor{charliteral}{'-'});
97   \textcolor{keywordflow}{if} (!n || !m || (*nptr != \textcolor{charliteral}{'-'} && *nptr != \textcolor{charliteral}{'/'}))
98     die(\textcolor{stringliteral}{"Couldn't parse pattern %s.\(\backslash\)n"}, argv[3]);
99 
100   info = aom\_video\_reader\_get\_info(reader);
101 
102   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
103   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
104 
105   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
106 
107   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
108     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
109 
110   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
111     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
112     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
113     \textcolor{keywordtype}{size\_t} frame\_size = 0;
114     \textcolor{keywordtype}{int} skip;
115     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
116         aom\_video\_reader\_get\_frame(reader, &frame\_size);
117     ++frame\_cnt;
118 
119     skip = (is\_range && frame\_cnt >= n && frame\_cnt <= m) ||
120            (!is\_range && m - (frame\_cnt - 1) % m <= n);
121 
122     \textcolor{keywordflow}{if} (!skip) \{
123       putc(\textcolor{charliteral}{'.'}, stdout);
124       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
125         die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
126 
127       \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL)
128         aom\_img\_write(img, outfile);
129     \} \textcolor{keywordflow}{else} \{
130       putc(\textcolor{charliteral}{'X'}, stdout);
131     \}
132 
133     fflush(stdout);
134   \}
135 
136   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
137   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
138 
139   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
140          info->frame\_width, info->frame\_height, argv[2]);
141 
142   aom\_video\_reader\_close(reader);
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_decoder}{}\subsection{simple\+\_\+decoder}\label{example_simple_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Decoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple decoder loop. It takes an input file}
16 \textcolor{comment}{// containing the compressed data (in IVF format), passes it through the}
17 \textcolor{comment}{// decoder, and writes the decompressed frames to disk. Other decoder}
18 \textcolor{comment}{// examples build upon this one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For decoders, you only have to include `aom\_decoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Initializing The Codec}
35 \textcolor{comment}{// ----------------------}
36 \textcolor{comment}{// The libaom decoder is initialized by the call to aom\_codec\_dec\_init().}
37 \textcolor{comment}{// Determining the codec interface to use is handled by AvxVideoReader and the}
38 \textcolor{comment}{// functions prefixed with aom\_video\_reader\_. Discussion of those functions is}
39 \textcolor{comment}{// beyond the scope of this example, but the main gist is to open the input file}
40 \textcolor{comment}{// and parse just enough of it to determine if it's a AVx file and which AVx}
41 \textcolor{comment}{// codec is contained within the file.}
42 \textcolor{comment}{// Note the NULL pointer passed to aom\_codec\_dec\_init(). We do that in this}
43 \textcolor{comment}{// example because we want the algorithm to determine the stream configuration}
44 \textcolor{comment}{// (width/height) and allocate memory automatically.}
45 \textcolor{comment}{//}
46 \textcolor{comment}{// Decoding A Frame}
47 \textcolor{comment}{// ----------------}
48 \textcolor{comment}{// Once the frame has been read into memory, it is decoded using the}
49 \textcolor{comment}{// `aom\_codec\_decode` function. The call takes a pointer to the data}
50 \textcolor{comment}{// (`frame`) and the length of the data (`frame\_size`). No application data}
51 \textcolor{comment}{// is associated with the frame in this example, so the `user\_priv`}
52 \textcolor{comment}{// parameter is NULL.}
53 \textcolor{comment}{//}
54 \textcolor{comment}{// Codecs may produce a variable number of output frames for every call to}
55 \textcolor{comment}{// `aom\_codec\_decode`. These frames are retrieved by the}
56 \textcolor{comment}{// `aom\_codec\_get\_frame` iterator function. The iterator variable `iter` is}
57 \textcolor{comment}{// initialized to NULL each time `aom\_codec\_decode` is called.}
58 \textcolor{comment}{// `aom\_codec\_get\_frame` is called in a loop, returning a pointer to a}
59 \textcolor{comment}{// decoded image or NULL to indicate the end of list.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Processing The Decoded Data}
62 \textcolor{comment}{// ---------------------------}
63 \textcolor{comment}{// In this example, we simply write the encoded data to disk. It is}
64 \textcolor{comment}{// important to honor the image's `stride` values.}
65 \textcolor{comment}{//}
66 \textcolor{comment}{// Cleanup}
67 \textcolor{comment}{// -------}
68 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
69 \textcolor{comment}{//}
70 \textcolor{comment}{// Error Handling}
71 \textcolor{comment}{// --------------}
72 \textcolor{comment}{// This example does not special case any error return codes. If there was}
73 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
74 \textcolor{comment}{// few exceptions, aom\_codec functions return an enumerated error status,}
75 \textcolor{comment}{// with the value `0` indicating success.}
76 
77 \textcolor{preprocessor}{#include <stdio.h>}
78 \textcolor{preprocessor}{#include <stdlib.h>}
79 \textcolor{preprocessor}{#include <string.h>}
80 
81 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
82 \textcolor{preprocessor}{#include "common/tools\_common.h"}
83 \textcolor{preprocessor}{#include "common/video\_reader.h"}
84 
85 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
86 
87 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
88   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
89   exit(EXIT\_FAILURE);
90 \}
91 
92 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
93   \textcolor{keywordtype}{int} frame\_cnt = 0;
94   FILE *outfile = NULL;
95   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
96   AvxVideoReader *reader = NULL;
97   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
98   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
99 
100   exec\_name = argv[0];
101 
102   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
103 
104   reader = aom\_video\_reader\_open(argv[1]);
105   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
106 
107   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
108     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
109 
110   info = aom\_video\_reader\_get\_info(reader);
111 
112   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
113   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
114 
115   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
116 
117   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
118     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
119 
120   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
121     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
122     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
123     \textcolor{keywordtype}{size\_t} frame\_size = 0;
124     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
125         aom\_video\_reader\_get\_frame(reader, &frame\_size);
126     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
127       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
128 
129     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
130       aom\_img\_write(img, outfile);
131       ++frame\_cnt;
132     \}
133   \}
134 
135   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
136   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
137 
138   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
139          info->frame\_width, info->frame\_height, argv[2]);
140 
141   aom\_video\_reader\_close(reader);
142 
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lossless_encoder}{}\subsection{lossless\+\_\+encoder}\label{example_lossless_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <stdio.h>}
13 \textcolor{preprocessor}{#include <stdlib.h>}
14 \textcolor{preprocessor}{#include <string.h>}
15 
16 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
17 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
18 \textcolor{preprocessor}{#include "common/tools\_common.h"}
19 \textcolor{preprocessor}{#include "common/video\_writer.h"}
20 
21 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
22 
23 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
24   fprintf(stderr,
25           \textcolor{stringliteral}{"lossless\_encoder: Example demonstrating lossless "}
26           \textcolor{stringliteral}{"encoding feature. Supports raw input only.\(\backslash\)n"});
27   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <width> <height> <infile> <outfile>\(\backslash\)n"}, exec\_name);
28   exit(EXIT\_FAILURE);
29 \}
30 
31 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
32                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
33   \textcolor{keywordtype}{int} got\_pkts = 0;
34   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
35   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
36   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
37       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
38   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
39 
40   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
41     got\_pkts = 1;
42 
43     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
44       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
45       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
46                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
47                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
48         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
49       \}
50       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
51       fflush(stdout);
52     \}
53   \}
54 
55   \textcolor{keywordflow}{return} got\_pkts;
56 \}
57 
58 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
59   FILE *infile = NULL;
60   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
61   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
62   \textcolor{keywordtype}{int} frame\_count = 0;
63   \hyperlink{structaom__image}{aom\_image\_t} raw;
64   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
65   AvxVideoInfo info;
66   AvxVideoWriter *writer = NULL;
67   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
68   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
69 
70   exec\_name = argv[0];
71 
72   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
73   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
74   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
75 
76   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments"});
77 
78   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
79   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
80 
81   info.codec\_fourcc = encoder->fourcc;
82   info.frame\_width = (int)strtol(argv[1], NULL, 0);
83   info.frame\_height = (int)strtol(argv[2], NULL, 0);
84   info.time\_base.numerator = 1;
85   info.time\_base.denominator = fps;
86 
87   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
88       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
89     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
90   \}
91 
92   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
93                      info.frame\_height, 1)) \{
94     die(\textcolor{stringliteral}{"Failed to allocate image."});
95   \}
96 
97   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
98 
99   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
100   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
101 
102   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
103   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
104   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
105   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
106 
107   writer = aom\_video\_writer\_open(argv[4], kContainerIVF, &info);
108   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[4]);
109 
110   \textcolor{keywordflow}{if} (!(infile = fopen(argv[3], \textcolor{stringliteral}{"rb"})))
111     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[3]);
112 
113   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
114     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
115 
116   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS}, 1))
117     die\_codec(&codec, \textcolor{stringliteral}{"Failed to use lossless mode"});
118 
119   \textcolor{comment}{// Encode frames.}
120   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
121     encode\_frame(&codec, &raw, frame\_count++, 0, writer);
122   \}
123 
124   \textcolor{comment}{// Flush encoder.}
125   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \{
126   \}
127 
128   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
129   fclose(infile);
130   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
131 
132   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
133   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
134 
135   aom\_video\_writer\_close(writer);
136 
137   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
138 \}
\end{DoxyCodeInclude}
 \hypertarget{example_set_maps}{}\subsection{set\+\_\+maps}\label{example_set_maps}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AOM Set Active and ROI Maps}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to control the AOM encoder's}
16 \textcolor{comment}{// ROI and Active maps.}
17 \textcolor{comment}{//}
18 \textcolor{comment}{// ROI (Reigon of Interest) maps are a way for the application to assign}
19 \textcolor{comment}{// each macroblock in the image to a region, and then set quantizer and}
20 \textcolor{comment}{// filtering parameters on that image.}
21 \textcolor{comment}{//}
22 \textcolor{comment}{// Active maps are a way for the application to specify on a}
23 \textcolor{comment}{// macroblock-by-macroblock basis whether there is any activity in that}
24 \textcolor{comment}{// macroblock.}
25 \textcolor{comment}{//}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Configuration}
28 \textcolor{comment}{// -------------}
29 \textcolor{comment}{// An ROI map is set on frame 22. If the width of the image in macroblocks}
30 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
31 \textcolor{comment}{// columns, where the quantizer, loopfilter, and static threshold differ}
32 \textcolor{comment}{// from column to column.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// An active map is set on frame 33. If the width of the image in macroblocks}
35 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
36 \textcolor{comment}{// columns, where one column will have motion and the next will not.}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// The active map is cleared on frame 44.}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Observing The Effects}
41 \textcolor{comment}{// ---------------------}
42 \textcolor{comment}{// Use the `simple\_decoder` example to decode this sample, and observe}
43 \textcolor{comment}{// the change in the image at frames 22, 33, and 44.}
44 
45 \textcolor{preprocessor}{#include <assert.h>}
46 \textcolor{preprocessor}{#include <stdio.h>}
47 \textcolor{preprocessor}{#include <stdlib.h>}
48 \textcolor{preprocessor}{#include <string.h>}
49 
50 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
51 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
52 \textcolor{preprocessor}{#include "common/tools\_common.h"}
53 \textcolor{preprocessor}{#include "common/video\_writer.h"}
54 
55 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
56 
57 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
58   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile>\(\backslash\)n"},
59           exec\_name);
60   exit(EXIT\_FAILURE);
61 \}
62 
63 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
64                            \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
65   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
66   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
67 
68   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
69   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
70 
71   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = (uint8\_t *)malloc(map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols});
72   \textcolor{keywordflow}{for} (i = 0; i < map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols}; ++i) map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map}[i] = i % 2;
73 
74   if (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
75     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
76 
77   free(map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map});
78 \}
79 
80 \textcolor{keyword}{static} \textcolor{keywordtype}{void} unset\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
81                              \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
82   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
83 
84   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
85   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
86   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = NULL;
87 
88   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
89     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
93                         \textcolor{keywordtype}{int} frame\_index, AvxVideoWriter *writer) \{
94   \textcolor{keywordtype}{int} got\_pkts = 0;
95   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
96   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
97   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, 0
      );
98   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
99 
100   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
101     got\_pkts = 1;
102 
103     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
104       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
105       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
106                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
107                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
108         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
109       \}
110 
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
120   FILE *infile = NULL;
121   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
122   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \textcolor{keyword}{const} \textcolor{keywordtype}{int} limit = 15;
125   \hyperlink{structaom__image}{aom\_image\_t} raw;
126   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
127   AvxVideoInfo info;
128   AvxVideoWriter *writer = NULL;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 2;  \textcolor{comment}{// TODO(dkovalev) add command line argument}
131   \textcolor{keyword}{const} \textcolor{keywordtype}{double} bits\_per\_pixel\_per\_frame = 0.067;
132 
133   exec\_name = argv[0];
134   \textcolor{keywordflow}{if} (argc != 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
135 
136   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
137 
138   encoder = get\_aom\_encoder\_by\_name(argv[1]);
139   \textcolor{keywordflow}{if} (encoder == NULL) \{
140     die(\textcolor{stringliteral}{"Unsupported codec."});
141   \}
142   assert(encoder != NULL);
143   info.codec\_fourcc = encoder->fourcc;
144   info.frame\_width = (int)strtol(argv[2], NULL, 0);
145   info.frame\_height = (int)strtol(argv[3], NULL, 0);
146   info.time\_base.numerator = 1;
147   info.time\_base.denominator = fps;
148 
149   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
150       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
151     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
152   \}
153 
154   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
155                      info.frame\_height, 1)) \{
156     die(\textcolor{stringliteral}{"Failed to allocate image."});
157   \}
158 
159   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
160 
161   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
162   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
163 
164   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
165   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
166   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
167   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
168   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} =
169       (\textcolor{keywordtype}{unsigned} int)(bits\_per\_pixel\_per\_frame * cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} * cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} * fps / 1000);
170   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
171 
172   writer = aom\_video\_writer\_open(argv[5], kContainerIVF, &info);
173   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[5]);
174 
175   \textcolor{keywordflow}{if} (!(infile = fopen(argv[4], \textcolor{stringliteral}{"rb"})))
176     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[4]);
177 
178   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
179     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
180 
181   \textcolor{comment}{// Encode frames.}
182   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile) && frame\_count < limit) \{
183     ++frame\_count;
184 
185     \textcolor{keywordflow}{if} (frame\_count == 5) \{
186       set\_active\_map(&cfg, &codec);
187     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (frame\_count == 11) \{
188       unset\_active\_map(&cfg, &codec);
189     \}
190 
191     encode\_frame(&codec, &raw, frame\_count, writer);
192   \}
193 
194   \textcolor{comment}{// Flush encoder.}
195   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, writer)) \{
196   \}
197 
198   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
199   fclose(infile);
200   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
201 
202   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
203   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
204 
205   aom\_video\_writer\_close(writer);
206 
207   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
208 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_encoder}{}\subsection{simple\+\_\+encoder}\label{example_simple_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. Other decoder examples build upon this}
18 \textcolor{comment}{// one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For encoders, you only have to include `aom\_encoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Getting The Default Configuration}
35 \textcolor{comment}{// ---------------------------------}
36 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
37 \textcolor{comment}{// may want to publish default configurations for both a video}
38 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
39 \textcolor{comment}{// obviously have very different default settings. Consult the}
40 \textcolor{comment}{// documentation for your codec to see if it provides any default}
41 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
42 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Updating The Configuration}
45 \textcolor{comment}{// ---------------------------------}
46 \textcolor{comment}{// Almost all applications will want to update the default configuration}
47 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
48 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
49 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
50 \textcolor{comment}{// and the resolution specified on the command line.}
51 \textcolor{comment}{//}
52 \textcolor{comment}{// Initializing The Codec}
53 \textcolor{comment}{// ----------------------}
54 \textcolor{comment}{// The encoder is initialized by the following code.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Encoding A Frame}
57 \textcolor{comment}{// ----------------}
58 \textcolor{comment}{// The frame is read as a continuous block (size width * height * 3 / 2)}
59 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
60 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
61 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
62 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
63 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
64 \textcolor{comment}{// unused in this example.}
65 
66 \textcolor{comment}{// Forced Keyframes}
67 \textcolor{comment}{// ----------------}
68 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
69 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
70 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
71 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
72 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
73 \textcolor{comment}{// encoder.}
74 \textcolor{comment}{//}
75 \textcolor{comment}{// Processing The Encoded Data}
76 \textcolor{comment}{// ---------------------------}
77 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
78 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
79 \textcolor{comment}{//}
80 \textcolor{comment}{// Cleanup}
81 \textcolor{comment}{// -------}
82 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
83 \textcolor{comment}{//}
84 \textcolor{comment}{// Error Handling}
85 \textcolor{comment}{// --------------}
86 \textcolor{comment}{// This example does not special case any error return codes. If there was}
87 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
88 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
89 \textcolor{comment}{// with the value `0` indicating success.}
90 \textcolor{comment}{//}
91 \textcolor{comment}{// Error Resiliency Features}
92 \textcolor{comment}{// -------------------------}
93 \textcolor{comment}{// Error resiliency is controlled by the g\_error\_resilient member of the}
94 \textcolor{comment}{// configuration structure. Use the `decode\_with\_drops` example to decode with}
95 \textcolor{comment}{// frames 5-10 dropped. Compare the output for a file encoded with this example}
96 \textcolor{comment}{// versus one encoded with the `simple\_encoder` example.}
97 
98 \textcolor{preprocessor}{#include <stdio.h>}
99 \textcolor{preprocessor}{#include <stdlib.h>}
100 \textcolor{preprocessor}{#include <string.h>}
101 
102 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
103 \textcolor{preprocessor}{#include "common/tools\_common.h"}
104 \textcolor{preprocessor}{#include "common/video\_writer.h"}
105 
106 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
107 
108 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
109   fprintf(stderr,
110           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
111           \textcolor{stringliteral}{"<keyframe-interval> <error-resilient> <frames to encode>\(\backslash\)n"}
112           \textcolor{stringliteral}{"See comments in simple\_encoder.c for more information.\(\backslash\)n"},
113           exec\_name);
114   exit(EXIT\_FAILURE);
115 \}
116 
117 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
118                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
119   \textcolor{keywordtype}{int} got\_pkts = 0;
120   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
121   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
122   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
123       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
124   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
125 
126   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
127     got\_pkts = 1;
128 
129     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
130       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
131       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
132                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
133                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
134         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
135       \}
136       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
137       fflush(stdout);
138     \}
139   \}
140 
141   \textcolor{keywordflow}{return} got\_pkts;
142 \}
143 
144 \textcolor{comment}{// TODO(tomfinegan): Improve command line parsing and add args for bitrate/fps.}
145 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
146   FILE *infile = NULL;
147   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
148   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
149   \textcolor{keywordtype}{int} frame\_count = 0;
150   \hyperlink{structaom__image}{aom\_image\_t} raw;
151   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
152   AvxVideoInfo info;
153   AvxVideoWriter *writer = NULL;
154   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
155   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
156   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
157   \textcolor{keywordtype}{int} keyframe\_interval = 0;
158   \textcolor{keywordtype}{int} max\_frames = 0;
159   \textcolor{keywordtype}{int} frames\_encoded = 0;
160   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
161   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
162   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
163   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
164   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
165   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *keyframe\_interval\_arg = NULL;
166 
167   exec\_name = argv[0];
168 
169   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
170   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
171   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
172 
173   \textcolor{keywordflow}{if} (argc != 9) die(\textcolor{stringliteral}{"Invalid number of arguments"});
174 
175   codec\_arg = argv[1];
176   width\_arg = argv[2];
177   height\_arg = argv[3];
178   infile\_arg = argv[4];
179   outfile\_arg = argv[5];
180   keyframe\_interval\_arg = argv[6];
181   max\_frames = (int)strtol(argv[8], NULL, 0);
182 
183   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
184   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
185 
186   info.codec\_fourcc = encoder->fourcc;
187   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
188   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
189   info.time\_base.numerator = 1;
190   info.time\_base.denominator = fps;
191 
192   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
193       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
194     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
195   \}
196 
197   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
198                      info.frame\_height, 1)) \{
199     die(\textcolor{stringliteral}{"Failed to allocate image."});
200   \}
201 
202   keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);
203   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
204 
205   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
206 
207   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
208   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
209 
210   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
211   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
212   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
213   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
214   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
215   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = (\hyperlink{group__encoder_ga5f326af84993f371bb165883bb5a5a59}{aom\_codec\_er\_flags\_t})strtoul(argv[7], NULL,
       0);
216 
217   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
218   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
219 
220   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
221     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
222 
223   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
224     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
225 
226   \textcolor{comment}{// Encode frames.}
227   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
228     \textcolor{keywordtype}{int} flags = 0;
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frame\_count % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     encode\_frame(&codec, &raw, frame\_count++, flags, writer);
232     frames\_encoded++;
233     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
234   \}
235 
236   \textcolor{comment}{// Flush encoder.}
237   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \textcolor{keywordflow}{continue};
238 
239   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
240   fclose(infile);
241   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
242 
243   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
244   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
245 
246   aom\_video\_writer\_close(writer);
247 
248   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
249 \}
\end{DoxyCodeInclude}
 \hypertarget{example_twopass_encoder}{}\subsection{twopass\+\_\+encoder}\label{example_twopass_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Two Pass Encoder}
13 \textcolor{comment}{// ================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a two pass encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder twice, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. It builds upon the simple\_encoder example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Twopass Variables}
20 \textcolor{comment}{// -----------------}
21 \textcolor{comment}{// Twopass mode needs to track the current pass number and the buffer of}
22 \textcolor{comment}{// statistics packets.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Updating The Configuration}
25 \textcolor{comment}{// ---------------------------------}
26 \textcolor{comment}{// In two pass mode, the configuration has to be updated on each pass. The}
27 \textcolor{comment}{// statistics buffer is passed on the last pass.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Encoding A Frame}
30 \textcolor{comment}{// ----------------}
31 \textcolor{comment}{// Encoding a frame in two pass mode is identical to the simple encoder}
32 \textcolor{comment}{// example.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Processing Statistics Packets}
35 \textcolor{comment}{// -----------------------------}
36 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
37 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
38 \textcolor{comment}{//}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Pass Progress Reporting}
41 \textcolor{comment}{// -----------------------------}
42 \textcolor{comment}{// It's sometimes helpful to see when each pass completes.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Clean-up}
46 \textcolor{comment}{// -----------------------------}
47 \textcolor{comment}{// Destruction of the encoder instance must be done on each pass. The}
48 \textcolor{comment}{// raw image should be destroyed at the end as usual.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
55 \textcolor{preprocessor}{#include "common/tools\_common.h"}
56 \textcolor{preprocessor}{#include "common/video\_writer.h"}
57 
58 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
59 
60 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
61   fprintf(stderr,
62           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
63           \textcolor{stringliteral}{"<limit(optional)>\(\backslash\)n"},
64           exec\_name);
65   exit(EXIT\_FAILURE);
66 \}
67 
68 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
69                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
70                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
71                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
72   \textcolor{keywordtype}{int} got\_pkts = 0;
73   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
74   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
75   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
76   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
77 
78   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
79     got\_pkts = 1;
80 
81     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
82       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
83       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
84       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
85       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
86       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
87     \}
88   \}
89 
90   \textcolor{keywordflow}{return} got\_pkts;
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
95                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
96   \textcolor{keywordtype}{int} got\_pkts = 0;
97   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
98   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
99   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
103     got\_pkts = 1;
104     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
105       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
106 
107       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
108                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
109                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
110         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
120                              \textcolor{keyword}{const} AvxInterface *encoder,
121                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} limit) \{
122   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
125 
126   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
127     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
128 
129   \textcolor{comment}{// Calculate frame statistics.}
130   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
131     ++frame\_count;
132     get\_frame\_stats(&codec, raw, frame\_count, 1, 0, &stats);
133   \}
134 
135   \textcolor{comment}{// Flush encoder.}
136   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
137   \}
138 
139   printf(\textcolor{stringliteral}{"Pass 0 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
140   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
141 
142   \textcolor{keywordflow}{return} stats;
143 \}
144 
145 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
146                   \textcolor{keyword}{const} AvxInterface *encoder, \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
147                   \textcolor{keywordtype}{int} limit) \{
148   AvxVideoInfo info = \{ encoder->fourcc,
149                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
150                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
151                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \},
152                         0 \};
153   AvxVideoWriter *writer = NULL;
154   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
155   \textcolor{keywordtype}{int} frame\_count = 0;
156 
157   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
158   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
159 
160   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
161     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
162 
163   \textcolor{comment}{// Encode frames.}
164   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
165     ++frame\_count;
166     encode\_frame(&codec, raw, frame\_count, 1, 0, writer);
167   \}
168 
169   \textcolor{comment}{// Flush encoder.}
170   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
171   \}
172 
173   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
174 
175   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
176 
177   aom\_video\_writer\_close(writer);
178 
179   printf(\textcolor{stringliteral}{"Pass 1 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
180 \}
181 
182 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
183   FILE *infile = NULL;
184   \textcolor{keywordtype}{int} w, h;
185   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
186   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
187   \hyperlink{structaom__image}{aom\_image\_t} raw;
188   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
189   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
190 
191   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
192   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;       \textcolor{comment}{// TODO(dkovalev) add command line argument}
193   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s TODO(dkovalev) add command line argument}
194   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} codec\_arg = argv[1];
195   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[2];
196   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[3];
197   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[4];
198   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[5];
199   \textcolor{keywordtype}{int} limit = 0;
200   exec\_name = argv[0];
201 
202   \textcolor{keywordflow}{if} (argc < 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
203 
204   \textcolor{keywordflow}{if} (argc > 6) limit = (int)strtol(argv[6], NULL, 0);
205 
206   \textcolor{keywordflow}{if} (limit == 0) limit = 100;
207 
208   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
209   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
210 
211   w = (int)strtol(width\_arg, NULL, 0);
212   h = (int)strtol(height\_arg, NULL, 0);
213 
214   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
215     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
216 
217   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 1))
218     die(\textcolor{stringliteral}{"Failed to allocate image"}, w, h);
219 
220   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
221 
222   \textcolor{comment}{// Configuration}
223   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
224   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
225 
226   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
227   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
228   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
229   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
230   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
231 
232   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
233     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
234 
235   \textcolor{comment}{// Pass 0}
236   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
237   stats = pass0(&raw, infile, encoder, &cfg, limit);
238 
239   \textcolor{comment}{// Pass 1}
240   rewind(infile);
241   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
242   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
243   pass1(&raw, infile, outfile\_arg, encoder, &cfg, limit);
244   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
245 
246   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
247   fclose(infile);
248 
249   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
250 \}
\end{DoxyCodeInclude}
 \hypertarget{example_scalable_encoder}{}\subsection{scalable\+\_\+encoder}\label{example_scalable_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Scalable Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a scalable encoder loop. It takes two input files in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in OBU format.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Getting The Default Configuration}
20 \textcolor{comment}{// ---------------------------------}
21 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
22 \textcolor{comment}{// may want to publish default configurations for both a video}
23 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
24 \textcolor{comment}{// obviously have very different default settings. Consult the}
25 \textcolor{comment}{// documentation for your codec to see if it provides any default}
26 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
27 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Updating The Configuration}
30 \textcolor{comment}{// ---------------------------------}
31 \textcolor{comment}{// Almost all applications will want to update the default configuration}
32 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
33 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
34 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
35 \textcolor{comment}{// and the resolution specified on the command line.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{// Encoding A Frame}
38 \textcolor{comment}{// ----------------}
39 \textcolor{comment}{// The frame is read as a continuous block (size = width * height * 3 / 2)}
40 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
41 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
42 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
43 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
44 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
45 \textcolor{comment}{// unused in this example.}
46 
47 \textcolor{comment}{// Forced Keyframes}
48 \textcolor{comment}{// ----------------}
49 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
50 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
51 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
52 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
53 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
54 \textcolor{comment}{// encoder.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Processing The Encoded Data}
57 \textcolor{comment}{// ---------------------------}
58 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
59 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Cleanup}
62 \textcolor{comment}{// -------}
63 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
64 \textcolor{comment}{//}
65 \textcolor{comment}{// Error Handling}
66 \textcolor{comment}{// --------------}
67 \textcolor{comment}{// This example does not special case any error return codes. If there was}
68 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
69 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
70 \textcolor{comment}{// with the value `0` indicating success.}
71 
72 \textcolor{preprocessor}{#include <stdio.h>}
73 \textcolor{preprocessor}{#include <stdlib.h>}
74 \textcolor{preprocessor}{#include <string.h>}
75 
76 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
77 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
78 \textcolor{preprocessor}{#include "av1/common/enums.h"}
79 \textcolor{preprocessor}{#include "common/tools\_common.h"}
80 \textcolor{preprocessor}{#include "common/video\_writer.h"}
81 
82 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
83 
84 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
85   fprintf(stderr,
86           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile0> <infile1> "}
87           \textcolor{stringliteral}{"<outfile> <frames to encode>\(\backslash\)n"}
88           \textcolor{stringliteral}{"See comments in scalable\_encoder.c for more information.\(\backslash\)n"},
89           exec\_name);
90   exit(EXIT\_FAILURE);
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, FILE *outfile) \{
95   \textcolor{keywordtype}{int} got\_pkts = 0;
96   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
97   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
98   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
99       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
103     got\_pkts = 1;
104 
105     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
106       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
107       \textcolor{keywordflow}{if} (fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, outfile) !=
108           pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz) \{
109         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
110       \}
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       printf(\textcolor{stringliteral}{" %6d\(\backslash\)n"}, (\textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
113       fflush(stdout);
114     \}
115   \}
116 
117   \textcolor{keywordflow}{return} got\_pkts;
118 \}
119 
120 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
121   FILE *infile0 = NULL;
122   FILE *infile1 = NULL;
123   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
124   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
125   \textcolor{keywordtype}{int} frame\_count = 0;
126   \hyperlink{structaom__image}{aom\_image\_t} raw0, raw1;
127   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
128   AvxVideoInfo info;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
131   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
132   \textcolor{keywordtype}{int} keyframe\_interval = 0;
133   \textcolor{keywordtype}{int} max\_frames = 0;
134   \textcolor{keywordtype}{int} frames\_encoded = 0;
135   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
136   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
137   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
138   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile0\_arg = NULL;
139   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile1\_arg = NULL;
140   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
141   \textcolor{comment}{//  const char *keyframe\_interval\_arg = NULL;}
142   FILE *outfile = NULL;
143 
144   exec\_name = argv[0];
145 
146   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
147   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
148   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
149 
150   \textcolor{keywordflow}{if} (argc != 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
151 
152   codec\_arg = argv[1];
153   width\_arg = argv[2];
154   height\_arg = argv[3];
155   infile0\_arg = argv[4];
156   infile1\_arg = argv[5];
157   outfile\_arg = argv[6];
158   max\_frames = (int)strtol(argv[7], NULL, 0);
159 
160   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
161   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
162 
163   info.codec\_fourcc = encoder->fourcc;
164   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
165   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
166   info.time\_base.numerator = 1;
167   info.time\_base.denominator = fps;
168 
169   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
170       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
171     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
172   \}
173 
174   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw0, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
175                      info.frame\_height, 1)) \{
176     die(\textcolor{stringliteral}{"Failed to allocate image for layer 0."});
177   \}
178   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw1, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
179                      info.frame\_height, 1)) \{
180     die(\textcolor{stringliteral}{"Failed to allocate image for layer 1."});
181   \}
182 
183   \textcolor{comment}{//  keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);}
184   keyframe\_interval = 100;
185   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
186 
187   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
188 
189   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
190   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
191 
192   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
193   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
194   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
195   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
196   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
197   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;
198   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
199   cfg.\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
200   cfg.\hyperlink{structaom__codec__enc__cfg_adb3fe41c1ce39579a49b97bc2ca7b2f2}{save\_as\_annexb} = 0;
201 
202   outfile = fopen(outfile\_arg, \textcolor{stringliteral}{"wb"});
203   \textcolor{keywordflow}{if} (!outfile) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
204 
205   \textcolor{keywordflow}{if} (!(infile0 = fopen(infile0\_arg, \textcolor{stringliteral}{"rb"})))
206     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
207   \textcolor{keywordflow}{if} (!(infile1 = fopen(infile1\_arg, \textcolor{stringliteral}{"rb"})))
208     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
209 
210   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
211     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
212   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED}, 8))
213     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cpu to 8"});
214 
215   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 2))
216     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile columns to 2"});
217   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG}, 3))
218     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set num of tile groups to 3"});
219 
220   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aef4facbd3745aa7f2a604faaf68316ff}{AOME\_SET\_NUMBER\_SPATIAL\_LAYERS}
      , 2))
221     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set number of spatial layers to 2"});
222 
223   \textcolor{comment}{// Encode frames.}
224   \textcolor{keywordflow}{while} (aom\_img\_read(&raw0, infile0)) \{
225     \textcolor{keywordtype}{int} flags = 0;
226 
227     \textcolor{comment}{// configure and encode base layer}
228 
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frames\_encoded % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     \textcolor{keywordflow}{else}
232       \textcolor{comment}{// use previous base layer (LAST) as sole reference}
233       \textcolor{comment}{// save this frame as LAST to be used as reference by enhanmcent layer}
234       \textcolor{comment}{// and next base layer}
235       flags |= \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
236                \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
237                \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
238                \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
239                \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
240     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
241     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
242     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
243       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 0"});
244     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 0))
245       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 0"});
246     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 62))
247       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
248     encode\_frame(&codec, &raw0, frame\_count++, flags, outfile);
249 
250     \textcolor{comment}{// configure and encode enhancement layer}
251 
252     \textcolor{comment}{//  use LAST (base layer) as sole reference}
253     flags = \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
254             \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} | 
      \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} |
255             \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} | \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} |
256             \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
257             \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
258     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
259     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
260     aom\_img\_read(&raw1, infile1);
261     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
262       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 1"});
263     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 1))
264       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 1"});
265     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 10))
266       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
267     encode\_frame(&codec, &raw1, frame\_count++, flags, outfile);
268 
269     frames\_encoded++;
270 
271     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
272   \}
273 
274   \textcolor{comment}{// Flush encoder.}
275   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, outfile)) \textcolor{keywordflow}{continue};
276 
277   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
278   fclose(infile0);
279   fclose(infile1);
280   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count / 2);
281 
282   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw0);
283   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw1);
284   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
285 
286   fclose(outfile);
287 
288   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
289 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aom_cx_set_ref}{}\subsection{aom\+\_\+cx\+\_\+set\+\_\+ref}\label{example_aom_cx_set_ref}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AV1 Set Reference Frame}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to overwrite the AV1 encoder's}
16 \textcolor{comment}{// internal reference frame. In the sample we set the last frame to the}
17 \textcolor{comment}{// current frame. This technique could be used to bounce between two cameras.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// The decoder would also have to set the reference frame to the same value}
20 \textcolor{comment}{// on the same frame, or the video will become corrupt. The 'test\_decode'}
21 \textcolor{comment}{// variable is set to 1 in this example that tests if the encoder and decoder}
22 \textcolor{comment}{// results are matching.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Usage}
25 \textcolor{comment}{// -----}
26 \textcolor{comment}{// This example encodes a raw video. And the last argument passed in specifies}
27 \textcolor{comment}{// the frame number to update the reference frame on. For example, run}
28 \textcolor{comment}{// examples/aom\_cx\_set\_ref av1 352 288 in.yuv out.ivf 4 30}
29 \textcolor{comment}{// The parameter is parsed as follows:}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//}
32 \textcolor{comment}{// Extra Variables}
33 \textcolor{comment}{// ---------------}
34 \textcolor{comment}{// This example maintains the frame number passed on the command line}
35 \textcolor{comment}{// in the `update\_frame\_num` variable.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// Configuration}
39 \textcolor{comment}{// -------------}
40 \textcolor{comment}{//}
41 \textcolor{comment}{// The reference frame is updated on the frame specified on the command}
42 \textcolor{comment}{// line.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Observing The Effects}
45 \textcolor{comment}{// ---------------------}
46 \textcolor{comment}{// The encoder and decoder results should be matching when the same reference}
47 \textcolor{comment}{// frame setting operation is done in both encoder and decoder. Otherwise,}
48 \textcolor{comment}{// the encoder/decoder mismatch would be seen.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
55 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
56 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
57 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
58 \textcolor{preprocessor}{#include "common/tools\_common.h"}
59 \textcolor{preprocessor}{#include "common/video\_writer.h"}
60 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
61 
62 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
63 
64 \textcolor{keywordtype}{void} usage\_exit() \{
65   fprintf(stderr,
66           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
67           \textcolor{stringliteral}{"<frame> <limit(optional)>\(\backslash\)n"},
68           exec\_name);
69   exit(EXIT\_FAILURE);
70 \}
71 
72 \textcolor{keyword}{static} \textcolor{keywordtype}{void} testing\_decode(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *encoder, 
      \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *decoder,
73                            \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen) \{
74   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
75 
76   \textcolor{keywordflow}{if} (*mismatch\_seen) \textcolor{keywordflow}{return};
77 
78   \textcolor{comment}{/* Get the internal reference frame */}
79   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &enc\_img)
      )
80     die\_codec(encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
81   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &dec\_img)
      )
82     die\_codec(decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
83 
84   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
85       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
86     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
87       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
88       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
89                     enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
90       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
91       enc\_img = enc\_hbd\_img;
92     \}
93     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
94       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
95       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
96                     dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
97       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
98       dec\_img = dec\_hbd\_img;
99     \}
100   \}
101 
102   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
103     \textcolor{keywordtype}{int} y[4], u[4], v[4];
104     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
105       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
106     \} \textcolor{keywordflow}{else} \{
107       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
108     \}
109 
110     printf(
111         \textcolor{stringliteral}{"Encode/decode mismatch on frame %d at"}
112         \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
113         \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
114         \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
115         frame\_out, y[0], y[1], y[2], y[3], u[0], u[1], u[2], u[3], v[0], v[1],
116         v[2], v[3]);
117     *mismatch\_seen = 1;
118   \}
119 
120   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
121   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
122 \}
123 
124 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ecodec, \hyperlink{structaom__image}{aom\_image\_t} *img,
125                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in, AvxVideoWriter *writer,
126                         \textcolor{keywordtype}{int} test\_decode, \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *dcodec,
127                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen,
128                         \hyperlink{structaom__image}{aom\_image\_t} *ext\_ref) \{
129   \textcolor{keywordtype}{int} got\_pkts = 0;
130   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
131   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
132   \textcolor{keywordtype}{int} got\_data;
133   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ecodec, img, frame\_in, 1, 0);
134   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ecodec, \textcolor{stringliteral}{"Failed to encode frame"});
135 
136   got\_data = 0;
137 
138   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ecodec, &iter)) != NULL) \{
139     got\_pkts = 1;
140 
141     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
142       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
143 
144       ++*frame\_out;
145 
146       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
147                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
148                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
149         die\_codec(ecodec, \textcolor{stringliteral}{"Failed to write compressed frame"});
150       \}
151       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
152       fflush(stdout);
153       got\_data = 1;
154 
155       \textcolor{comment}{// Decode 1 frame.}
156       \textcolor{keywordflow}{if} (test\_decode) \{
157         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(dcodec, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
158                              (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL))
159           die\_codec(dcodec, \textcolor{stringliteral}{"Failed to decode frame."});
160 
161         \textcolor{comment}{// Copy out first decoded frame, and use it as reference later.}
162         \textcolor{keywordflow}{if} (*frame\_out == 1 && ext\_ref != NULL)
163           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(dcodec, 
      \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE}, ext\_ref))
164             die\_codec(dcodec, \textcolor{stringliteral}{"Failed to get decoder new frame"});
165       \}
166     \}
167   \}
168 
169   \textcolor{comment}{// Mismatch checking}
170   \textcolor{keywordflow}{if} (got\_data && test\_decode) \{
171     testing\_decode(ecodec, dcodec, *frame\_out, mismatch\_seen);
172   \}
173 
174   \textcolor{keywordflow}{return} got\_pkts;
175 \}
176 
177 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
178   FILE *infile = NULL;
179   \textcolor{comment}{// Encoder}
180   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} ecodec;
181   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
182   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in = 0;
183   \hyperlink{structaom__image}{aom\_image\_t} raw;
184   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
185   \hyperlink{structaom__image}{aom\_image\_t} ext\_ref;
186   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
187   AvxVideoInfo info;
188   AvxVideoWriter *writer = NULL;
189   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
190   \textcolor{keywordtype}{int} flags = 0;
191   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
192   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} raw\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
193   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
194 
195   \textcolor{comment}{// Test encoder/decoder mismatch.}
196   \textcolor{keywordtype}{int} test\_decode = 1;
197   \textcolor{comment}{// Decoder}
198   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} dcodec;
199   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out = 0;
200 
201   \textcolor{comment}{// The frame number to set reference frame on}
202   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} update\_frame\_num = 0;
203   \textcolor{keywordtype}{int} mismatch\_seen = 0;
204 
205   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
206   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 500;
207 
208   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
209   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
210   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
211   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
212   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
213   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *update\_frame\_num\_arg = NULL;
214   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit = 0;
215   exec\_name = argv[0];
216 
217   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
218   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
219   memset(&ecodec, 0, \textcolor{keyword}{sizeof}(ecodec));
220   memset(&cfg, 0, \textcolor{keyword}{sizeof}(cfg));
221   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
222 
223   \textcolor{keywordflow}{if} (argc < 7) die(\textcolor{stringliteral}{"Invalid number of arguments"});
224 
225   codec\_arg = argv[1];
226   width\_arg = argv[2];
227   height\_arg = argv[3];
228   infile\_arg = argv[4];
229   outfile\_arg = argv[5];
230   update\_frame\_num\_arg = argv[6];
231 
232   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
233   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
234 
235   update\_frame\_num = (\textcolor{keywordtype}{unsigned} int)strtoul(update\_frame\_num\_arg, NULL, 0);
236   \textcolor{comment}{// In AV1, the reference buffers (cm->buffer\_pool->frame\_bufs[i].buf) are}
237   \textcolor{comment}{// allocated while calling aom\_codec\_encode(), thus, setting reference for}
238   \textcolor{comment}{// 1st frame isn't supported.}
239   \textcolor{keywordflow}{if} (update\_frame\_num <= 1) \{
240     die(\textcolor{stringliteral}{"Couldn't parse frame number '%s'\(\backslash\)n"}, update\_frame\_num\_arg);
241   \}
242 
243   \textcolor{keywordflow}{if} (argc > 7) \{
244     limit = (\textcolor{keywordtype}{unsigned} int)strtoul(argv[7], NULL, 0);
245     \textcolor{keywordflow}{if} (update\_frame\_num > limit)
246       die(\textcolor{stringliteral}{"Update frame number couldn't larger than limit\(\backslash\)n"});
247   \}
248 
249   info.codec\_fourcc = encoder->fourcc;
250   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
251   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
252   info.time\_base.numerator = 1;
253   info.time\_base.denominator = fps;
254 
255   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0) \{
256     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
257   \}
258 
259   \textcolor{comment}{// In this test, the bit depth of input video is 8-bit, and the input format}
260   \textcolor{comment}{// is AOM\_IMG\_FMT\_I420.}
261   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, raw\_fmt, info.frame\_width, info.frame\_height, 32)) \{
262     die(\textcolor{stringliteral}{"Failed to allocate image."});
263   \}
264 
265   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
266   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
267   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&ext\_ref, ref\_fmt, info.frame\_width,
268                                  info.frame\_height, 32, 8,
269                                  AOM\_BORDER\_IN\_PIXELS)) \{
270     die(\textcolor{stringliteral}{"Failed to allocate image."});
271   \}
272 
273   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
274 
275   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
276   \textcolor{keywordflow}{if} (res) die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to get default codec config."});
277 
278   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
279   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
280   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
281   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
282   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
283   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 3;
284   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
285 
286   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
287                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
288                : 0;
289 
290   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
291   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
292 
293   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
294     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
295 
296   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&ecodec, encoder->codec\_interface(), &cfg, flags))
297     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to initialize encoder"});
298 
299   \textcolor{comment}{// Disable alt\_ref.}
300   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
301     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set enable auto alt ref"});
302 
303   \textcolor{keywordflow}{if} (test\_decode) \{
304     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(codec\_arg);
305     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&dcodec, decoder->codec\_interface(), NULL, 0))
306       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to initialize decoder."});
307   \}
308 
309   \textcolor{comment}{// Encode frames.}
310   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
311     \textcolor{keywordflow}{if} (limit && frame\_in >= limit) \textcolor{keywordflow}{break};
312     \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
313 
314     \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
315       \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
316       \textcolor{keywordtype}{int} input\_shift = 0;
317       \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
318         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw\_fmt | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
319                       info.frame\_width, info.frame\_height, 32);
320         allocated\_raw\_shift = 1;
321       \}
322       aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
323       frame\_to\_encode = &raw\_shift;
324     \} \textcolor{keywordflow}{else} \{
325       frame\_to\_encode = &raw;
326     \}
327 
328     \textcolor{keywordflow}{if} (update\_frame\_num > 1 && frame\_out + 1 == update\_frame\_num) \{
329       \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
330       ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
331       ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 0;
332       ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = ext\_ref;
333       \textcolor{comment}{// Set reference frame in encoder.}
334       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
335         die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set encoder reference frame"});
336       printf(\textcolor{stringliteral}{" <SET\_REF>"});
337 
338       \textcolor{comment}{// If set\_reference in decoder is commented out, the enc/dec mismatch}
339       \textcolor{comment}{// would be seen.}
340       \textcolor{keywordflow}{if} (test\_decode) \{
341         ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
342         \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&dcodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
343           die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to set decoder reference frame"});
344       \}
345     \}
346 
347     encode\_frame(&ecodec, frame\_to\_encode, frame\_in, writer, test\_decode,
348                  &dcodec, &frame\_out, &mismatch\_seen, &ext\_ref);
349     frame\_in++;
350     \textcolor{keywordflow}{if} (mismatch\_seen) \textcolor{keywordflow}{break};
351   \}
352 
353   \textcolor{comment}{// Flush encoder.}
354   \textcolor{keywordflow}{if} (!mismatch\_seen)
355     \textcolor{keywordflow}{while} (encode\_frame(&ecodec, NULL, frame\_in, writer, test\_decode, &dcodec,
356                         &frame\_out, &mismatch\_seen, NULL)) \{
357     \}
358 
359   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
360   fclose(infile);
361   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_out);
362 
363   \textcolor{keywordflow}{if} (test\_decode) \{
364     \textcolor{keywordflow}{if} (!mismatch\_seen)
365       printf(\textcolor{stringliteral}{"Encoder/decoder results are matching.\(\backslash\)n"});
366     \textcolor{keywordflow}{else}
367       printf(\textcolor{stringliteral}{"Encoder/decoder results are NOT matching.\(\backslash\)n"});
368   \}
369 
370   \textcolor{keywordflow}{if} (test\_decode)
371     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&dcodec))
372       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to destroy decoder"});
373 
374   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
375   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&ext\_ref);
376   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
377   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&ecodec))
378     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to destroy encoder."});
379 
380   aom\_video\_writer\_close(writer);
381 
382   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
383 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_encoder}{}\subsection{lightfield\+\_\+encoder}\label{example_lightfield_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Encoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield encoder.  It builds upon the}
16 \textcolor{comment}{// twopass\_encoder.c example. It takes an input file in YV12 format,}
17 \textcolor{comment}{// treating it as a planar lightfield instead of a video. The img\_width}
18 \textcolor{comment}{// and img\_height arguments are the dimensions of the lightfield images,}
19 \textcolor{comment}{// while the lf\_width and lf\_height arguments are the number of}
20 \textcolor{comment}{// lightfield images in each dimension. The lf\_blocksize determines the}
21 \textcolor{comment}{// number of reference images used for MCP. For example, 5 means that there}
22 \textcolor{comment}{// is a reference image for every 5x5 lightfield image block. All images}
23 \textcolor{comment}{// within a block will use the center image in that block as the reference}
24 \textcolor{comment}{// image for MCP.}
25 \textcolor{comment}{// Run "make test" to download lightfield test data: vase10x10.yuv.}
26 \textcolor{comment}{// Run lightfield encoder to encode whole lightfield:}
27 \textcolor{comment}{// examples/lightfield\_encoder 1024 1024 vase10x10.yuv vase10x10.ivf 10 10 5}
28 
29 \textcolor{comment}{// Note: In bitstream.c and encoder.c, define EXT\_TILE\_DEBUG as 1 will print}
30 \textcolor{comment}{// out the uncompressed header and the frame contexts, which can be used to}
31 \textcolor{comment}{// test the bit exactness of the headers and the frame contexts for large scale}
32 \textcolor{comment}{// tile coded frames.}
33 
34 \textcolor{preprocessor}{#include <stdio.h>}
35 \textcolor{preprocessor}{#include <stdlib.h>}
36 \textcolor{preprocessor}{#include <string.h>}
37 
38 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
39 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
40 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
41 \textcolor{preprocessor}{#include "av1/common/enums.h"}
42 \textcolor{preprocessor}{#include "common/tools\_common.h"}
43 \textcolor{preprocessor}{#include "common/video\_writer.h"}
44 
45 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
46 
47 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
48   fprintf(stderr,
49           \textcolor{stringliteral}{"Usage: %s <img\_width> <img\_height> <infile> <outfile> "}
50           \textcolor{stringliteral}{"<lf\_width> <lf\_height> <lf\_blocksize>\(\backslash\)n"},
51           exec\_name);
52   exit(EXIT\_FAILURE);
53 \}
54 
55 \textcolor{keyword}{static} \textcolor{keywordtype}{int} aom\_img\_size\_bytes(\hyperlink{structaom__image}{aom\_image\_t} *img) \{
56   \textcolor{keywordtype}{int} image\_size\_bytes = 0;
57   \textcolor{keywordtype}{int} plane;
58   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
59     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = \hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(img, plane) *
60                   ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 2 : 1);
61     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(img, plane);
62     image\_size\_bytes += w * h;
63   \}
64   \textcolor{keywordflow}{return} image\_size\_bytes;
65 \}
66 
67 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
68                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
69                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
70                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
71   \textcolor{keywordtype}{int} got\_pkts = 0;
72   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
73   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
74   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
75   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
76 
77   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
78     got\_pkts = 1;
79 
80     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
81       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
82       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
83       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
84       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
85       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
86     \}
87   \}
88 
89   \textcolor{keywordflow}{return} got\_pkts;
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
93                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
94                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
95   \textcolor{keywordtype}{int} got\_pkts = 0;
96   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
97   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
98   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
99   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
100 
101   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
102     got\_pkts = 1;
103     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
104       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
105 
106       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
107                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
108                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
109         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
110       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
111       fflush(stdout);
112     \}
113   \}
114 
115   \textcolor{keywordflow}{return} got\_pkts;
116 \}
117 
118 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_raw\_image(\hyperlink{structaom__image}{aom\_image\_t} **frame\_to\_encode, \hyperlink{structaom__image}{aom\_image\_t} *raw,
119                           \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
120   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
121     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
122     \textcolor{keywordtype}{int} input\_shift = 0;
123     aom\_img\_upshift(raw\_shift, raw, input\_shift);
124     *frame\_to\_encode = raw\_shift;
125   \} \textcolor{keywordflow}{else} \{
126     *frame\_to\_encode = raw;
127   \}
128 \}
129 
130 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
131                              \textcolor{keyword}{const} AvxInterface *encoder,
132                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} lf\_width,
133                              \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
134                              \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
135   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
136   \textcolor{keywordtype}{int} frame\_count = 0;
137   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
138   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
139   \textcolor{keywordtype}{int} bu, bv;
140   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
141   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
142 
143   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
144     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
145   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
146     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
147   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
148     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
149 
150   \textcolor{comment}{// How many reference images we need to encode.}
151   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
152   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
153 
154   printf(\textcolor{stringliteral}{"\(\backslash\)n First pass: "});
155 
156   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
157     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
158       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
159       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
160       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
161       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
162       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
163       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
164 
165       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
166       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
167       u\_block\_size = block\_u\_end - block\_u\_min;
168       v\_block\_size = block\_v\_end - block\_v\_min;
169       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
170       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
171 
172       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
173       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
174             SEEK\_SET);
175       aom\_img\_read(raw, infile);
176       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
177 
178       \textcolor{comment}{// Reference frames can be encoded encoded without tiles.}
179       ++frame\_count;
180       get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
181                       \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
182                           \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
183                           \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
184                           \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
185                           \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF},
186                       &stats);
187     \}
188   \}
189 
190   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
191     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
192 
193   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
194     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
195       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
196       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
197       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
198       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
199       \textcolor{keywordtype}{int} u, v;
200       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
201       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
202       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
203         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
204           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
205           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
206           aom\_img\_read(raw, infile);
207           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
208 
209           ++frame\_count;
210           get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
211                           \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
212                               \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
213                               \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
214                               \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
215                               \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
216                           &stats);
217         \}
218       \}
219     \}
220   \}
221   \textcolor{comment}{// Flush encoder.}
222   \textcolor{comment}{// No ARF, this should not be needed.}
223   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
224   \}
225 
226   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
227 
228   printf(\textcolor{stringliteral}{"\(\backslash\)nFirst pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
229 
230   \textcolor{keywordflow}{return} stats;
231 \}
232 
233 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
234                   \textcolor{keyword}{const} AvxInterface *encoder, \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
235                   \textcolor{keywordtype}{int} lf\_width, \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
236                   \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
237   AvxVideoInfo info = \{ encoder->fourcc,
238                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
239                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
240                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \},
241                         0 \};
242   AvxVideoWriter *writer = NULL;
243   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
244   \textcolor{keywordtype}{int} frame\_count = 0;
245   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
246   \textcolor{keywordtype}{int} bu, bv;
247   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
248   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
249   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
250   \textcolor{keywordtype}{int} reference\_image\_num = 0;
251   \textcolor{keywordtype}{int} i;
252 
253   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
254   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
255 
256   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
257     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
258   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
259     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
260   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
261     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
262   \textcolor{comment}{// Note: The superblock is a sequence parameter and has to be the same for 1}
263   \textcolor{comment}{// sequence. In lightfield application, must choose the superblock size(either}
264   \textcolor{comment}{// 64x64 or 128x128) before the encoding starts. Otherwise, the default is}
265   \textcolor{comment}{// AOM\_SUPERBLOCK\_SIZE\_DYNAMIC, and the superblock size will be set to 64x64}
266   \textcolor{comment}{// internally.}
267   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
268                         \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64}))
269     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set SB size"});
270 
271   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
272   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
273 
274   reference\_image\_num = u\_blocks * v\_blocks;
275   \textcolor{comment}{// Set the max gf group length so the references are guaranteed to be in}
276   \textcolor{comment}{// a different gf group than any of the regular frames. This avoids using}
277   \textcolor{comment}{// both vbr and constant quality mode in a single group. The number of}
278   \textcolor{comment}{// references now cannot surpass 17 because of the enforced MAX\_GF\_INTERVAL of}
279   \textcolor{comment}{// 16. If it is necessary to exceed this reference frame limit, one will have}
280   \textcolor{comment}{// to do some additional handling to ensure references are in separate gf}
281   \textcolor{comment}{// groups from the regular frames.}
282   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0355cea227ab76f9bd77028a39bbfca8}{AV1E\_SET\_MAX\_GF\_INTERVAL},
283                         reference\_image\_num - 1))
284     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set max gf interval"});
285   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
286   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
287   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
288   \textcolor{keywordtype}{int} border\_in\_pixels =
289       (codec.\hyperlink{structaom__codec__ctx_ac6777025d3b72c9ab49adba78fc70b30}{config}.enc->\hyperlink{structaom__codec__enc__cfg_ab9123d944cd168511d65c823b30d5705}{rc\_resize\_mode} || codec.\hyperlink{structaom__codec__ctx_ac6777025d3b72c9ab49adba78fc70b30}{config}.enc->
      \hyperlink{structaom__codec__enc__cfg_a704ff1b4202b1d5499928b98eef17424}{rc\_superres\_mode})
290           ? AOM\_BORDER\_IN\_PIXELS
291           : AOM\_ENC\_NO\_SCALE\_BORDER;
292   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \{
293     \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[i], ref\_fmt, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
294                                    cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 32, 8, border\_in\_pixels)) \{
295       die(\textcolor{stringliteral}{"Failed to allocate image."});
296     \}
297   \}
298 
299   printf(\textcolor{stringliteral}{"\(\backslash\)n Second pass: "});
300 
301   \textcolor{comment}{// Encode reference images first.}
302   printf(\textcolor{stringliteral}{"Encoding Reference Images\(\backslash\)n"});
303   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
304     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
305       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
306       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
307       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
308       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
309       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
310       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
311 
312       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
313       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
314       u\_block\_size = block\_u\_end - block\_u\_min;
315       v\_block\_size = block\_v\_end - block\_v\_min;
316       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
317       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
318 
319       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
320       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
321             SEEK\_SET);
322       aom\_img\_read(raw, infile);
323 
324       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
325 
326       \textcolor{comment}{// Reference frames may be encoded without tiles.}
327       ++frame\_count;
328       printf(\textcolor{stringliteral}{"Encoding reference image %d of %d\(\backslash\)n"}, bv * u\_blocks + bu,
329              u\_blocks * v\_blocks);
330       encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
331                    \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
332                        \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
333                        \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
334                        \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
335                        \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
336                    writer);
337 
338       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
339                             &reference\_images[frame\_count - 1]))
340         die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoder reference frame"});
341     \}
342   \}
343 
344   cfg->\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 1;
345   \textcolor{comment}{// Fixed q encoding for camera frames.}
346   cfg->\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
347   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, cfg))
348     die\_codec(&codec, \textcolor{stringliteral}{"Failed to configure encoder"});
349 
350   \textcolor{comment}{// The fixed q value used in encoding.}
351   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 36))
352     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
353   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
354     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
355   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af341538631ffe2ac2b562c8b5336a10a}{AV1E\_SET\_SINGLE\_TILE\_DECODING}
      , 1))
356     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn on single tile decoding"});
357   \textcolor{comment}{// Set tile\_columns and tile\_rows to MAX values, which guarantees the tile}
358   \textcolor{comment}{// size of 64 x 64 pixels(i.e. 1 SB) for <= 4k resolution.}
359   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 6))
360     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile width"});
361   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS}, 6))
362     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile height"});
363 
364   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
365     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
366       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
367       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
368       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
369       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
370       \textcolor{keywordtype}{int} u, v;
371       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
372       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
373       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
374         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
375           \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
376           ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
377           ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
378           ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[bv * u\_blocks + bu];
379           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
380             die\_codec(&codec, \textcolor{stringliteral}{"Failed to set reference frame"});
381 
382           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
383           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
384           aom\_img\_read(raw, infile);
385           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
386 
387           ++frame\_count;
388           printf(\textcolor{stringliteral}{"Encoding image %d of %d\(\backslash\)n"},
389                  frame\_count - (u\_blocks * v\_blocks), lf\_width * lf\_height);
390           encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
391                        \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
392                            \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
393                            \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
394                            \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
395                            \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
396                        writer);
397         \}
398       \}
399     \}
400   \}
401 
402   \textcolor{comment}{// Flush encoder.}
403   \textcolor{comment}{// No ARF, this should not be needed.}
404   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
405   \}
406 
407   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
408 
409   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
410 
411   \textcolor{comment}{// Modify large\_scale\_file fourcc.}
412   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} == 1)
413     aom\_video\_writer\_set\_fourcc(writer, LST\_FOURCC);
414   aom\_video\_writer\_close(writer);
415 
416   printf(\textcolor{stringliteral}{"\(\backslash\)nSecond pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
417 \}
418 
419 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
420   FILE *infile = NULL;
421   \textcolor{keywordtype}{int} w, h;
422   \textcolor{comment}{// The number of lightfield images in the u and v dimensions.}
423   \textcolor{keywordtype}{int} lf\_width, lf\_height;
424   \textcolor{comment}{// Defines how many images refer to the same reference image for MCP.}
425   \textcolor{comment}{// lf\_blocksize X lf\_blocksize images will all use the reference image}
426   \textcolor{comment}{// in the middle of the block of images.}
427   \textcolor{keywordtype}{int} lf\_blocksize;
428   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
429   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
430   \hyperlink{structaom__image}{aom\_image\_t} raw;
431   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
432   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
433   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
434   \textcolor{keywordtype}{int} flags = 0;
435 
436   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
437   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
438   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s}
439   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[1];
440   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[2];
441   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[3];
442   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[4];
443   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_width\_arg = argv[5];
444   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_height\_arg = argv[6];
445   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *lf\_blocksize\_arg = argv[7];
446   exec\_name = argv[0];
447 
448   \textcolor{keywordflow}{if} (argc < 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
449 
450   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
451   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
452 
453   w = (int)strtol(width\_arg, NULL, 0);
454   h = (int)strtol(height\_arg, NULL, 0);
455   lf\_width = (int)strtol(lf\_width\_arg, NULL, 0);
456   lf\_height = (int)strtol(lf\_height\_arg, NULL, 0);
457   lf\_blocksize = (int)strtol(lf\_blocksize\_arg, NULL, 0);
458   lf\_blocksize = lf\_blocksize < lf\_width ? lf\_blocksize : lf\_width;
459   lf\_blocksize = lf\_blocksize < lf\_height ? lf\_blocksize : lf\_height;
460 
461   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
462     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
463   \textcolor{keywordflow}{if} (lf\_width <= 0 || lf\_height <= 0)
464     die(\textcolor{stringliteral}{"Invalid lf\_width and/or lf\_height: %dx%d"}, lf\_width, lf\_height);
465   \textcolor{keywordflow}{if} (lf\_blocksize <= 0) die(\textcolor{stringliteral}{"Invalid lf\_blocksize: %d"}, lf\_blocksize);
466 
467   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 32)) \{
468     die(\textcolor{stringliteral}{"Failed to allocate image."});
469   \}
470   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
471     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
472     \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}, w, h,
473                   32);
474   \}
475 
476   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
477 
478   \textcolor{comment}{// Configuration}
479   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
480   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
481 
482   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
483   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
484   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
485   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
486   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
487   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;  \textcolor{comment}{// This is required.}
488   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;    \textcolor{comment}{// need to set this since default is 19.}
489   cfg.\hyperlink{structaom__codec__enc__cfg_a3c1ea7f3ea90b9b8eab4c3f266ffacdc}{kf\_mode} = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
490   cfg.\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 0;  \textcolor{comment}{// Only set it to 1 for camera frame encoding.}
491   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
492   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
493                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
494                : 0;
495 
496   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
497     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
498 
499   \textcolor{comment}{// Pass 0}
500   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
501   stats = pass0(&raw, infile, encoder, &cfg, lf\_width, lf\_height, lf\_blocksize,
502                 flags, &raw\_shift);
503 
504   \textcolor{comment}{// Pass 1}
505   rewind(infile);
506   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
507   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
508   pass1(&raw, infile, outfile\_arg, encoder, &cfg, lf\_width, lf\_height,
509         lf\_blocksize, flags, &raw\_shift);
510   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
511 
512   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
513   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
514   fclose(infile);
515 
516   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
517 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_tile_list_decoder}{}\subsection{lightfield\+\_\+tile\+\_\+list\+\_\+decoder}\label{example_lightfield_tile_list_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Tile List Decoder}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield tile list decoder example. It takes an input file that}
16 \textcolor{comment}{// contains the anchor frames that are references of the coded tiles, the camera}
17 \textcolor{comment}{// frame header, and tile list OBUs that include the tile information and the}
18 \textcolor{comment}{// compressed tile data. This input file is reconstructed from the encoded}
19 \textcolor{comment}{// lightfield ivf file, and is decodable by AV1 decoder. num\_references is}
20 \textcolor{comment}{// the number of anchor frames coded at the beginning of the light field file.}
21 \textcolor{comment}{// num\_tile\_lists is the number of tile lists need to be decoded. There is an}
22 \textcolor{comment}{// optional parameter allowing to choose the output format, and the supported}
23 \textcolor{comment}{// formats are YUV1D(default), YUV, and NV12.}
24 \textcolor{comment}{// Run lightfield tile list decoder to decode an AV1 tile list file:}
25 \textcolor{comment}{// examples/lightfield\_tile\_list\_decoder vase\_tile\_list.ivf vase\_tile\_list.yuv}
26 \textcolor{comment}{// 4 2 0(optional)}
27 
28 \textcolor{preprocessor}{#include <stdio.h>}
29 \textcolor{preprocessor}{#include <stdlib.h>}
30 \textcolor{preprocessor}{#include <string.h>}
31 \textcolor{preprocessor}{#include <assert.h>}
32 
33 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
34 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
35 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
36 \textcolor{preprocessor}{#include "av1/common/enums.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 \textcolor{preprocessor}{#include "common/video\_reader.h"}
39 
40 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
41 
42 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
43   fprintf(stderr,
44           \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <num\_tile\_lists> "}
45           \textcolor{stringliteral}{"<output format(optional)>\(\backslash\)n"},
46           exec\_name);
47   exit(EXIT\_FAILURE);
48 \}
49 
50 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_tile\_yuv1d(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
51                              FILE *file) \{
52   \textcolor{comment}{// read out the tile size.}
53   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
54   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
55     die\_codec(codec, \textcolor{stringliteral}{"Failed to get the tile size"});
56   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
57   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
58   \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} / tile\_width;
59 
60   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_count = 0;
61   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba242d7dba47ef646f51f9795e2fa92f91}{AV1D\_GET\_TILE\_COUNT}, &tile\_count))
62     die\_codec(codec, \textcolor{stringliteral}{"Failed to get the tile size"});
63 
64   \textcolor{comment}{// Write tile to file.}
65   \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 1 : 0;
66   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_idx;
67 
68   \textcolor{keywordflow}{for} (tile\_idx = 0; tile\_idx < tile\_count; ++tile\_idx) \{
69     \textcolor{keyword}{const} \textcolor{keywordtype}{int} row\_offset =
70         (tile\_idx / output\_frame\_width\_in\_tiles) * tile\_height;
71     \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_offset =
72         (tile\_idx % output\_frame\_width\_in\_tiles) * tile\_width;
73     \textcolor{keywordtype}{int} plane;
74 
75     \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
76       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
77       \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
78       \textcolor{keyword}{const} \textcolor{keywordtype}{int} roffset =
79           (plane > 0) ? row\_offset >> img->\hyperlink{structaom__image_a5acfc850c272e1377f3b7d58a95f3749}{y\_chroma\_shift} : row\_offset;
80       \textcolor{keyword}{const} \textcolor{keywordtype}{int} coffset =
81           (plane > 0) ? col\_offset >> img->\hyperlink{structaom__image_a83fdb3677275dc0e1e38701000447214}{x\_chroma\_shift} : col\_offset;
82       \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = (plane > 0) ? ((tile\_width >> img->\hyperlink{structaom__image_a83fdb3677275dc0e1e38701000447214}{x\_chroma\_shift}) << shift)
83                                 : (tile\_width << shift);
84       \textcolor{keyword}{const} \textcolor{keywordtype}{int} h =
85           (plane > 0) ? (tile\_height >> img->\hyperlink{structaom__image_a5acfc850c272e1377f3b7d58a95f3749}{y\_chroma\_shift}) : tile\_height;
86       \textcolor{keywordtype}{int} y;
87 
88       \textcolor{comment}{// col offset needs to be adjusted for HBD.}
89       buf += roffset * stride + (coffset << shift);
90 
91       \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
92         fwrite(buf, 1, w, file);
93         buf += stride;
94       \}
95     \}
96   \}
97 \}
98 
99 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
100   FILE *outfile = NULL;
101   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
102   AvxVideoReader *reader = NULL;
103   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
104   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
105   \textcolor{keywordtype}{int} num\_references;
106   \textcolor{keywordtype}{int} num\_tile\_lists;
107   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
108   \textcolor{keywordtype}{size\_t} frame\_size = 0;
109   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
110   \textcolor{keywordtype}{int} output\_format = YUV1D;
111   \textcolor{keywordtype}{int} i, j, n;
112 
113   exec\_name = argv[0];
114 
115   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
116 
117   reader = aom\_video\_reader\_open(argv[1]);
118   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
119 
120   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
121     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
122 
123   num\_references = (int)strtol(argv[3], NULL, 0);
124   num\_tile\_lists = (int)strtol(argv[4], NULL, 0);
125 
126   \textcolor{keywordflow}{if} (argc > 5) output\_format = (int)strtol(argv[5], NULL, 0);
127   \textcolor{keywordflow}{if} (output\_format < YUV1D || output\_format > NV12)
128     die(\textcolor{stringliteral}{"Output format out of range [0, 2]"});
129 
130   info = aom\_video\_reader\_get\_info(reader);
131 
132   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
133   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
134   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
135 
136   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
137     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
138 
139   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, info->is\_annexb)) \{
140     die(\textcolor{stringliteral}{"Failed to set annex b status"});
141   \}
142 
143   \textcolor{comment}{// Decode anchor frames.}
144   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
145   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
146     aom\_video\_reader\_read\_frame(reader);
147     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
148     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
149       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
150 
151     \textcolor{keywordflow}{if} (i == 0) \{
152       \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
153       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
154         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
155 
156       \textcolor{keywordtype}{int} frame\_res[2];
157       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba175c454a7adf2d3927a0e979b4a2b07b}{AV1D\_GET\_FRAME\_SIZE}, frame\_res))
158         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image frame size"});
159 
160       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
161       \textcolor{comment}{// border so that it can be used as a reference.}
162       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
163         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_DEC\_BORDER\_IN\_PIXELS;
164         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt,
165                                        frame\_res[0], frame\_res[1], 32, 8,
166                                        border)) \{
167           die(\textcolor{stringliteral}{"Failed to allocate references."});
168         \}
169       \}
170     \}
171 
172     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
173                           &reference\_images[i]))
174       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
175 
176     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
177     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
178     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
179       \textcolor{keywordtype}{char} name[1024];
180       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
181       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
182       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
183       aom\_img\_write(img, ref\_file);
184       fclose(ref\_file);
185     \}
186   \}
187 
188   \textcolor{comment}{// Decode the lightfield.}
189   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
190 
191   \textcolor{comment}{// Set external references.}
192   \hyperlink{structav1__ext__ref__frame}{av1\_ext\_ref\_frame\_t} set\_ext\_ref = \{ &reference\_images[0], num\_references \};
193   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badfbe6c1ebe4039bfef4d2cfd98755add}{AV1D\_SET\_EXT\_REF\_PTR}, &set\_ext\_ref);
194   \textcolor{comment}{// Must decode the camera frame header first.}
195   aom\_video\_reader\_read\_frame(reader);
196   frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
197   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
198     die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the frame."});
199   \textcolor{comment}{// Decode tile lists one by one.}
200   \textcolor{keywordflow}{for} (n = 0; n < num\_tile\_lists; n++) \{
201     aom\_video\_reader\_read\_frame(reader);
202     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
203 
204     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
205       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the tile list."});
206     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
207     \hyperlink{structaom__image}{aom\_image\_t} *img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter);
208     \textcolor{keywordflow}{if} (!img) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get frame."});
209 
210     \textcolor{keywordflow}{if} (output\_format == YUV1D)
211       \textcolor{comment}{// write the tile to the output file in 1D format.}
212       write\_tile\_yuv1d(&codec, img, outfile);
213     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (output\_format == YUV)
214       aom\_img\_write(img, outfile);
215     \textcolor{keywordflow}{else}
216       \textcolor{comment}{// NV12 output format}
217       aom\_img\_write\_nv12(img, outfile);
218   \}
219 
220   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
221   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
222   aom\_video\_reader\_close(reader);
223   fclose(outfile);
224 
225   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
226 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_decoder}{}\subsection{lightfield\+\_\+decoder}\label{example_lightfield_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Decoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield decoder. It builds upon the}
16 \textcolor{comment}{// simple\_decoder.c example.  It takes an input file containing the compressed}
17 \textcolor{comment}{// data (in ivf format), treating it as a lightfield instead of a video; and a}
18 \textcolor{comment}{// text file with a list of tiles to decode. There is an optional parameter}
19 \textcolor{comment}{// allowing to choose the output format, and the supported formats are}
20 \textcolor{comment}{// YUV1D(default), YUV, and NV12.}
21 \textcolor{comment}{// After running the lightfield encoder, run lightfield decoder to decode a}
22 \textcolor{comment}{// batch of tiles:}
23 \textcolor{comment}{// examples/lightfield\_decoder vase10x10.ivf vase\_reference.yuv 4 tile\_list.txt}
24 \textcolor{comment}{// 0(optional)}
25 \textcolor{comment}{// The tile\_list.txt is expected to be of the form:}
26 \textcolor{comment}{// Frame <frame\_index0>}
27 \textcolor{comment}{// <image\_index0> <anchor\_index0> <tile\_col0> <tile\_row0>}
28 \textcolor{comment}{// <image\_index1> <anchor\_index1> <tile\_col1> <tile\_row1>}
29 \textcolor{comment}{// ...}
30 \textcolor{comment}{// Frame <frame\_index1)}
31 \textcolor{comment}{// ...}
32 \textcolor{comment}{//}
33 \textcolor{comment}{// The "Frame" markers indicate a new render frame and thus a new tile list}
34 \textcolor{comment}{// will be started and the old one flushed.  The image\_indexN, anchor\_indexN,}
35 \textcolor{comment}{// tile\_colN, and tile\_rowN identify an individual tile to be decoded and}
36 \textcolor{comment}{// to use anchor\_indexN anchor image for MCP.}
37 
38 \textcolor{preprocessor}{#include <stdio.h>}
39 \textcolor{preprocessor}{#include <stdlib.h>}
40 \textcolor{preprocessor}{#include <string.h>}
41 
42 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
43 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
44 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
45 \textcolor{preprocessor}{#include "av1/common/enums.h"}
46 \textcolor{preprocessor}{#include "common/tools\_common.h"}
47 \textcolor{preprocessor}{#include "common/video\_reader.h"}
48 
49 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
50 
51 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
52   fprintf(stderr,
53           \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <tile\_list> <output "}
54           \textcolor{stringliteral}{"format(optional)>\(\backslash\)n"},
55           exec\_name);
56   exit(EXIT\_FAILURE);
57 \}
58 
59 \textcolor{comment}{// Output frame size}
60 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_width = 512;
61 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_height = 512;
62 
63 \textcolor{keyword}{static} \textcolor{keywordtype}{void} aom\_img\_copy\_tile(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *src, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *dst,
64                               \textcolor{keywordtype}{int} dst\_row\_offset, \textcolor{keywordtype}{int} dst\_col\_offset) \{
65   \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = (src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 1 : 0;
66   \textcolor{keywordtype}{int} plane;
67 
68   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
69     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *src\_buf = src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
70     \textcolor{keyword}{const} \textcolor{keywordtype}{int} src\_stride = src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
71     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *dst\_buf = dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
72     \textcolor{keyword}{const} \textcolor{keywordtype}{int} dst\_stride = dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
73     \textcolor{keyword}{const} \textcolor{keywordtype}{int} roffset =
74         (plane > 0) ? dst\_row\_offset >> dst->\hyperlink{structaom__image_a5acfc850c272e1377f3b7d58a95f3749}{y\_chroma\_shift} : dst\_row\_offset;
75     \textcolor{keyword}{const} \textcolor{keywordtype}{int} coffset =
76         (plane > 0) ? dst\_col\_offset >> dst->\hyperlink{structaom__image_a83fdb3677275dc0e1e38701000447214}{x\_chroma\_shift} : dst\_col\_offset;
77 
78     \textcolor{comment}{// col offset needs to be adjusted for HBD.}
79     dst\_buf += roffset * dst\_stride + (coffset << shift);
80 
81     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = (\hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(src, plane) << shift);
82     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(src, plane);
83     \textcolor{keywordtype}{int} y;
84 
85     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
86       memcpy(dst\_buf, src\_buf, w);
87       src\_buf += src\_stride;
88       dst\_buf += dst\_stride;
89     \}
90   \}
91 \}
92 
93 \textcolor{keywordtype}{void} decode\_tile(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame,
94                  \textcolor{keywordtype}{size\_t} frame\_size, \textcolor{keywordtype}{int} tr, \textcolor{keywordtype}{int} tc, \textcolor{keywordtype}{int} ref\_idx,
95                  \hyperlink{structaom__image}{aom\_image\_t} *reference\_images, \hyperlink{structaom__image}{aom\_image\_t} *output,
96                  \textcolor{keywordtype}{int} *tile\_idx, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *output\_bit\_depth,
97                  \hyperlink{structaom__image}{aom\_image\_t} **img\_ptr, \textcolor{keywordtype}{int} output\_format) \{
98   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
99   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
100   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
101   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
102 
103   \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
104   ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
105   ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
106   ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[ref\_idx];
107   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref)) \{
108     die\_codec(codec, \textcolor{stringliteral}{"Failed to set reference frame."});
109   \}
110 
111   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status = \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(codec, frame, frame\_size, 
      NULL);
112   \textcolor{keywordflow}{if} (aom\_status) die\_codec(codec, \textcolor{stringliteral}{"Failed to decode tile."});
113 
114   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
115   \hyperlink{structaom__image}{aom\_image\_t} *img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(codec, &iter);
116   \textcolor{keywordflow}{if} (!img) die\_codec(codec, \textcolor{stringliteral}{"Failed to get frame."});
117   *img\_ptr = img;
118 
119   \textcolor{comment}{// aom\_img\_alloc() sets bit\_depth as follows:}
120   \textcolor{comment}{// output->bit\_depth = (fmt & AOM\_IMG\_FMT\_HIGHBITDEPTH) ? 16 : 8;}
121   \textcolor{comment}{// Use img->bit\_depth(read from bitstream), so that aom\_shift\_img()}
122   \textcolor{comment}{// works as expected.}
123   output->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
124   *output\_bit\_depth = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
125 
126   \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
127     \textcolor{comment}{// read out the tile size.}
128     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
129     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
130       die\_codec(codec, \textcolor{stringliteral}{"Failed to get the tile size"});
131     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
132     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
133     \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles = output\_frame\_width / tile\_width;
134 
135     \textcolor{comment}{// Copy the tile to the output frame.}
136     \textcolor{keyword}{const} \textcolor{keywordtype}{int} row\_offset =
137         (*tile\_idx / output\_frame\_width\_in\_tiles) * tile\_height;
138     \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_offset =
139         (*tile\_idx % output\_frame\_width\_in\_tiles) * tile\_width;
140 
141     aom\_img\_copy\_tile(img, output, row\_offset, col\_offset);
142     (*tile\_idx)++;
143   \}
144 \}
145 
146 \textcolor{keyword}{static} \textcolor{keywordtype}{void} img\_write\_to\_file(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, FILE *file,
147                               \textcolor{keywordtype}{int} output\_format) \{
148   \textcolor{keywordflow}{if} (output\_format == YUV)
149     aom\_img\_write(img, file);
150   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (output\_format == NV12)
151     aom\_img\_write\_nv12(img, file);
152   \textcolor{keywordflow}{else}
153     die(\textcolor{stringliteral}{"Invalid output format"});
154 \}
155 
156 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
157   FILE *outfile = NULL;
158   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
159   AvxVideoReader *reader = NULL;
160   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
161   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
162   \textcolor{keywordtype}{int} num\_references;
163   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
164   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
165   \hyperlink{structaom__image}{aom\_image\_t} output;
166   \hyperlink{structaom__image}{aom\_image\_t} *output\_shifted = NULL;
167   \textcolor{keywordtype}{size\_t} frame\_size = 0;
168   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
169   \textcolor{keywordtype}{int} i, j;
170   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *tile\_list\_file = NULL;
171   \textcolor{keywordtype}{int} output\_format = YUV1D;
172   exec\_name = argv[0];
173 
174   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
175 
176   reader = aom\_video\_reader\_open(argv[1]);
177   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
178 
179   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
180     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
181 
182   num\_references = (int)strtol(argv[3], NULL, 0);
183   tile\_list\_file = argv[4];
184 
185   \textcolor{keywordflow}{if} (argc > 5) output\_format = (int)strtol(argv[5], NULL, 0);
186   \textcolor{keywordflow}{if} (output\_format < YUV1D || output\_format > NV12)
187     die(\textcolor{stringliteral}{"Output format out of range [0, 2]"});
188 
189   info = aom\_video\_reader\_get\_info(reader);
190 
191   \textcolor{keywordflow}{if} (info->codec\_fourcc == LST\_FOURCC)
192     decoder = get\_aom\_decoder\_by\_fourcc(AV1\_FOURCC);
193   \textcolor{keywordflow}{else}
194     die(\textcolor{stringliteral}{"Unknown input codec."});
195   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
196 
197   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
198     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
199 
200   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, info->is\_annexb)) \{
201     die(\textcolor{stringliteral}{"Failed to set annex b status"});
202   \}
203 
204   \textcolor{comment}{// Decode anchor frames.}
205   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
206   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
207     aom\_video\_reader\_read\_frame(reader);
208     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
209     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
210       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
211 
212     \textcolor{keywordflow}{if} (i == 0) \{
213       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
214         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
215 
216       \textcolor{keywordtype}{int} frame\_res[2];
217       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba175c454a7adf2d3927a0e979b4a2b07b}{AV1D\_GET\_FRAME\_SIZE}, frame\_res))
218         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image frame size"});
219 
220       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
221       \textcolor{comment}{// border so that it can be used as a reference.}
222       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
223         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_DEC\_BORDER\_IN\_PIXELS;
224         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt,
225                                        frame\_res[0], frame\_res[1], 32, 8,
226                                        border)) \{
227           die(\textcolor{stringliteral}{"Failed to allocate references."});
228         \}
229       \}
230     \}
231 
232     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
233                           &reference\_images[i]))
234       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
235 
236     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
237     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
238     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
239       \textcolor{keywordtype}{char} name[1024];
240       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
241       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
242       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
243       aom\_img\_write(img, ref\_file);
244       fclose(ref\_file);
245     \}
246   \}
247 
248   FILE *infile = aom\_video\_reader\_get\_file(reader);
249   \textcolor{comment}{// Record the offset of the first camera image.}
250   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
251 
252   printf(\textcolor{stringliteral}{"Loading compressed frames into memory.\(\backslash\)n"});
253 
254   \textcolor{comment}{// Count the frames in the lightfield.}
255   \textcolor{keywordtype}{int} num\_frames = 0;
256   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
257     ++num\_frames;
258   \}
259   \textcolor{keywordflow}{if} (num\_frames < 1) die(\textcolor{stringliteral}{"Input light field has no frames."});
260 
261   \textcolor{comment}{// Read all of the lightfield frames into memory.}
262   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames =
263       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *));
264   \textcolor{keywordtype}{size\_t} *frame\_sizes = (\textcolor{keywordtype}{size\_t} *)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));
265   \textcolor{comment}{// Seek to the first camera image.}
266   fseeko(infile, camera\_frame\_pos, SEEK\_SET);
267   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
268     aom\_video\_reader\_read\_frame(reader);
269     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
270     frames[f] = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(frame\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));
271     memcpy(frames[f], frame, frame\_size);
272     frame\_sizes[f] = frame\_size;
273   \}
274   printf(\textcolor{stringliteral}{"Read %d frames.\(\backslash\)n"}, num\_frames);
275 
276   \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
277     \textcolor{comment}{// Allocate the output frame.}
278     \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} out\_fmt = ref\_fmt;
279     \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) out\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
280     \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&output, out\_fmt, output\_frame\_width,
281                        output\_frame\_height, 32))
282       die(\textcolor{stringliteral}{"Failed to allocate output image."});
283   \}
284 
285   printf(\textcolor{stringliteral}{"Decoding tile list from file.\(\backslash\)n"});
286   \textcolor{keywordtype}{char} line[1024];
287   FILE *tile\_list\_fptr = fopen(tile\_list\_file, \textcolor{stringliteral}{"r"});
288   \textcolor{keywordtype}{int} tile\_list\_cnt = 0;
289   \textcolor{keywordtype}{int} tile\_list\_writes = 0;
290   \textcolor{keywordtype}{int} tile\_idx = 0;
291   \hyperlink{structaom__image}{aom\_image\_t} *out = NULL;
292   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} output\_bit\_depth = 0;
293 
294   \textcolor{keywordflow}{while} ((fgets(line, 1024, tile\_list\_fptr)) != NULL) \{
295     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'}) \{
296       \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
297         \textcolor{comment}{// Write out the tile list.}
298         \textcolor{keywordflow}{if} (tile\_list\_cnt) \{
299           out = &output;
300           \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
301             aom\_shift\_img(output\_bit\_depth, &out, &output\_shifted);
302           img\_write\_to\_file(out, outfile, output\_format);
303           tile\_list\_writes++;
304         \}
305 
306         tile\_list\_cnt++;
307         tile\_idx = 0;
308         \textcolor{comment}{// Then memset the frame.}
309         memset(output.\hyperlink{structaom__image_a7c367f3227d5876ce9e5c198a01c2028}{img\_data}, 0, output.\hyperlink{structaom__image_af0f6c220bf000d1c488075c19d889290}{sz});
310       \}
311       \textcolor{keywordflow}{continue};
312     \}
313 
314     \textcolor{keywordtype}{int} image\_idx, ref\_idx, tc, tr;
315     sscanf(line, \textcolor{stringliteral}{"%d %d %d %d"}, &image\_idx, &ref\_idx, &tc, &tr);
316     \textcolor{keywordflow}{if} (image\_idx >= num\_frames) \{
317       die(\textcolor{stringliteral}{"Tile list image\_idx out of bounds: %d >= %d."}, image\_idx,
318           num\_frames);
319     \}
320     \textcolor{keywordflow}{if} (ref\_idx >= num\_references) \{
321       die(\textcolor{stringliteral}{"Tile list ref\_idx out of bounds: %d >= %d."}, ref\_idx,
322           num\_references);
323     \}
324     frame = frames[image\_idx];
325     frame\_size = frame\_sizes[image\_idx];
326 
327     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
328     decode\_tile(&codec, frame, frame\_size, tr, tc, ref\_idx, reference\_images,
329                 &output, &tile\_idx, &output\_bit\_depth, &img, output\_format);
330     \textcolor{keywordflow}{if} (output\_format == YUV1D) \{
331       out = img;
332       \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
333         aom\_shift\_img(output\_bit\_depth, &out, &output\_shifted);
334       aom\_img\_write(out, outfile);
335     \}
336   \}
337 
338   \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
339     \textcolor{comment}{// Write out the last tile list.}
340     \textcolor{keywordflow}{if} (tile\_list\_writes < tile\_list\_cnt) \{
341       out = &output;
342       \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
343         aom\_shift\_img(output\_bit\_depth, &out, &output\_shifted);
344       img\_write\_to\_file(out, outfile, output\_format);
345     \}
346   \}
347 
348   \textcolor{keywordflow}{if} (output\_shifted) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(output\_shifted);
349   \textcolor{keywordflow}{if} (output\_format != YUV1D) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&output);
350   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
351   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
352     free(frames[f]);
353   \}
354   free(frame\_sizes);
355   free(frames);
356   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
357   aom\_video\_reader\_close(reader);
358   fclose(outfile);
359 
360   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
361 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_bitstream_parsing}{}\subsection{lightfield\+\_\+bitstream\+\_\+parsing}\label{example_lightfield_bitstream_parsing}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Bitstream Parsing}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield bitstream parsing example. It takes an input file}
16 \textcolor{comment}{// containing the whole compressed lightfield bitstream(ivf file) and a text}
17 \textcolor{comment}{// file containing a stream of tiles to decode and then constructs and outputs}
18 \textcolor{comment}{// a new bitstream that can be decoded by an AV1 decoder. The output bitstream}
19 \textcolor{comment}{// contains reference frames(i.e. anchor frames), camera frame header, and}
20 \textcolor{comment}{// tile list OBUs. num\_references is the number of anchor frames coded at the}
21 \textcolor{comment}{// beginning of the light field file.  After running the lightfield encoder,}
22 \textcolor{comment}{// run lightfield bitstream parsing:}
23 \textcolor{comment}{// examples/lightfield\_bitstream\_parsing vase10x10.ivf vase\_tile\_list.ivf 4}
24 \textcolor{comment}{//   tile\_list.txt}
25 \textcolor{comment}{//}
26 \textcolor{comment}{// The tile\_list.txt is expected to be of the form:}
27 \textcolor{comment}{// Frame <frame\_index0>}
28 \textcolor{comment}{// <image\_index0> <anchor\_index0> <tile\_col0> <tile\_row0>}
29 \textcolor{comment}{// <image\_index1> <anchor\_index1> <tile\_col1> <tile\_row1>}
30 \textcolor{comment}{// ...}
31 \textcolor{comment}{// Frame <frame\_index1)}
32 \textcolor{comment}{// ...}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// The "Frame" markers indicate a new render frame and thus a new tile list}
35 \textcolor{comment}{// will be started and the old one flushed.  The image\_indexN, anchor\_indexN,}
36 \textcolor{comment}{// tile\_colN, and tile\_rowN identify an individual tile to be decoded and}
37 \textcolor{comment}{// to use anchor\_indexN anchor image for MCP.}
38 
39 \textcolor{preprocessor}{#include <stdio.h>}
40 \textcolor{preprocessor}{#include <stdlib.h>}
41 \textcolor{preprocessor}{#include <string.h>}
42 
43 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
44 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
45 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
46 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
47 \textcolor{preprocessor}{#include "aom\_dsp/bitwriter\_buffer.h"}
48 \textcolor{preprocessor}{#include "common/tools\_common.h"}
49 \textcolor{preprocessor}{#include "common/video\_reader.h"}
50 \textcolor{preprocessor}{#include "common/video\_writer.h"}
51 
52 \textcolor{preprocessor}{#define MAX\_TILES 512}
53 
54 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
55 
56 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
57   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <tile\_list>\(\backslash\)n"},
58           exec\_name);
59   exit(EXIT\_FAILURE);
60 \}
61 
62 \textcolor{preprocessor}{#define ALIGN\_POWER\_OF\_TWO(value, n) \(\backslash\)}
63 \textcolor{preprocessor}{  (((value) + ((1 << (n)) - 1)) & ~((1 << (n)) - 1))}
64 
65 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_width = 512;
66 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_height = 512;
67 
68 \textcolor{comment}{// Spec:}
69 \textcolor{comment}{// typedef struct \{}
70 \textcolor{comment}{//   uint8\_t anchor\_frame\_idx;}
71 \textcolor{comment}{//   uint8\_t tile\_row;}
72 \textcolor{comment}{//   uint8\_t tile\_col;}
73 \textcolor{comment}{//   uint16\_t coded\_tile\_data\_size\_minus\_1;}
74 \textcolor{comment}{//   uint8\_t *coded\_tile\_data;}
75 \textcolor{comment}{// \} TILE\_LIST\_ENTRY;}
76 
77 \textcolor{comment}{// Tile list entry provided by the application}
78 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
79   \textcolor{keywordtype}{int} image\_idx;
80   \textcolor{keywordtype}{int} reference\_idx;
81   \textcolor{keywordtype}{int} tile\_col;
82   \textcolor{keywordtype}{int} tile\_row;
83 \} TILE\_LIST\_INFO;
84 
85 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_image\_bps(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} fmt) \{
86   \textcolor{keywordflow}{switch} (fmt) \{
87     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} 12;
88     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} 16;
89     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} 24;
90     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} 24;
91     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} 32;
92     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} 48;
93     \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Invalid image format"});
94   \}
95   \textcolor{keywordflow}{return} 0;
96 \}
97 
98 \textcolor{keywordtype}{void} process\_tile\_list(\textcolor{keyword}{const} TILE\_LIST\_INFO *tiles, \textcolor{keywordtype}{int} num\_tiles,
99                        \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} tl\_pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames,
100                        \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} *frame\_sizes, \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec,
101                        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl\_buf, AvxVideoWriter *writer,
102                        uint8\_t output\_frame\_width\_in\_tiles\_minus\_1,
103                        uint8\_t output\_frame\_height\_in\_tiles\_minus\_1) \{
104   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl = tl\_buf;
105   \textcolor{keyword}{struct }aom\_write\_bit\_buffer wb = \{ tl, 0 \};
106   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *saved\_obu\_size\_loc = NULL;
107   uint32\_t tile\_list\_obu\_header\_size = 0;
108   uint32\_t tile\_list\_obu\_size = 0;
109   \textcolor{keywordtype}{int} num\_tiles\_minus\_1 = num\_tiles - 1;
110   \textcolor{keywordtype}{int} i;
111 
112   \textcolor{comment}{// Write the tile list OBU header that is 1 byte long.}
113   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// forbidden bit.}
114   aom\_wb\_write\_literal(&wb, 8, 4);  \textcolor{comment}{// tile list OBU: "1000"}
115   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// obu\_extension = 0}
116   aom\_wb\_write\_literal(&wb, 1, 1);  \textcolor{comment}{// obu\_has\_size\_field}
117   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// reserved}
118   tl++;
119   tile\_list\_obu\_header\_size++;
120 
121   \textcolor{comment}{// Write the OBU size using a fixed length\_field\_size of 4 bytes.}
122   saved\_obu\_size\_loc = tl;
123   \textcolor{comment}{// aom\_wb\_write\_unsigned\_literal(&wb, data, bits) requires that bits <= 32.}
124   aom\_wb\_write\_unsigned\_literal(&wb, 0, 32);
125   tl += 4;
126   tile\_list\_obu\_header\_size += 4;
127 
128   \textcolor{comment}{// write\_tile\_list\_obu()}
129   aom\_wb\_write\_literal(&wb, output\_frame\_width\_in\_tiles\_minus\_1, 8);
130   aom\_wb\_write\_literal(&wb, output\_frame\_height\_in\_tiles\_minus\_1, 8);
131   aom\_wb\_write\_literal(&wb, num\_tiles\_minus\_1, 16);
132   tl += 4;
133   tile\_list\_obu\_size += 4;
134 
135   \textcolor{comment}{// Write each tile's data}
136   \textcolor{keywordflow}{for} (i = 0; i <= num\_tiles\_minus\_1; i++) \{
137     \hyperlink{structaom__tile__data}{aom\_tile\_data} tile\_data = \{ 0, NULL, 0 \};
138 
139     \textcolor{keywordtype}{int} image\_idx = tiles[i].image\_idx;
140     \textcolor{keywordtype}{int} ref\_idx = tiles[i].reference\_idx;
141     \textcolor{keywordtype}{int} tc = tiles[i].tile\_col;
142     \textcolor{keywordtype}{int} tr = tiles[i].tile\_row;
143 
144     \textcolor{comment}{// Reset bit writer to the right location.}
145     wb.bit\_buffer = tl;
146     wb.bit\_offset = 0;
147 
148     \textcolor{keywordtype}{size\_t} frame\_size = frame\_sizes[image\_idx];
149     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = frames[image\_idx];
150 
151     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
152     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
153 
154     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
155         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(codec, frame, frame\_size, NULL);
156     \textcolor{keywordflow}{if} (aom\_status) die\_codec(codec, \textcolor{stringliteral}{"Failed to decode tile."});
157 
158     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badf1e96275f692bc97ddb4ce2fbdb456e}{AV1D\_GET\_TILE\_DATA}, &tile\_data);
159 
160     \textcolor{comment}{// Copy over tile info.}
161     \textcolor{comment}{//  uint8\_t anchor\_frame\_idx;}
162     \textcolor{comment}{//  uint8\_t tile\_row;}
163     \textcolor{comment}{//  uint8\_t tile\_col;}
164     \textcolor{comment}{//  uint16\_t coded\_tile\_data\_size\_minus\_1;}
165     \textcolor{comment}{//  uint8\_t *coded\_tile\_data;}
166     uint32\_t tile\_info\_bytes = 5;
167     aom\_wb\_write\_literal(&wb, ref\_idx, 8);
168     aom\_wb\_write\_literal(&wb, tr, 8);
169     aom\_wb\_write\_literal(&wb, tc, 8);
170     aom\_wb\_write\_literal(&wb, (\textcolor{keywordtype}{int})tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size} - 1, 16);
171     tl += tile\_info\_bytes;
172 
173     memcpy(tl, (uint8\_t *)tile\_data.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data},
174            tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size});
175     tl += tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
176 
177     tile\_list\_obu\_size +=
178         tile\_info\_bytes + (uint32\_t)tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
179   \}
180 
181   \textcolor{comment}{// Write tile list OBU size.}
182   \textcolor{keywordtype}{size\_t} bytes\_written = 0;
183   \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(tile\_list\_obu\_size, 4, 4, saved\_obu\_size\_loc,
184                                  &bytes\_written))
185     die\_codec(codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
186 
187   \textcolor{comment}{// Copy the tile list.}
188   \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(
189           writer, tl\_buf, tile\_list\_obu\_header\_size + tile\_list\_obu\_size,
190           tl\_pts))
191     die\_codec(codec, \textcolor{stringliteral}{"Failed to copy compressed tile list."});
192 \}
193 
194 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
195   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
196   AvxVideoReader *reader = NULL;
197   AvxVideoWriter *writer = NULL;
198   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
199   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
200   \textcolor{keywordtype}{int} num\_references;
201   \textcolor{keywordtype}{int} i;
202   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts;
203   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *tile\_list\_file = NULL;
204 
205   exec\_name = argv[0];
206   \textcolor{keywordflow}{if} (argc != 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
207 
208   reader = aom\_video\_reader\_open(argv[1]);
209   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
210 
211   num\_references = (int)strtol(argv[3], NULL, 0);
212   info = aom\_video\_reader\_get\_info(reader);
213 
214   aom\_video\_reader\_set\_fourcc(reader, AV1\_FOURCC);
215 
216   \textcolor{comment}{// The writer to write out ivf file in tile list OBU, which can be decoded by}
217   \textcolor{comment}{// AV1 decoder.}
218   writer = aom\_video\_writer\_open(argv[2], kContainerIVF, info);
219   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, argv[2]);
220 
221   tile\_list\_file = argv[4];
222 
223   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
224   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
225   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
226 
227   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
228     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
229 
230   \textcolor{comment}{// Decode anchor frames.}
231   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
232 
233   printf(\textcolor{stringliteral}{"Reading %d reference images.\(\backslash\)n"}, num\_references);
234   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
235     aom\_video\_reader\_read\_frame(reader);
236 
237     \textcolor{keywordtype}{size\_t} frame\_size = 0;
238     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
239         aom\_video\_reader\_get\_frame(reader, &frame\_size);
240     pts = (\hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t})aom\_video\_reader\_get\_frame\_pts(reader);
241 
242     \textcolor{comment}{// Copy references bitstream directly.}
243     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame, frame\_size, pts))
244       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed anchor frame."});
245 
246     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
247       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
248   \}
249 
250   \textcolor{comment}{// Decode camera frames.}
251   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
252   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
253 
254   FILE *infile = aom\_video\_reader\_get\_file(reader);
255   \textcolor{comment}{// Record the offset of the first camera image.}
256   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
257 
258   printf(\textcolor{stringliteral}{"Loading compressed frames into memory.\(\backslash\)n"});
259 
260   \textcolor{comment}{// Count the frames in the lightfield.}
261   \textcolor{keywordtype}{int} num\_frames = 0;
262   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
263     ++num\_frames;
264   \}
265   \textcolor{keywordflow}{if} (num\_frames < 1) die(\textcolor{stringliteral}{"Input light field has no frames."});
266 
267   \textcolor{comment}{// Read all of the lightfield frames into memory.}
268   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames =
269       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *));
270   \textcolor{keywordtype}{size\_t} *frame\_sizes = (\textcolor{keywordtype}{size\_t} *)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));
271   \textcolor{comment}{// Seek to the first camera image.}
272   fseeko(infile, camera\_frame\_pos, SEEK\_SET);
273   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
274     aom\_video\_reader\_read\_frame(reader);
275     \textcolor{keywordtype}{size\_t} frame\_size = 0;
276     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
277         aom\_video\_reader\_get\_frame(reader, &frame\_size);
278     frames[f] = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(frame\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));
279     memcpy(frames[f], frame, frame\_size);
280     frame\_sizes[f] = frame\_size;
281   \}
282   printf(\textcolor{stringliteral}{"Read %d frames.\(\backslash\)n"}, num\_frames);
283 
284   \textcolor{comment}{// Copy first camera frame for getting camera frame header. This is done}
285   \textcolor{comment}{// only once.}
286   \{
287     \textcolor{keywordtype}{size\_t} frame\_size = frame\_sizes[0];
288     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = frames[0];
289     pts = num\_references;
290     \hyperlink{structaom__tile__data}{aom\_tile\_data} frame\_header\_info = \{ 0, NULL, 0 \};
291 
292     \textcolor{comment}{// Need to decode frame header to get camera frame header info. So, here}
293     \textcolor{comment}{// decoding 1 tile is enough.}
294     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, 0);
295     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, AV1\_SET\_DECODE\_TILE\_COL, 0);
296 
297     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
298         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL);
299     \textcolor{keywordflow}{if} (aom\_status) die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode tile."});
300 
301     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baed16ed4514ea1bd2847e607ca880b246}{AV1D\_GET\_FRAME\_HEADER\_INFO}, &
      frame\_header\_info);
302 
303     \textcolor{keywordtype}{size\_t} obu\_size\_offset =
304         (uint8\_t *)frame\_header\_info.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data} - frame;
305     \textcolor{keywordtype}{size\_t} length\_field\_size = frame\_header\_info.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
306     \textcolor{comment}{// Remove ext-tile tile info.}
307     uint32\_t frame\_header\_size = (uint32\_t)frame\_header\_info.\hyperlink{structaom__tile__data_a936851e515bcea0af38d2d091f5adf65}{extra\_size} - 1;
308     \textcolor{keywordtype}{size\_t} bytes\_to\_copy =
309         obu\_size\_offset + length\_field\_size + frame\_header\_size;
310 
311     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame\_hdr\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(bytes\_to\_copy);
312     \textcolor{keywordflow}{if} (frame\_hdr\_buf == NULL)
313       die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate frame header buffer."});
314 
315     memcpy(frame\_hdr\_buf, frame, bytes\_to\_copy);
316 
317     \textcolor{comment}{// Update frame header OBU size.}
318     \textcolor{keywordtype}{size\_t} bytes\_written = 0;
319     \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(
320             frame\_header\_size, length\_field\_size, length\_field\_size,
321             frame\_hdr\_buf + obu\_size\_offset, &bytes\_written))
322       die\_codec(&codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
323 
324     \textcolor{comment}{// Copy camera frame header bitstream.}
325     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame\_hdr\_buf, bytes\_to\_copy,
326                                       pts))
327       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed camera frame header."});
328     free(frame\_hdr\_buf);
329   \}
330 
331   \textcolor{comment}{// Read out the image format.}
332   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
333   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
334     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
335   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bps = get\_image\_bps(ref\_fmt);
336   \textcolor{keywordflow}{if} (!bps) die\_codec(&codec, \textcolor{stringliteral}{"Invalid image format."});
337   \textcolor{comment}{// read out the tile size.}
338   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
339   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
340     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the tile size"});
341   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
342   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
343   \textcolor{comment}{// Allocate a buffer to store tile list bitstream.}
344   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} data\_sz = MAX\_TILES * ALIGN\_POWER\_OF\_TWO(tile\_width, 5) *
345                          ALIGN\_POWER\_OF\_TWO(tile\_height, 5) * bps / 8;
346 
347   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(data\_sz);
348   \textcolor{keywordflow}{if} (tl\_buf == NULL) die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate tile list buffer."});
349 
350   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} tl\_pts = num\_references;
351   \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles\_minus\_1 =
352       output\_frame\_width / tile\_width - 1;
353   \textcolor{keyword}{const} uint8\_t output\_frame\_height\_in\_tiles\_minus\_1 =
354       output\_frame\_height / tile\_height - 1;
355 
356   printf(\textcolor{stringliteral}{"Reading tile list from file.\(\backslash\)n"});
357   \textcolor{keywordtype}{char} line[1024];
358   FILE *tile\_list\_fptr = fopen(tile\_list\_file, \textcolor{stringliteral}{"r"});
359   \textcolor{keywordflow}{if} (!tile\_list\_fptr) die\_codec(&codec, \textcolor{stringliteral}{"Failed to open tile list file."});
360   \textcolor{keywordtype}{int} num\_tiles = 0;
361   TILE\_LIST\_INFO tiles[MAX\_TILES];
362   \textcolor{keywordflow}{while} ((fgets(line, 1024, tile\_list\_fptr)) != NULL) \{
363     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'} || num\_tiles >= MAX\_TILES) \{
364       \textcolor{comment}{// Flush existing tile list and start another, either because we hit a}
365       \textcolor{comment}{// new render frame or because we've hit our max number of tiles per list.}
366       \textcolor{keywordflow}{if} (num\_tiles > 0) \{
367         process\_tile\_list(tiles, num\_tiles, tl\_pts, frames, frame\_sizes, &codec,
368                           tl\_buf, writer, output\_frame\_width\_in\_tiles\_minus\_1,
369                           output\_frame\_height\_in\_tiles\_minus\_1);
370         ++tl\_pts;
371       \}
372       num\_tiles = 0;
373     \}
374     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'}) \{
375       \textcolor{keywordflow}{continue};
376     \}
377     \textcolor{keywordflow}{if} (sscanf(line, \textcolor{stringliteral}{"%d %d %d %d"}, &tiles[num\_tiles].image\_idx,
378                &tiles[num\_tiles].reference\_idx, &tiles[num\_tiles].tile\_col,
379                &tiles[num\_tiles].tile\_row) == 4) \{
380       \textcolor{keywordflow}{if} (tiles[num\_tiles].image\_idx >= num\_frames) \{
381         die(\textcolor{stringliteral}{"Tile list image\_idx out of bounds: %d >= %d."},
382             tiles[num\_tiles].image\_idx, num\_frames);
383       \}
384       \textcolor{keywordflow}{if} (tiles[num\_tiles].reference\_idx >= num\_references) \{
385         die(\textcolor{stringliteral}{"Tile list reference\_idx out of bounds: %d >= %d."},
386             tiles[num\_tiles].reference\_idx, num\_references);
387       \}
388       ++num\_tiles;
389     \}
390   \}
391   \textcolor{keywordflow}{if} (num\_tiles > 0) \{
392     \textcolor{comment}{// Flush out the last tile list.}
393     process\_tile\_list(tiles, num\_tiles, tl\_pts, frames, frame\_sizes, &codec,
394                       tl\_buf, writer, output\_frame\_width\_in\_tiles\_minus\_1,
395                       output\_frame\_height\_in\_tiles\_minus\_1);
396     ++tl\_pts;
397   \}
398 
399   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_tile\_lists = (int)(tl\_pts - pts);
400   printf(\textcolor{stringliteral}{"Finished processing tile lists.  Num tile lists: %d.\(\backslash\)n"},
401          num\_tile\_lists);
402   free(tl\_buf);
403   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
404     free(frames[f]);
405   \}
406   free(frame\_sizes);
407   free(frames);
408   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
409   aom\_video\_writer\_close(writer);
410   aom\_video\_reader\_close(reader);
411 
412   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
413 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomdec}{}\subsection{aomdec}\label{example_aomdec}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <assert.h>}
13 \textcolor{preprocessor}{#include <stdio.h>}
14 \textcolor{preprocessor}{#include <stdlib.h>}
15 \textcolor{preprocessor}{#include <stdarg.h>}
16 \textcolor{preprocessor}{#include <string.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 
19 \textcolor{preprocessor}{#include "config/aom\_config.h"}
20 
21 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
22 \textcolor{preprocessor}{#if HAVE\_UNISTD\_H}
23 \textcolor{preprocessor}{#include <unistd.h>}  \textcolor{comment}{// NOLINT}
24 \textcolor{preprocessor}{#elif !defined(STDOUT\_FILENO)}
25 \textcolor{preprocessor}{#define STDOUT\_FILENO 1}
26 \textcolor{preprocessor}{#endif}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
30 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
31 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
32 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
33 \textcolor{preprocessor}{#include "common/args.h"}
34 \textcolor{preprocessor}{#include "common/ivfdec.h"}
35 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
36 \textcolor{preprocessor}{#include "common/obudec.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 
39 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
40 \textcolor{preprocessor}{#include "common/webmdec.h"}
41 \textcolor{preprocessor}{#endif}
42 
43 \textcolor{preprocessor}{#include "common/rawenc.h"}
44 \textcolor{preprocessor}{#include "common/y4menc.h"}
45 
46 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
47 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
48 \textcolor{preprocessor}{#endif}
49 
50 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
51 
52 \textcolor{keyword}{struct }AvxDecInputContext \{
53   \textcolor{keyword}{struct }AvxInputContext *aom\_input\_ctx;
54   \textcolor{keyword}{struct }ObuDecInputContext *obu\_ctx;
55   \textcolor{keyword}{struct }WebmInputContext *webm\_ctx;
56 \};
57 
58 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
59     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
60 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t looparg =
61     ARG\_DEF(NULL, \textcolor{stringliteral}{"loops"}, 1, \textcolor{stringliteral}{"Number of times to decode the file"});
62 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
63 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
64     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Output raw YV12 frames"});
65 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
66     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Output raw I420 frames"});
67 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t flipuvarg =
68     ARG\_DEF(NULL, \textcolor{stringliteral}{"flipuv"}, 0, \textcolor{stringliteral}{"Flip the chroma planes in the output"});
69 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rawvideo =
70     ARG\_DEF(NULL, \textcolor{stringliteral}{"rawvideo"}, 0, \textcolor{stringliteral}{"Output raw YUV frames"});
71 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noblitarg =
72     ARG\_DEF(NULL, \textcolor{stringliteral}{"noblit"}, 0, \textcolor{stringliteral}{"Don't process the decoded frames"});
73 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t progressarg =
74     ARG\_DEF(NULL, \textcolor{stringliteral}{"progress"}, 0, \textcolor{stringliteral}{"Show progress after each frame decodes"});
75 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limitarg =
76     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop decoding after n frames"});
77 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skiparg =
78     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
79 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t postprocarg =
80     ARG\_DEF(NULL, \textcolor{stringliteral}{"postproc"}, 0, \textcolor{stringliteral}{"Postprocess decoded frames"});
81 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t summaryarg =
82     ARG\_DEF(NULL, \textcolor{stringliteral}{"summary"}, 0, \textcolor{stringliteral}{"Show timing summary"});
83 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
84     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output file name pattern (see below)"});
85 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threadsarg =
86     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max threads to use"});
87 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
88     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show version string"});
89 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t scalearg =
90     ARG\_DEF(\textcolor{stringliteral}{"S"}, \textcolor{stringliteral}{"scale"}, 0, \textcolor{stringliteral}{"Scale output frames uniformly"});
91 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t continuearg =
92     ARG\_DEF(\textcolor{stringliteral}{"k"}, \textcolor{stringliteral}{"keep-going"}, 0, \textcolor{stringliteral}{"(debug) Continue decoding after error"});
93 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fb\_arg =
94     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-buffers"}, 1, \textcolor{stringliteral}{"Number of frame buffers to use"});
95 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t md5arg =
96     ARG\_DEF(NULL, \textcolor{stringliteral}{"md5"}, 0, \textcolor{stringliteral}{"Compute the MD5 sum of the decoded frame"});
97 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framestatsarg =
98     ARG\_DEF(NULL, \textcolor{stringliteral}{"framestats"}, 1, \textcolor{stringliteral}{"Output per-frame stats (.csv format)"});
99 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outbitdeptharg =
100     ARG\_DEF(NULL, \textcolor{stringliteral}{"output-bit-depth"}, 1, \textcolor{stringliteral}{"Output bit-depth for decoded frames"});
101 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t isannexb =
102     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 0, \textcolor{stringliteral}{"Bitstream is in Annex-B format"});
103 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t oppointarg = ARG\_DEF(
104     NULL, \textcolor{stringliteral}{"oppoint"}, 1, \textcolor{stringliteral}{"Select an operating point of a scalable bitstream"});
105 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outallarg = ARG\_DEF(
106     NULL, \textcolor{stringliteral}{"all-layers"}, 0, \textcolor{stringliteral}{"Output all decoded frames of a scalable bitstream"});
107 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skipfilmgrain =
108     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip-film-grain"}, 0, \textcolor{stringliteral}{"Skip film grain application"});
109 
110 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *all\_args[] = \{
111   &help,           &codecarg,   &use\_yv12,      &use\_i420,
112   &flipuvarg,      &rawvideo,   &noblitarg,     &progressarg,
113   &limitarg,       &skiparg,    &postprocarg,   &summaryarg,
114   &outputfile,     &threadsarg, &verbosearg,    &scalearg,
115   &fb\_arg,         &md5arg,     &framestatsarg, &continuearg,
116   &outbitdeptharg, &isannexb,   &oppointarg,    &outallarg,
117   &skipfilmgrain,  NULL
118 \};
119 
120 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
121 \textcolor{keyword}{static} INLINE \textcolor{keywordtype}{int} libyuv\_scale(\hyperlink{structaom__image}{aom\_image\_t} *src, \hyperlink{structaom__image}{aom\_image\_t} *dst,
122                                FilterModeEnum mode) \{
123   \textcolor{keywordflow}{if} (src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
124     assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016});
125     \textcolor{keywordflow}{return} I420Scale\_16(
126         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_Y] / 2,
127         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2,
128         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2,
129         src->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_Y],
130         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_Y] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U],
131         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V],
132         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2, dst->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
133   \}
134   assert(src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
135   assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
136   \textcolor{keywordflow}{return} I420Scale(src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
137                    src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
138                    src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], src->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
139                    src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], dst->
      \hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
140                    dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
141                    dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], dst->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
142                    dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
143 \}
144 \textcolor{preprocessor}{#endif}
145 
146 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
147   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> filename\(\backslash\)n\(\backslash\)n"}, exec\_name);
148 
149   \textcolor{keywordflow}{if} (shorthelp) \{
150     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
151     \textcolor{keywordflow}{return};
152   \}
153 
154   fprintf(fout, \textcolor{stringliteral}{"Options:\(\backslash\)n"});
155   arg\_show\_usage(fout, all\_args);
156   fprintf(fout,
157           \textcolor{stringliteral}{"\(\backslash\)nOutput File Patterns:\(\backslash\)n\(\backslash\)n"}
158           \textcolor{stringliteral}{"  The -o argument specifies the name of the file(s) to "}
159           \textcolor{stringliteral}{"write to. If the\(\backslash\)n  argument does not include any escape "}
160           \textcolor{stringliteral}{"characters, the output will be\(\backslash\)n  written to a single file. "}
161           \textcolor{stringliteral}{"Otherwise, the filename will be calculated by\(\backslash\)n  expanding "}
162           \textcolor{stringliteral}{"the following escape characters:\(\backslash\)n"});
163   fprintf(fout,
164           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%w   - Frame width"}
165           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%h   - Frame height"}
166           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%<n> - Frame number, zero padded to <n> places (1..9)"}
167           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n  Pattern arguments are only supported in conjunction "}
168           \textcolor{stringliteral}{"with the --yv12 and\(\backslash\)n  --i420 options. If the -o option is "}
169           \textcolor{stringliteral}{"not specified, the output will be\(\backslash\)n  directed to stdout.\(\backslash\)n"});
170   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded decoders:\(\backslash\)n\(\backslash\)n"});
171 
172   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_aom\_decoder\_count(); ++i) \{
173     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
174     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s\(\backslash\)n"}, decoder->name,
175             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
176   \}
177 \}
178 
179 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
180   show\_help(stderr, 1);
181   exit(EXIT\_FAILURE);
182 \}
183 
184 \textcolor{keyword}{static} \textcolor{keywordtype}{int} raw\_read\_frame(FILE *infile, uint8\_t **buffer, \textcolor{keywordtype}{size\_t} *bytes\_read,
185                           \textcolor{keywordtype}{size\_t} *buffer\_size) \{
186   \textcolor{keywordtype}{char} raw\_hdr[RAW\_FRAME\_HDR\_SZ];
187   \textcolor{keywordtype}{size\_t} frame\_size = 0;
188 
189   \textcolor{keywordflow}{if} (fread(raw\_hdr, RAW\_FRAME\_HDR\_SZ, 1, infile) != 1) \{
190     \textcolor{keywordflow}{if} (!feof(infile)) warn(\textcolor{stringliteral}{"Failed to read RAW frame size\(\backslash\)n"});
191   \} \textcolor{keywordflow}{else} \{
192     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kCorruptFrameThreshold = 256 * 1024 * 1024;
193     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kFrameTooSmallThreshold = 256 * 1024;
194     frame\_size = mem\_get\_le32(raw\_hdr);
195 
196     \textcolor{keywordflow}{if} (frame\_size > kCorruptFrameThreshold) \{
197       warn(\textcolor{stringliteral}{"Read invalid frame size (%u)\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
198       frame\_size = 0;
199     \}
200 
201     \textcolor{keywordflow}{if} (frame\_size < kFrameTooSmallThreshold) \{
202       warn(\textcolor{stringliteral}{"Warning: Read invalid frame size (%u) - not a raw file?\(\backslash\)n"},
203            (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
204     \}
205 
206     \textcolor{keywordflow}{if} (frame\_size > *buffer\_size) \{
207       uint8\_t *new\_buf = realloc(*buffer, 2 * frame\_size);
208       \textcolor{keywordflow}{if} (new\_buf) \{
209         *buffer = new\_buf;
210         *buffer\_size = 2 * frame\_size;
211       \} \textcolor{keywordflow}{else} \{
212         warn(\textcolor{stringliteral}{"Failed to allocate compressed data buffer\(\backslash\)n"});
213         frame\_size = 0;
214       \}
215     \}
216   \}
217 
218   \textcolor{keywordflow}{if} (!feof(infile)) \{
219     \textcolor{keywordflow}{if} (fread(*buffer, 1, frame\_size, infile) != frame\_size) \{
220       warn(\textcolor{stringliteral}{"Failed to read full frame\(\backslash\)n"});
221       \textcolor{keywordflow}{return} 1;
222     \}
223     *bytes\_read = frame\_size;
224   \}
225 
226   \textcolor{keywordflow}{return} 0;
227 \}
228 
229 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxDecInputContext *input, uint8\_t **buf,
230                       \textcolor{keywordtype}{size\_t} *bytes\_in\_buffer, \textcolor{keywordtype}{size\_t} *buffer\_size) \{
231   \textcolor{keywordflow}{switch} (input->aom\_input\_ctx->file\_type) \{
232 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
233     \textcolor{keywordflow}{case} FILE\_TYPE\_WEBM:
234       \textcolor{keywordflow}{return} webm\_read\_frame(input->webm\_ctx, buf, bytes\_in\_buffer,
235                              buffer\_size);
236 \textcolor{preprocessor}{#endif}
237     \textcolor{keywordflow}{case} FILE\_TYPE\_RAW:
238       \textcolor{keywordflow}{return} raw\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
239                             buffer\_size);
240     \textcolor{keywordflow}{case} FILE\_TYPE\_IVF:
241       \textcolor{keywordflow}{return} ivf\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
242                             buffer\_size, NULL);
243     \textcolor{keywordflow}{case} FILE\_TYPE\_OBU:
244       \textcolor{keywordflow}{return} obudec\_read\_temporal\_unit(input->obu\_ctx, buf, bytes\_in\_buffer,
245                                        buffer\_size);
246     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 1;
247   \}
248 \}
249 
250 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_raw(\textcolor{keyword}{struct} AvxInputContext *input) \{
251   uint8\_t buf[32];
252   \textcolor{keywordtype}{int} is\_raw = 0;
253   \hyperlink{structaom__codec__stream__info}{aom\_codec\_stream\_info\_t} si;
254   memset(&si, 0, \textcolor{keyword}{sizeof}(si));
255 
256   \textcolor{keywordflow}{if} (fread(buf, 1, 32, input->file) == 32) \{
257     \textcolor{keywordtype}{int} i;
258 
259     \textcolor{keywordflow}{if} (mem\_get\_le32(buf) < 256 * 1024 * 1024) \{
260       \textcolor{keywordflow}{for} (i = 0; i < get\_aom\_decoder\_count(); ++i) \{
261         \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
262         \textcolor{keywordflow}{if} (!\hyperlink{group__decoder_ga2544bac9fdc439f0effd6b1b14df54be}{aom\_codec\_peek\_stream\_info}(decoder->codec\_interface(), buf + 4,
263                                         32 - 4, &si)) \{
264           is\_raw = 1;
265           input->fourcc = decoder->fourcc;
266           input->width = si.\hyperlink{structaom__codec__stream__info_add84a2752fefd706f893fbc41ba6b9f2}{w};
267           input->height = si.\hyperlink{structaom__codec__stream__info_a2f1c33e3b980b274176545340b474e34}{h};
268           input->framerate.numerator = 30;
269           input->framerate.denominator = 1;
270           \textcolor{keywordflow}{break};
271         \}
272       \}
273     \}
274   \}
275 
276   rewind(input->file);
277   \textcolor{keywordflow}{return} is\_raw;
278 \}
279 
280 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_progress(\textcolor{keywordtype}{int} frame\_in, \textcolor{keywordtype}{int} frame\_out, uint64\_t dx\_time) \{
281   fprintf(stderr,
282           \textcolor{stringliteral}{"%d decoded frames/%d showed frames in %"} PRId64 \textcolor{stringliteral}{" us (%.2f fps)\(\backslash\)r"},
283           frame\_in, frame\_out, dx\_time,
284           (\textcolor{keywordtype}{double})frame\_out * 1000000.0 / (\textcolor{keywordtype}{double})dx\_time);
285 \}
286 
287 \textcolor{keyword}{struct }ExternalFrameBuffer \{
288   uint8\_t *data;
289   \textcolor{keywordtype}{size\_t} size;
290   \textcolor{keywordtype}{int} in\_use;
291 \};
292 
293 \textcolor{keyword}{struct }ExternalFrameBufferList \{
294   \textcolor{keywordtype}{int} num\_external\_frame\_buffers;
295   \textcolor{keyword}{struct }ExternalFrameBuffer *ext\_fb;
296 \};
297 
298 \textcolor{comment}{// Callback used by libaom to request an external frame buffer. |cb\_priv|}
299 \textcolor{comment}{// Application private data passed into the set function. |min\_size| is the}
300 \textcolor{comment}{// minimum size in bytes needed to decode the next frame. |fb| pointer to the}
301 \textcolor{comment}{// frame buffer.}
302 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv, \textcolor{keywordtype}{size\_t} min\_size,
303                                 \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
304   \textcolor{keywordtype}{int} i;
305   \textcolor{keyword}{struct }ExternalFrameBufferList *\textcolor{keyword}{const} ext\_fb\_list =
306       (\textcolor{keyword}{struct }ExternalFrameBufferList *)cb\_priv;
307   \textcolor{keywordflow}{if} (ext\_fb\_list == NULL) \textcolor{keywordflow}{return} -1;
308 
309   \textcolor{comment}{// Find a free frame buffer.}
310   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list->num\_external\_frame\_buffers; ++i) \{
311     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].in\_use) \textcolor{keywordflow}{break};
312   \}
313 
314   \textcolor{keywordflow}{if} (i == ext\_fb\_list->num\_external\_frame\_buffers) \textcolor{keywordflow}{return} -1;
315 
316   \textcolor{keywordflow}{if} (ext\_fb\_list->ext\_fb[i].size < min\_size) \{
317     free(ext\_fb\_list->ext\_fb[i].data);
318     ext\_fb\_list->ext\_fb[i].data = (uint8\_t *)calloc(min\_size, \textcolor{keyword}{sizeof}(uint8\_t));
319     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].data) \textcolor{keywordflow}{return} -1;
320 
321     ext\_fb\_list->ext\_fb[i].size = min\_size;
322   \}
323 
324   fb->\hyperlink{structaom__codec__frame__buffer_a4b73719e1d6756516de8cbceb68822d2}{data} = ext\_fb\_list->ext\_fb[i].data;
325   fb->\hyperlink{structaom__codec__frame__buffer_a6fc24049c4e1706ce3a462825009f3d4}{size} = ext\_fb\_list->ext\_fb[i].size;
326   ext\_fb\_list->ext\_fb[i].in\_use = 1;
327 
328   \textcolor{comment}{// Set the frame buffer's private data to point at the external frame buffer.}
329   fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv} = &ext\_fb\_list->ext\_fb[i];
330   \textcolor{keywordflow}{return} 0;
331 \}
332 
333 \textcolor{comment}{// Callback used by libaom when there are no references to the frame buffer.}
334 \textcolor{comment}{// |cb\_priv| user private data passed into the set function. |fb| pointer}
335 \textcolor{comment}{// to the frame buffer.}
336 \textcolor{keyword}{static} \textcolor{keywordtype}{int} release\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv,
337                                     \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
338   \textcolor{keyword}{struct }ExternalFrameBuffer *\textcolor{keyword}{const} ext\_fb =
339       (\textcolor{keyword}{struct }ExternalFrameBuffer *)fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv};
340   (\textcolor{keywordtype}{void})cb\_priv;
341   ext\_fb->in\_use = 0;
342   \textcolor{keywordflow}{return} 0;
343 \}
344 
345 \textcolor{keyword}{static} \textcolor{keywordtype}{void} generate\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *pattern, \textcolor{keywordtype}{char} *out, \textcolor{keywordtype}{size\_t} q\_len,
346                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_h,
347                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in) \{
348   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = pattern;
349   \textcolor{keywordtype}{char} *q = out;
350 
351   \textcolor{keywordflow}{do} \{
352     \textcolor{keywordtype}{char} *next\_pat = strchr(p, \textcolor{charliteral}{'%'});
353 
354     \textcolor{keywordflow}{if} (p == next\_pat) \{
355       \textcolor{keywordtype}{size\_t} pat\_len;
356 
357       \textcolor{comment}{/* parse the pattern */}
358       q[q\_len - 1] = \textcolor{charliteral}{'\(\backslash\)0'};
359       \textcolor{keywordflow}{switch} (p[1]) \{
360         \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_w); \textcolor{keywordflow}{break};
361         \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_h); \textcolor{keywordflow}{break};
362         \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, frame\_in); \textcolor{keywordflow}{break};
363         \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%02d"}, frame\_in); \textcolor{keywordflow}{break};
364         \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%03d"}, frame\_in); \textcolor{keywordflow}{break};
365         \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%04d"}, frame\_in); \textcolor{keywordflow}{break};
366         \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%05d"}, frame\_in); \textcolor{keywordflow}{break};
367         \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%06d"}, frame\_in); \textcolor{keywordflow}{break};
368         \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%07d"}, frame\_in); \textcolor{keywordflow}{break};
369         \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%08d"}, frame\_in); \textcolor{keywordflow}{break};
370         \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%09d"}, frame\_in); \textcolor{keywordflow}{break};
371         \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Unrecognized pattern %%%c\(\backslash\)n"}, p[1]); \textcolor{keywordflow}{break};
372       \}
373 
374       pat\_len = strlen(q);
375       \textcolor{keywordflow}{if} (pat\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
376       q += pat\_len;
377       p += 2;
378       q\_len -= pat\_len;
379     \} \textcolor{keywordflow}{else} \{
380       \textcolor{keywordtype}{size\_t} copy\_len;
381 
382       \textcolor{comment}{/* copy the next segment */}
383       \textcolor{keywordflow}{if} (!next\_pat)
384         copy\_len = strlen(p);
385       \textcolor{keywordflow}{else}
386         copy\_len = next\_pat - p;
387 
388       \textcolor{keywordflow}{if} (copy\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
389 
390       memcpy(q, p, copy\_len);
391       q[copy\_len] = \textcolor{charliteral}{'\(\backslash\)0'};
392       q += copy\_len;
393       p += copy\_len;
394       q\_len -= copy\_len;
395     \}
396   \} \textcolor{keywordflow}{while} (*p);
397 \}
398 
399 \textcolor{keyword}{static} \textcolor{keywordtype}{int} is\_single\_file(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern) \{
400   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = outfile\_pattern;
401 
402   \textcolor{keywordflow}{do} \{
403     p = strchr(p, \textcolor{charliteral}{'%'});
404     \textcolor{keywordflow}{if} (p && p[1] >= \textcolor{charliteral}{'1'} && p[1] <= \textcolor{charliteral}{'9'})
405       \textcolor{keywordflow}{return} 0;  \textcolor{comment}{// pattern contains sequence number, so it's not unique}
406     \textcolor{keywordflow}{if} (p) p++;
407   \} \textcolor{keywordflow}{while} (p);
408 
409   \textcolor{keywordflow}{return} 1;
410 \}
411 
412 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16], \textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename) \{
413   \textcolor{keywordtype}{int} i;
414 
415   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) printf(\textcolor{stringliteral}{"%02x"}, digest[i]);
416   printf(\textcolor{stringliteral}{"  %s\(\backslash\)n"}, filename);
417 \}
418 
419 \textcolor{keyword}{static} FILE *open\_outfile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name) \{
420   \textcolor{keywordflow}{if} (strcmp(\textcolor{stringliteral}{"-"}, name) == 0) \{
421     set\_binary\_mode(stdout);
422     \textcolor{keywordflow}{return} stdout;
423   \} \textcolor{keywordflow}{else} \{
424     FILE *file = fopen(name, \textcolor{stringliteral}{"wb"});
425     \textcolor{keywordflow}{if} (!file) fatal(\textcolor{stringliteral}{"Failed to open output file '%s'"}, name);
426     \textcolor{keywordflow}{return} file;
427   \}
428 \}
429 
430 \textcolor{keyword}{static} \textcolor{keywordtype}{int} main\_loop(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
431   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
432   \textcolor{keywordtype}{char} *fn = NULL;
433   \textcolor{keywordtype}{int} i;
434   \textcolor{keywordtype}{int} ret = EXIT\_FAILURE;
435   uint8\_t *buf = NULL;
436   \textcolor{keywordtype}{size\_t} bytes\_in\_buffer = 0, buffer\_size = 0;
437   FILE *infile;
438   \textcolor{keywordtype}{int} frame\_in = 0, frame\_out = 0, flipuv = 0, noblit = 0;
439   \textcolor{keywordtype}{int} do\_md5 = 0, progress = 0;
440   \textcolor{keywordtype}{int} stop\_after = 0, postproc = 0, summary = 0, quiet = 1;
441   \textcolor{keywordtype}{int} arg\_skip = 0;
442   \textcolor{keywordtype}{int} keep\_going = 0;
443   \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{interface }= NULL;
444   \textcolor{keyword}{const} AvxInterface *fourcc\_interface = NULL;
445   uint64\_t dx\_time = 0;
446   \textcolor{keyword}{struct }arg arg;
447   \textcolor{keywordtype}{char} **argv, **argi, **argj;
448 
449   \textcolor{keywordtype}{int} single\_file;
450   \textcolor{keywordtype}{int} use\_y4m = 1;
451   \textcolor{keywordtype}{int} opt\_yv12 = 0;
452   \textcolor{keywordtype}{int} opt\_i420 = 0;
453   \textcolor{keywordtype}{int} opt\_raw = 0;
454   \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
455   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fixed\_output\_bit\_depth = 0;
456   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} is\_annexb = 0;
457   \textcolor{keywordtype}{int} frames\_corrupted = 0;
458   \textcolor{keywordtype}{int} dec\_flags = 0;
459   \textcolor{keywordtype}{int} do\_scale = 0;
460   \textcolor{keywordtype}{int} operating\_point = 0;
461   \textcolor{keywordtype}{int} output\_all\_layers = 0;
462   \textcolor{keywordtype}{int} skip\_film\_grain = 0;
463   \hyperlink{structaom__image}{aom\_image\_t} *scaled\_img = NULL;
464   \hyperlink{structaom__image}{aom\_image\_t} *img\_shifted = NULL;
465   \textcolor{keywordtype}{int} frame\_avail, got\_data, flush\_decoder = 0;
466   \textcolor{keywordtype}{int} num\_external\_frame\_buffers = 0;
467   \textcolor{keyword}{struct }ExternalFrameBufferList ext\_fb\_list = \{ 0, NULL \};
468 
469   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern = NULL;
470   \textcolor{keywordtype}{char} outfile\_name[PATH\_MAX] = \{ 0 \};
471   FILE *outfile = NULL;
472 
473   FILE *framestats\_file = NULL;
474 
475   MD5Context md5\_ctx;
476   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} md5\_digest[16];
477 
478   \textcolor{keyword}{struct }AvxDecInputContext input = \{ NULL, NULL, NULL \};
479   \textcolor{keyword}{struct }AvxInputContext aom\_input\_ctx;
480   memset(&aom\_input\_ctx, 0, \textcolor{keyword}{sizeof}(aom\_input\_ctx));
481 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
482   \textcolor{keyword}{struct }WebmInputContext webm\_ctx;
483   memset(&webm\_ctx, 0, \textcolor{keyword}{sizeof}(webm\_ctx));
484   input.webm\_ctx = &webm\_ctx;
485 \textcolor{preprocessor}{#endif}
486   \textcolor{keyword}{struct }ObuDecInputContext obu\_ctx = \{ NULL, NULL, 0, 0, 0 \};
487   \textcolor{keywordtype}{int} is\_ivf = 0;
488 
489   obu\_ctx.avx\_ctx = &aom\_input\_ctx;
490   input.obu\_ctx = &obu\_ctx;
491   input.aom\_input\_ctx = &aom\_input\_ctx;
492 
493   \textcolor{comment}{/* Parse command line */}
494   exec\_name = argv\_[0];
495   argv = argv\_dup(argc - 1, argv\_ + 1);
496 
497   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
498     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
499     arg.argv\_step = 1;
500 
501     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
502       show\_help(stdout, 0);
503       exit(EXIT\_SUCCESS);
504     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
505       \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_name(arg.val);
506       \textcolor{keywordflow}{if} (!interface)
507         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
508     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
509       \textcolor{comment}{// no-op}
510     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
511       outfile\_pattern = arg.val;
512     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi)) \{
513       use\_y4m = 0;
514       flipuv = 1;
515       opt\_yv12 = 1;
516       opt\_i420 = 0;
517       opt\_raw = 0;
518     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi)) \{
519       use\_y4m = 0;
520       flipuv = 0;
521       opt\_yv12 = 0;
522       opt\_i420 = 1;
523       opt\_raw = 0;
524     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rawvideo, argi)) \{
525       use\_y4m = 0;
526       opt\_yv12 = 0;
527       opt\_i420 = 0;
528       opt\_raw = 1;
529     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &flipuvarg, argi)) \{
530       flipuv = 1;
531     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &noblitarg, argi)) \{
532       noblit = 1;
533     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &progressarg, argi)) \{
534       progress = 1;
535     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limitarg, argi)) \{
536       stop\_after = arg\_parse\_uint(&arg);
537     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skiparg, argi)) \{
538       arg\_skip = arg\_parse\_uint(&arg);
539     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &postprocarg, argi)) \{
540       postproc = 1;
541     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &md5arg, argi)) \{
542       do\_md5 = 1;
543     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framestatsarg, argi)) \{
544       framestats\_file = fopen(arg.val, \textcolor{stringliteral}{"w"});
545       \textcolor{keywordflow}{if} (!framestats\_file) \{
546         die(\textcolor{stringliteral}{"Error: Could not open --framestats file (%s) for writing.\(\backslash\)n"},
547             arg.val);
548       \}
549     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &summaryarg, argi)) \{
550       summary = 1;
551     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threadsarg, argi)) \{
552       cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads} = arg\_parse\_uint(&arg);
553 \textcolor{preprocessor}{#if !CONFIG\_MULTITHREAD}
554       \textcolor{keywordflow}{if} (cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads} > 1) \{
555         die(\textcolor{stringliteral}{"Error: --threads=%d is not supported when CONFIG\_MULTITHREAD = "}
556             \textcolor{stringliteral}{"0.\(\backslash\)n"},
557             cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads});
558       \}
559 \textcolor{preprocessor}{#endif}
560     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi)) \{
561       quiet = 0;
562     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &scalearg, argi)) \{
563       do\_scale = 1;
564     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fb\_arg, argi)) \{
565       num\_external\_frame\_buffers = arg\_parse\_uint(&arg);
566     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &continuearg, argi)) \{
567       keep\_going = 1;
568     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outbitdeptharg, argi)) \{
569       fixed\_output\_bit\_depth = arg\_parse\_uint(&arg);
570     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &isannexb, argi)) \{
571       is\_annexb = 1;
572       input.obu\_ctx->is\_annexb = 1;
573     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &oppointarg, argi)) \{
574       operating\_point = arg\_parse\_int(&arg);
575     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outallarg, argi)) \{
576       output\_all\_layers = 1;
577     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skipfilmgrain, argi)) \{
578       skip\_film\_grain = 1;
579     \} \textcolor{keywordflow}{else} \{
580       argj++;
581     \}
582   \}
583 
584   \textcolor{comment}{/* Check for unrecognized options */}
585   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
586     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && strlen(argi[0]) > 1)
587       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
588 
589   \textcolor{comment}{/* Handle non-option arguments */}
590   fn = argv[0];
591 
592   \textcolor{keywordflow}{if} (!fn) \{
593     free(argv);
594     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
595     usage\_exit();
596   \}
597   \textcolor{comment}{/* Open file */}
598   infile = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"rb"}) : set\_binary\_mode(stdin);
599 
600   \textcolor{keywordflow}{if} (!infile) \{
601     fatal(\textcolor{stringliteral}{"Failed to open input file '%s'"}, strcmp(fn, \textcolor{stringliteral}{"-"}) ? fn : \textcolor{stringliteral}{"stdin"});
602   \}
603 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
604   \textcolor{comment}{/* Make sure we don't dump to the terminal, unless forced to with -o - */}
605   \textcolor{keywordflow}{if} (!outfile\_pattern && isatty(STDOUT\_FILENO) && !do\_md5 && !noblit) \{
606     fprintf(stderr,
607             \textcolor{stringliteral}{"Not dumping raw video to your terminal. Use '-o -' to "}
608             \textcolor{stringliteral}{"override.\(\backslash\)n"});
609     \textcolor{keywordflow}{return} EXIT\_FAILURE;
610   \}
611 \textcolor{preprocessor}{#endif}
612   input.aom\_input\_ctx->filename = fn;
613   input.aom\_input\_ctx->file = infile;
614   \textcolor{keywordflow}{if} (file\_is\_ivf(input.aom\_input\_ctx)) \{
615     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_IVF;
616     is\_ivf = 1;
617   \}
618 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
619   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_webm(input.webm\_ctx, input.aom\_input\_ctx))
620     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_WEBM;
621 \textcolor{preprocessor}{#endif}
622   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_obu(&obu\_ctx))
623     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_OBU;
624   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_raw(input.aom\_input\_ctx))
625     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_RAW;
626   \textcolor{keywordflow}{else} \{
627     fprintf(stderr, \textcolor{stringliteral}{"Unrecognized input file type.\(\backslash\)n"});
628 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
629     fprintf(stderr, \textcolor{stringliteral}{"aomdec was built without WebM container support.\(\backslash\)n"});
630 \textcolor{preprocessor}{#endif}
631     \textcolor{keywordflow}{return} EXIT\_FAILURE;
632   \}
633 
634   outfile\_pattern = outfile\_pattern ? outfile\_pattern : \textcolor{stringliteral}{"-"};
635   single\_file = is\_single\_file(outfile\_pattern);
636 
637   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
638     generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX,
639                       aom\_input\_ctx.width, aom\_input\_ctx.height, 0);
640     \textcolor{keywordflow}{if} (do\_md5)
641       MD5Init(&md5\_ctx);
642     \textcolor{keywordflow}{else}
643       outfile = open\_outfile(outfile\_name);
644   \}
645 
646   \textcolor{keywordflow}{if} (use\_y4m && !noblit) \{
647     \textcolor{keywordflow}{if} (!single\_file) \{
648       fprintf(stderr,
649               \textcolor{stringliteral}{"YUV4MPEG2 not supported with output patterns,"}
650               \textcolor{stringliteral}{" try --i420 or --yv12 or --rawvideo.\(\backslash\)n"});
651       \textcolor{keywordflow}{return} EXIT\_FAILURE;
652     \}
653 
654 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
655     \textcolor{keywordflow}{if} (aom\_input\_ctx.file\_type == FILE\_TYPE\_WEBM) \{
656       \textcolor{keywordflow}{if} (webm\_guess\_framerate(input.webm\_ctx, input.aom\_input\_ctx)) \{
657         fprintf(stderr,
658                 \textcolor{stringliteral}{"Failed to guess framerate -- error parsing "}
659                 \textcolor{stringliteral}{"webm file?\(\backslash\)n"});
660         \textcolor{keywordflow}{return} EXIT\_FAILURE;
661       \}
662     \}
663 \textcolor{preprocessor}{#endif}
664   \}
665 
666   fourcc\_interface = get\_aom\_decoder\_by\_fourcc(aom\_input\_ctx.fourcc);
667 
668   \textcolor{keywordflow}{if} (is\_ivf && !fourcc\_interface)
669     fatal(\textcolor{stringliteral}{"Unsupported fourcc: %x\(\backslash\)n"}, aom\_input\_ctx.fourcc);
670 
671   \textcolor{keywordflow}{if} (interface && fourcc\_interface && interface != fourcc\_interface)
672     warn(\textcolor{stringliteral}{"Header indicates codec: %s\(\backslash\)n"}, fourcc\_interface->name);
673   \textcolor{keywordflow}{else}
674     \textcolor{keyword}{interface }= fourcc\_interface;
675 
676   \textcolor{keywordflow}{if} (!interface) \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_index(0);
677 
678   dec\_flags = (postproc ? \hyperlink{group__decoder_ga7b6c145833964c9edd3ff78be017f7ec}{AOM\_CODEC\_USE\_POSTPROC} : 0);
679   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&decoder, interface->codec\_interface(), &cfg,
680                          dec\_flags)) \{
681     fprintf(stderr, \textcolor{stringliteral}{"Failed to initialize decoder: %s\(\backslash\)n"},
682             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
683     \textcolor{keywordflow}{goto} fail2;
684   \}
685 
686   \textcolor{keywordflow}{if} (!quiet) fprintf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, decoder.\hyperlink{structaom__codec__ctx_a3aa8abff3e05d2fbbf4f5a9fa0575f2b}{name});
687 
688   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, is\_annexb)) \{
689     fprintf(stderr, \textcolor{stringliteral}{"Failed to set is\_annexb: %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
690     \textcolor{keywordflow}{goto} fail;
691   \}
692 
693   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa8b955fc5a2f6e33c6dad858d7c15f67}{AV1D\_SET\_OPERATING\_POINT}, 
      operating\_point)) \{
694     fprintf(stderr, \textcolor{stringliteral}{"Failed to set operating\_point: %s\(\backslash\)n"},
695             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
696     \textcolor{keywordflow}{goto} fail;
697   \}
698 
699   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba8d51f96b8877b665225f5cfaa73ded8e}{AV1D\_SET\_OUTPUT\_ALL\_LAYERS},
700                         output\_all\_layers)) \{
701     fprintf(stderr, \textcolor{stringliteral}{"Failed to set output\_all\_layers: %s\(\backslash\)n"},
702             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
703     \textcolor{keywordflow}{goto} fail;
704   \}
705 
706   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba17fa09c9ce1ae4a68eae21efd219418b}{AV1D\_SET\_SKIP\_FILM\_GRAIN}, 
      skip\_film\_grain)) \{
707     fprintf(stderr, \textcolor{stringliteral}{"Failed to set skip\_film\_grain: %s\(\backslash\)n"},
708             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
709     \textcolor{keywordflow}{goto} fail;
710   \}
711 
712   \textcolor{keywordflow}{if} (arg\_skip) fprintf(stderr, \textcolor{stringliteral}{"Skipping first %d frames.\(\backslash\)n"}, arg\_skip);
713   \textcolor{keywordflow}{while} (arg\_skip) \{
714     \textcolor{keywordflow}{if} (read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \textcolor{keywordflow}{break};
715     arg\_skip--;
716   \}
717 
718   \textcolor{keywordflow}{if} (num\_external\_frame\_buffers > 0) \{
719     ext\_fb\_list.num\_external\_frame\_buffers = num\_external\_frame\_buffers;
720     ext\_fb\_list.ext\_fb = (\textcolor{keyword}{struct }ExternalFrameBuffer *)calloc(
721         num\_external\_frame\_buffers, \textcolor{keyword}{sizeof}(*ext\_fb\_list.ext\_fb));
722     \textcolor{keywordflow}{if} (\hyperlink{group__cap__external__frame__buffer_ga1818a812e4d1e70eeafbe5b0ee538d6e}{aom\_codec\_set\_frame\_buffer\_functions}(&decoder, 
      get\_av1\_frame\_buffer,
723                                              release\_av1\_frame\_buffer,
724                                              &ext\_fb\_list)) \{
725       fprintf(stderr, \textcolor{stringliteral}{"Failed to configure external frame buffers: %s\(\backslash\)n"},
726               \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
727       \textcolor{keywordflow}{goto} fail;
728     \}
729   \}
730 
731   frame\_avail = 1;
732   got\_data = 0;
733 
734   \textcolor{keywordflow}{if} (framestats\_file) fprintf(framestats\_file, \textcolor{stringliteral}{"bytes,qp\(\backslash\)r\(\backslash\)n"});
735 
736   \textcolor{comment}{/* Decode file */}
737   \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
738     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
739     \hyperlink{structaom__image}{aom\_image\_t} *img;
740     \textcolor{keyword}{struct }aom\_usec\_timer timer;
741     \textcolor{keywordtype}{int} corrupted = 0;
742 
743     frame\_avail = 0;
744     \textcolor{keywordflow}{if} (!stop\_after || frame\_in < stop\_after) \{
745       \textcolor{keywordflow}{if} (!read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \{
746         frame\_avail = 1;
747         frame\_in++;
748 
749         aom\_usec\_timer\_start(&timer);
750 
751         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, buf, bytes\_in\_buffer, NULL)) \{
752           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(&decoder);
753           warn(\textcolor{stringliteral}{"Failed to decode frame %d: %s"}, frame\_in,
754                \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
755 
756           \textcolor{keywordflow}{if} (detail) warn(\textcolor{stringliteral}{"Additional information: %s"}, detail);
757           \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
758         \}
759 
760         \textcolor{keywordflow}{if} (framestats\_file) \{
761           \textcolor{keywordtype}{int} qp;
762           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa984acc8b42df9c7d18fc3556a14fd29}{AOMD\_GET\_LAST\_QUANTIZER}, &qp)) \{
763             warn(\textcolor{stringliteral}{"Failed AOMD\_GET\_LAST\_QUANTIZER: %s"},
764                  \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
765             \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
766           \}
767           fprintf(framestats\_file, \textcolor{stringliteral}{"%d,%d\(\backslash\)r\(\backslash\)n"}, (\textcolor{keywordtype}{int})bytes\_in\_buffer, qp);
768         \}
769 
770         aom\_usec\_timer\_mark(&timer);
771         dx\_time += aom\_usec\_timer\_elapsed(&timer);
772       \} \textcolor{keywordflow}{else} \{
773         flush\_decoder = 1;
774       \}
775     \} \textcolor{keywordflow}{else} \{
776       flush\_decoder = 1;
777     \}
778 
779     aom\_usec\_timer\_start(&timer);
780 
781     \textcolor{keywordflow}{if} (flush\_decoder) \{
782       \textcolor{comment}{// Flush the decoder.}
783       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, NULL, 0, NULL)) \{
784         warn(\textcolor{stringliteral}{"Failed to flush decoder: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
785       \}
786     \}
787 
788     aom\_usec\_timer\_mark(&timer);
789     dx\_time += aom\_usec\_timer\_elapsed(&timer);
790 
791     got\_data = 0;
792     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&decoder, &iter))) \{
793       ++frame\_out;
794       got\_data = 1;
795 
796       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba159ddb748cb69956226b7c13e3890ff6}{AOMD\_GET\_FRAME\_CORRUPTED}, &
      corrupted)) \{
797         warn(\textcolor{stringliteral}{"Failed AOM\_GET\_FRAME\_CORRUPTED: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
798         \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
799       \}
800       frames\_corrupted += corrupted;
801 
802       \textcolor{keywordflow}{if} (progress) show\_progress(frame\_in, frame\_out, dx\_time);
803 
804       \textcolor{keywordflow}{if} (!noblit) \{
805         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YUV[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a0845e9194541329c0f77b4bd6a38cc7c}{AOM\_PLANE\_U}, AOM\_PLANE\_V \};
806         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YVU[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a32a43f20adb01d846af1925189c37495}{AOM\_PLANE\_V}, AOM\_PLANE\_U \};
807         \textcolor{keyword}{const} \textcolor{keywordtype}{int} *planes = flipuv ? PLANES\_YVU : PLANES\_YUV;
808 
809         \textcolor{keywordflow}{if} (do\_scale) \{
810           \textcolor{keywordflow}{if} (frame\_out == 1) \{
811             \textcolor{comment}{// If the output frames are to be scaled to a fixed display size}
812             \textcolor{comment}{// then use the width and height specified in the container. If}
813             \textcolor{comment}{// either of these is set to 0, use the display size set in the}
814             \textcolor{comment}{// first frame header. If that is unavailable, use the raw decoded}
815             \textcolor{comment}{// size of the first decoded frame.}
816             \textcolor{keywordtype}{int} render\_width = aom\_input\_ctx.width;
817             \textcolor{keywordtype}{int} render\_height = aom\_input\_ctx.height;
818             \textcolor{keywordflow}{if} (!render\_width || !render\_height) \{
819               \textcolor{keywordtype}{int} render\_size[2];
820               \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba592a5d1390204d743ddfe7bfe8ef177c}{AV1D\_GET\_DISPLAY\_SIZE},
821                                     render\_size)) \{
822                 \textcolor{comment}{// As last resort use size of first frame as display size.}
823                 render\_width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
824                 render\_height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
825               \} \textcolor{keywordflow}{else} \{
826                 render\_width = render\_size[0];
827                 render\_height = render\_size[1];
828               \}
829             \}
830             scaled\_img =
831                 \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, render\_width, render\_height, 16);
832             scaled\_img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
833             scaled\_img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome} = img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome};
834             scaled\_img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp} = img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp};
835           \}
836 
837           \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != scaled\_img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != scaled\_img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}) \{
838 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
839             libyuv\_scale(img, scaled\_img, kFilterBox);
840             img = scaled\_img;
841 \textcolor{preprocessor}{#else}
842             fprintf(
843                 stderr,
844                 \textcolor{stringliteral}{"Failed to scale output frame: %s.\(\backslash\)n"}
845                 \textcolor{stringliteral}{"libyuv is required for scaling but is currently disabled.\(\backslash\)n"}
846                 \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running cmake.\(\backslash\)n"},
847                 \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
848             \textcolor{keywordflow}{goto} fail;
849 \textcolor{preprocessor}{#endif}
850           \}
851         \}
852         \textcolor{comment}{// Default to codec bit depth if output bit depth not set}
853         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} output\_bit\_depth;
854         \textcolor{keywordflow}{if} (!fixed\_output\_bit\_depth && single\_file) \{
855           output\_bit\_depth = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
856         \} \textcolor{keywordflow}{else} \{
857           output\_bit\_depth = fixed\_output\_bit\_depth;
858         \}
859         \textcolor{comment}{// Shift up or down if necessary}
860         \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
861           aom\_shift\_img(output\_bit\_depth, &img, &img\_shifted);
862 
863         aom\_input\_ctx.width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
864         aom\_input\_ctx.height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
865 
866         \textcolor{keywordtype}{int} num\_planes = (opt\_raw && img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome}) ? 1 : 3;
867         \textcolor{keywordflow}{if} (single\_file) \{
868           \textcolor{keywordflow}{if} (use\_y4m) \{
869             \textcolor{keywordtype}{char} y4m\_buf[Y4M\_BUFFER\_SIZE] = \{ 0 \};
870             \textcolor{keywordtype}{size\_t} len = 0;
871             \textcolor{keywordflow}{if} (frame\_out == 1) \{
872               \textcolor{comment}{// Y4M file header}
873               len = y4m\_write\_file\_header(
874                   y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf), aom\_input\_ctx.width,
875                   aom\_input\_ctx.height, &aom\_input\_ctx.framerate,
876                   img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome}, img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp}, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, img->
      \hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth});
877               \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp} == \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba01ef7204c2234ef43acfd493d5e18c84}{AOM\_CSP\_COLOCATED}) \{
878                 fprintf(stderr,
879                         \textcolor{stringliteral}{"Warning: Y4M lacks a colorspace for colocated "}
880                         \textcolor{stringliteral}{"chroma. Using a placeholder.\(\backslash\)n"});
881               \}
882               \textcolor{keywordflow}{if} (do\_md5) \{
883                 MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
884               \} \textcolor{keywordflow}{else} \{
885                 fputs(y4m\_buf, outfile);
886               \}
887             \}
888 
889             \textcolor{comment}{// Y4M frame header}
890             len = y4m\_write\_frame\_header(y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf));
891             \textcolor{keywordflow}{if} (do\_md5) \{
892               MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
893               y4m\_update\_image\_md5(img, planes, &md5\_ctx);
894             \} \textcolor{keywordflow}{else} \{
895               fputs(y4m\_buf, outfile);
896               y4m\_write\_image\_file(img, planes, outfile);
897             \}
898           \} \textcolor{keywordflow}{else} \{
899             \textcolor{keywordflow}{if} (frame\_out == 1) \{
900               \textcolor{comment}{// Check if --yv12 or --i420 options are consistent with the}
901               \textcolor{comment}{// bit-stream decoded}
902               \textcolor{keywordflow}{if} (opt\_i420) \{
903                 \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
904                     img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
905                   fprintf(stderr,
906                           \textcolor{stringliteral}{"Cannot produce i420 output for bit-stream.\(\backslash\)n"});
907                   \textcolor{keywordflow}{goto} fail;
908                 \}
909               \}
910               \textcolor{keywordflow}{if} (opt\_yv12) \{
911                 \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
912                      img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) ||
913                     img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} != 8) \{
914                   fprintf(stderr,
915                           \textcolor{stringliteral}{"Cannot produce yv12 output for bit-stream.\(\backslash\)n"});
916                   \textcolor{keywordflow}{goto} fail;
917                 \}
918               \}
919             \}
920             \textcolor{keywordflow}{if} (do\_md5) \{
921               raw\_update\_image\_md5(img, planes, num\_planes, &md5\_ctx);
922             \} \textcolor{keywordflow}{else} \{
923               raw\_write\_image\_file(img, planes, num\_planes, outfile);
924             \}
925           \}
926         \} \textcolor{keywordflow}{else} \{
927           generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
928                             img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, frame\_in);
929           \textcolor{keywordflow}{if} (do\_md5) \{
930             MD5Init(&md5\_ctx);
931             \textcolor{keywordflow}{if} (use\_y4m) \{
932               y4m\_update\_image\_md5(img, planes, &md5\_ctx);
933             \} \textcolor{keywordflow}{else} \{
934               raw\_update\_image\_md5(img, planes, num\_planes, &md5\_ctx);
935             \}
936             MD5Final(md5\_digest, &md5\_ctx);
937             print\_md5(md5\_digest, outfile\_name);
938           \} \textcolor{keywordflow}{else} \{
939             outfile = open\_outfile(outfile\_name);
940             \textcolor{keywordflow}{if} (use\_y4m) \{
941               y4m\_write\_image\_file(img, planes, outfile);
942             \} \textcolor{keywordflow}{else} \{
943               raw\_write\_image\_file(img, planes, num\_planes, outfile);
944             \}
945             fclose(outfile);
946           \}
947         \}
948       \}
949     \}
950   \}
951 
952   \textcolor{keywordflow}{if} (summary || progress) \{
953     show\_progress(frame\_in, frame\_out, dx\_time);
954     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
955   \}
956 
957   \textcolor{keywordflow}{if} (frames\_corrupted) \{
958     fprintf(stderr, \textcolor{stringliteral}{"WARNING: %d frames corrupted.\(\backslash\)n"}, frames\_corrupted);
959   \} \textcolor{keywordflow}{else} \{
960     ret = EXIT\_SUCCESS;
961   \}
962 
963 fail:
964 
965   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&decoder)) \{
966     fprintf(stderr, \textcolor{stringliteral}{"Failed to destroy decoder: %s\(\backslash\)n"},
967             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
968   \}
969 
970 fail2:
971 
972   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
973     \textcolor{keywordflow}{if} (do\_md5) \{
974       MD5Final(md5\_digest, &md5\_ctx);
975       print\_md5(md5\_digest, outfile\_name);
976     \} \textcolor{keywordflow}{else} \{
977       fclose(outfile);
978     \}
979   \}
980 
981 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
982   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_WEBM)
983     webm\_free(input.webm\_ctx);
984 \textcolor{preprocessor}{#endif}
985   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_OBU)
986     obudec\_free(input.obu\_ctx);
987 
988   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type != FILE\_TYPE\_WEBM) free(buf);
989 
990   \textcolor{keywordflow}{if} (scaled\_img) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(scaled\_img);
991   \textcolor{keywordflow}{if} (img\_shifted) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(img\_shifted);
992 
993   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list.num\_external\_frame\_buffers; ++i) \{
994     free(ext\_fb\_list.ext\_fb[i].data);
995   \}
996   free(ext\_fb\_list.ext\_fb);
997 
998   fclose(infile);
999   \textcolor{keywordflow}{if} (framestats\_file) fclose(framestats\_file);
1000 
1001   free(argv);
1002 
1003   \textcolor{keywordflow}{return} ret;
1004 \}
1005 
1006 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
1007   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} loops = 1, i;
1008   \textcolor{keywordtype}{char} **argv, **argi, **argj;
1009   \textcolor{keyword}{struct }arg arg;
1010   \textcolor{keywordtype}{int} error = 0;
1011 
1012   argv = argv\_dup(argc - 1, argv\_ + 1);
1013   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1014     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
1015     arg.argv\_step = 1;
1016 
1017     \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
1018       loops = arg\_parse\_uint(&arg);
1019       \textcolor{keywordflow}{break};
1020     \}
1021   \}
1022   free(argv);
1023   \textcolor{keywordflow}{for} (i = 0; !error && i < loops; i++) error = main\_loop(argc, argv\_);
1024   \textcolor{keywordflow}{return} error;
1025 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomenc}{}\subsection{aomenc}\label{example_aomenc}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include "apps/aomenc.h"}
13 
14 \textcolor{preprocessor}{#include "config/aom\_config.h"}
15 
16 \textcolor{preprocessor}{#include <assert.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 \textcolor{preprocessor}{#include <math.h>}
19 \textcolor{preprocessor}{#include <stdarg.h>}
20 \textcolor{preprocessor}{#include <stdio.h>}
21 \textcolor{preprocessor}{#include <stdlib.h>}
22 \textcolor{preprocessor}{#include <string.h>}
23 
24 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
25 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
26 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
30 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
31 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
32 \textcolor{preprocessor}{#include "aom\_dsp/aom\_dsp\_common.h"}
33 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
34 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
35 \textcolor{preprocessor}{#include "common/args.h"}
36 \textcolor{preprocessor}{#include "common/ivfenc.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 \textcolor{preprocessor}{#include "common/warnings.h"}
39 
40 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
41 \textcolor{preprocessor}{#include "common/webmenc.h"}
42 \textcolor{preprocessor}{#endif}
43 
44 \textcolor{preprocessor}{#include "common/y4minput.h"}
45 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
46 \textcolor{preprocessor}{#include "stats/aomstats.h"}
47 \textcolor{preprocessor}{#include "stats/rate\_hist.h"}
48 
49 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
50 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
51 \textcolor{preprocessor}{#endif}
52 
53 \textcolor{comment}{/* Swallow warnings about unused results of fread/fwrite */}
54 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fread(\textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb, FILE *stream) \{
55   \textcolor{keywordflow}{return} fread(ptr, size, nmemb, stream);
56 \}
57 \textcolor{preprocessor}{#define fread wrap\_fread}
58 
59 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fwrite(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb,
60                           FILE *stream) \{
61   \textcolor{keywordflow}{return} fwrite(ptr, size, nmemb, stream);
62 \}
63 \textcolor{preprocessor}{#define fwrite wrap\_fwrite}
64 
65 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
66 
67 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_errorv(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
68                                    \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, va\_list ap) \{
69   \textcolor{keywordflow}{if} (ctx->\hyperlink{structaom__codec__ctx_a4cf9c265a7c34e92bb02d04aa3cab718}{err}) \{
70     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(ctx);
71 
72     vfprintf(stderr, s, ap);
73     fprintf(stderr, \textcolor{stringliteral}{": %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(ctx));
74 
75     \textcolor{keywordflow}{if} (detail) fprintf(stderr, \textcolor{stringliteral}{"    %s\(\backslash\)n"}, detail);
76 
77     \textcolor{keywordflow}{if} (fatal) exit(EXIT\_FAILURE);
78   \}
79 \}
80 
81 \textcolor{keyword}{static} \textcolor{keywordtype}{void} ctx\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
82   va\_list ap;
83 
84   va\_start(ap, s);
85   warn\_or\_exit\_on\_errorv(ctx, 1, s, ap);
86   va\_end(ap);
87 \}
88 
89 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
90                                   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
91   va\_list ap;
92 
93   va\_start(ap, s);
94   warn\_or\_exit\_on\_errorv(ctx, fatal, s, ap);
95   va\_end(ap);
96 \}
97 
98 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxInputContext *input\_ctx, \hyperlink{structaom__image}{aom\_image\_t} *img) \{
99   FILE *f = input\_ctx->file;
100   y4m\_input *y4m = &input\_ctx->y4m;
101   \textcolor{keywordtype}{int} shortread = 0;
102 
103   \textcolor{keywordflow}{if} (input\_ctx->file\_type == FILE\_TYPE\_Y4M) \{
104     \textcolor{keywordflow}{if} (y4m\_input\_fetch\_frame(y4m, f, img) < 1) \textcolor{keywordflow}{return} 0;
105   \} \textcolor{keywordflow}{else} \{
106     shortread = read\_yuv\_frame(input\_ctx, img);
107   \}
108 
109   \textcolor{keywordflow}{return} !shortread;
110 \}
111 
112 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_y4m(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
113   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"YUV4"}, 4) == 0) \{
114     \textcolor{keywordflow}{return} 1;
115   \}
116   \textcolor{keywordflow}{return} 0;
117 \}
118 
119 \textcolor{keyword}{static} \textcolor{keywordtype}{int} fourcc\_is\_ivf(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
120   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"DKIF"}, 4) == 0) \{
121     \textcolor{keywordflow}{return} 1;
122   \}
123   \textcolor{keywordflow}{return} 0;
124 \}
125 
126 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
127     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
128 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t debugmode =
129     ARG\_DEF(\textcolor{stringliteral}{"D"}, \textcolor{stringliteral}{"debug"}, 0, \textcolor{stringliteral}{"Debug mode (makes output deterministic)"});
130 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
131     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output filename"});
132 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
133     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Input file is YV12 "});
134 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
135     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Input file is I420 (default)"});
136 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i422 =
137     ARG\_DEF(NULL, \textcolor{stringliteral}{"i422"}, 0, \textcolor{stringliteral}{"Input file is I422"});
138 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i444 =
139     ARG\_DEF(NULL, \textcolor{stringliteral}{"i444"}, 0, \textcolor{stringliteral}{"Input file is I444"});
140 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
141 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t passes =
142     ARG\_DEF(\textcolor{stringliteral}{"p"}, \textcolor{stringliteral}{"passes"}, 1, \textcolor{stringliteral}{"Number of passes (1/2)"});
143 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pass\_arg =
144     ARG\_DEF(NULL, \textcolor{stringliteral}{"pass"}, 1, \textcolor{stringliteral}{"Pass to execute (1/2)"});
145 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpf\_name =
146     ARG\_DEF(NULL, \textcolor{stringliteral}{"fpf"}, 1, \textcolor{stringliteral}{"First pass statistics file name"});
147 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limit =
148     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop encoding after n input frames"});
149 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skip =
150     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
151 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t good\_dl =
152     ARG\_DEF(NULL, \textcolor{stringliteral}{"good"}, 0, \textcolor{stringliteral}{"Use Good Quality Deadline"});
153 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rt\_dl =
154     ARG\_DEF(NULL, \textcolor{stringliteral}{"rt"}, 0, \textcolor{stringliteral}{"Use Realtime Quality Deadline"});
155 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t quietarg =
156     ARG\_DEF(\textcolor{stringliteral}{"q"}, \textcolor{stringliteral}{"quiet"}, 0, \textcolor{stringliteral}{"Do not print encode progress"});
157 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
158     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show encoder parameters"});
159 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t psnrarg =
160     ARG\_DEF(NULL, \textcolor{stringliteral}{"psnr"}, 0, \textcolor{stringliteral}{"Show PSNR in status line"});
161 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
162 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_cfg = ARG\_DEF(\textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"cfg"}, 1, \textcolor{stringliteral}{"Config file to use"});
163 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t ext\_partition =
164     ARG\_DEF(NULL, \textcolor{stringliteral}{"ext-partition"}, 1, \textcolor{stringliteral}{"corresponds to extended partitions"});
165 \textcolor{preprocessor}{#endif}
166 
167 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list test\_decode\_enum[] = \{
168   \{ \textcolor{stringliteral}{"off"}, TEST\_DECODE\_OFF \},
169   \{ \textcolor{stringliteral}{"fatal"}, TEST\_DECODE\_FATAL \},
170   \{ \textcolor{stringliteral}{"warn"}, TEST\_DECODE\_WARN \},
171   \{ NULL, 0 \}
172 \};
173 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t recontest = ARG\_DEF\_ENUM(
174     NULL, \textcolor{stringliteral}{"test-decode"}, 1, \textcolor{stringliteral}{"Test encode/decode mismatch"}, test\_decode\_enum);
175 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framerate =
176     ARG\_DEF(NULL, \textcolor{stringliteral}{"fps"}, 1, \textcolor{stringliteral}{"Stream frame rate (rate/scale)"});
177 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_webm =
178     ARG\_DEF(NULL, \textcolor{stringliteral}{"webm"}, 0, \textcolor{stringliteral}{"Output WebM (default when WebM IO is enabled)"});
179 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_ivf = ARG\_DEF(NULL, \textcolor{stringliteral}{"ivf"}, 0, \textcolor{stringliteral}{"Output IVF"});
180 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_obu = ARG\_DEF(NULL, \textcolor{stringliteral}{"obu"}, 0, \textcolor{stringliteral}{"Output OBU"});
181 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t q\_hist\_n =
182     ARG\_DEF(NULL, \textcolor{stringliteral}{"q-hist"}, 1, \textcolor{stringliteral}{"Show quantizer histogram (n-buckets)"});
183 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rate\_hist\_n =
184     ARG\_DEF(NULL, \textcolor{stringliteral}{"rate-hist"}, 1, \textcolor{stringliteral}{"Show rate histogram (n-buckets)"});
185 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warnings =
186     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-warnings"}, 0,
187             \textcolor{stringliteral}{"Disable warnings about potentially incorrect encode settings."});
188 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warning\_prompt =
189     ARG\_DEF(\textcolor{stringliteral}{"y"}, \textcolor{stringliteral}{"disable-warning-prompt"}, 0,
190             \textcolor{stringliteral}{"Display warnings, but do not prompt user to continue."});
191 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list bitdepth\_enum[] = \{
192   \{ \textcolor{stringliteral}{"8"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} \}, \{ \textcolor{stringliteral}{"10"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a91734384f432233c3d681052122ab8e7}{AOM\_BITS\_10} \}, \{ \textcolor{stringliteral}{"12"}, 
      \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a15836a87f9e9940885d5ef59a52bf728}{AOM\_BITS\_12} \}, \{ NULL, 0 \}
193 \};
194 
195 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bitdeptharg = ARG\_DEF\_ENUM(
196     \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"bit-depth"}, 1,
197     \textcolor{stringliteral}{"Bit depth for codec (8 for version <=1, 10 or 12 for version 2)"},
198     bitdepth\_enum);
199 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t inbitdeptharg =
200     ARG\_DEF(NULL, \textcolor{stringliteral}{"input-bit-depth"}, 1, \textcolor{stringliteral}{"Bit depth of input"});
201 
202 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_subsampling\_x = ARG\_DEF(
203     NULL, \textcolor{stringliteral}{"input-chroma-subsampling-x"}, 1, \textcolor{stringliteral}{"chroma subsampling x value."});
204 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_subsampling\_y = ARG\_DEF(
205     NULL, \textcolor{stringliteral}{"input-chroma-subsampling-y"}, 1, \textcolor{stringliteral}{"chroma subsampling y value."});
206 
207 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *main\_args[] = \{ &help,
208 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
209                                         &use\_cfg,
210 \textcolor{preprocessor}{#endif}
211                                         &debugmode,
212                                         &outputfile,
213                                         &codecarg,
214                                         &passes,
215                                         &pass\_arg,
216                                         &fpf\_name,
217                                         &limit,
218                                         &skip,
219                                         &good\_dl,
220                                         &rt\_dl,
221                                         &quietarg,
222                                         &verbosearg,
223                                         &psnrarg,
224                                         &use\_webm,
225                                         &use\_ivf,
226                                         &use\_obu,
227                                         &q\_hist\_n,
228                                         &rate\_hist\_n,
229                                         &disable\_warnings,
230                                         &disable\_warning\_prompt,
231                                         &recontest,
232                                         NULL \};
233 
234 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t usage =
235     ARG\_DEF(\textcolor{stringliteral}{"u"}, \textcolor{stringliteral}{"usage"}, 1, \textcolor{stringliteral}{"Usage profile number to use"});
236 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threads =
237     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max number of threads to use"});
238 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t profile =
239     ARG\_DEF(NULL, \textcolor{stringliteral}{"profile"}, 1, \textcolor{stringliteral}{"Bitstream profile number to use"});
240 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t width = ARG\_DEF(\textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"width"}, 1, \textcolor{stringliteral}{"Frame width"});
241 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t height = ARG\_DEF(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{"height"}, 1, \textcolor{stringliteral}{"Frame height"});
242 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_width = ARG\_DEF(
243     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_width"}, 0, \textcolor{stringliteral}{"Maximum frame width value to force"});
244 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_height = ARG\_DEF(
245     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_height"}, 0, \textcolor{stringliteral}{"Maximum frame height value to force"});
246 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
247 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list stereo\_mode\_enum[] = \{
248   \{ \textcolor{stringliteral}{"mono"}, STEREO\_FORMAT\_MONO \},
249   \{ \textcolor{stringliteral}{"left-right"}, STEREO\_FORMAT\_LEFT\_RIGHT \},
250   \{ \textcolor{stringliteral}{"bottom-top"}, STEREO\_FORMAT\_BOTTOM\_TOP \},
251   \{ \textcolor{stringliteral}{"top-bottom"}, STEREO\_FORMAT\_TOP\_BOTTOM \},
252   \{ \textcolor{stringliteral}{"right-left"}, STEREO\_FORMAT\_RIGHT\_LEFT \},
253   \{ NULL, 0 \}
254 \};
255 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t stereo\_mode = ARG\_DEF\_ENUM(
256     NULL, \textcolor{stringliteral}{"stereo-mode"}, 1, \textcolor{stringliteral}{"Stereo 3D video format"}, stereo\_mode\_enum);
257 \textcolor{preprocessor}{#endif}
258 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timebase = ARG\_DEF(
259     NULL, \textcolor{stringliteral}{"timebase"}, 1, \textcolor{stringliteral}{"Output timestamp precision (fractional seconds)"});
260 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t global\_error\_resilient =
261     ARG\_DEF(NULL, \textcolor{stringliteral}{"global-error-resilient"}, 1,
262             \textcolor{stringliteral}{"Enable global error resiliency features"});
263 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lag\_in\_frames =
264     ARG\_DEF(NULL, \textcolor{stringliteral}{"lag-in-frames"}, 1, \textcolor{stringliteral}{"Max number of frames to lag"});
265 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t large\_scale\_tile = ARG\_DEF(
266     NULL, \textcolor{stringliteral}{"large-scale-tile"}, 1,
267     \textcolor{stringliteral}{"Large scale tile coding (0: off (default), 1: on (ivf output only))"});
268 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t monochrome =
269     ARG\_DEF(NULL, \textcolor{stringliteral}{"monochrome"}, 0, \textcolor{stringliteral}{"Monochrome video (no chroma planes)"});
270 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t full\_still\_picture\_hdr = ARG\_DEF(
271     NULL, \textcolor{stringliteral}{"full-still-picture-hdr"}, 0, \textcolor{stringliteral}{"Use full header for still picture"});
272 
273 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *global\_args[] = \{ &use\_yv12,
274                                           &use\_i420,
275                                           &use\_i422,
276                                           &use\_i444,
277                                           &usage,
278                                           &threads,
279                                           &profile,
280                                           &width,
281                                           &height,
282                                           &forced\_max\_frame\_width,
283                                           &forced\_max\_frame\_height,
284 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
285                                           &stereo\_mode,
286 \textcolor{preprocessor}{#endif}
287                                           &timebase,
288                                           &framerate,
289                                           &global\_error\_resilient,
290                                           &bitdeptharg,
291                                           &lag\_in\_frames,
292                                           &large\_scale\_tile,
293                                           &monochrome,
294                                           &full\_still\_picture\_hdr,
295                                           NULL \};
296 
297 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t dropframe\_thresh =
298     ARG\_DEF(NULL, \textcolor{stringliteral}{"drop-frame"}, 1, \textcolor{stringliteral}{"Temporal resampling threshold (buf %)"});
299 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_mode =
300     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-mode"}, 1, \textcolor{stringliteral}{"Frame resize mode"});
301 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_denominator =
302     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-denominator"}, 1, \textcolor{stringliteral}{"Frame resize denominator"});
303 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_kf\_denominator = ARG\_DEF(
304     NULL, \textcolor{stringliteral}{"resize-kf-denominator"}, 1, \textcolor{stringliteral}{"Frame resize keyframe denominator"});
305 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_mode =
306     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-mode"}, 1, \textcolor{stringliteral}{"Frame super-resolution mode"});
307 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_denominator = ARG\_DEF(
308     NULL, \textcolor{stringliteral}{"superres-denominator"}, 1, \textcolor{stringliteral}{"Frame super-resolution denominator"});
309 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_denominator =
310     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-denominator"}, 1,
311             \textcolor{stringliteral}{"Frame super-resolution keyframe denominator"});
312 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_qthresh = ARG\_DEF(
313     NULL, \textcolor{stringliteral}{"superres-qthresh"}, 1, \textcolor{stringliteral}{"Frame super-resolution qindex threshold"});
314 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_qthresh =
315     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-qthresh"}, 1,
316             \textcolor{stringliteral}{"Frame super-resolution keyframe qindex threshold"});
317 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list end\_usage\_enum[] = \{ \{ \textcolor{stringliteral}{"vbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a7d3a2574737ea63d0f160ffdbd7f0110}{AOM\_VBR} \},
318                                                        \{ \textcolor{stringliteral}{"cbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a14b6057d61c61e6117f5af16dcf89b0c}{AOM\_CBR} \},
319                                                        \{ \textcolor{stringliteral}{"cq"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a70aa1f15e91f6576ba3e63879947be64}{AOM\_CQ} \},
320                                                        \{ \textcolor{stringliteral}{"q"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q} \},
321                                                        \{ NULL, 0 \} \};
322 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t end\_usage =
323     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"end-usage"}, 1, \textcolor{stringliteral}{"Rate control mode"}, end\_usage\_enum);
324 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t target\_bitrate =
325     ARG\_DEF(NULL, \textcolor{stringliteral}{"target-bitrate"}, 1, \textcolor{stringliteral}{"Bitrate (kbps)"});
326 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_quantizer =
327     ARG\_DEF(NULL, \textcolor{stringliteral}{"min-q"}, 1, \textcolor{stringliteral}{"Minimum (best) quantizer"});
328 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_quantizer =
329     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-q"}, 1, \textcolor{stringliteral}{"Maximum (worst) quantizer"});
330 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t undershoot\_pct =
331     ARG\_DEF(NULL, \textcolor{stringliteral}{"undershoot-pct"}, 1, \textcolor{stringliteral}{"Datarate undershoot (min) target (%)"});
332 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t overshoot\_pct =
333     ARG\_DEF(NULL, \textcolor{stringliteral}{"overshoot-pct"}, 1, \textcolor{stringliteral}{"Datarate overshoot (max) target (%)"});
334 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_sz =
335     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-sz"}, 1, \textcolor{stringliteral}{"Client buffer size (ms)"});
336 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_initial\_sz =
337     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-initial-sz"}, 1, \textcolor{stringliteral}{"Client initial buffer size (ms)"});
338 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_optimal\_sz =
339     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-optimal-sz"}, 1, \textcolor{stringliteral}{"Client optimal buffer size (ms)"});
340 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_args[] = \{ &dropframe\_thresh,
341                                       &resize\_mode,
342                                       &resize\_denominator,
343                                       &resize\_kf\_denominator,
344                                       &superres\_mode,
345                                       &superres\_denominator,
346                                       &superres\_kf\_denominator,
347                                       &superres\_qthresh,
348                                       &superres\_kf\_qthresh,
349                                       &end\_usage,
350                                       &target\_bitrate,
351                                       &min\_quantizer,
352                                       &max\_quantizer,
353                                       &undershoot\_pct,
354                                       &overshoot\_pct,
355                                       &buf\_sz,
356                                       &buf\_initial\_sz,
357                                       &buf\_optimal\_sz,
358                                       NULL \};
359 
360 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bias\_pct =
361     ARG\_DEF(NULL, \textcolor{stringliteral}{"bias-pct"}, 1, \textcolor{stringliteral}{"CBR/VBR bias (0=CBR, 100=VBR)"});
362 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t minsection\_pct =
363     ARG\_DEF(NULL, \textcolor{stringliteral}{"minsection-pct"}, 1, \textcolor{stringliteral}{"GOP min bitrate (% of target)"});
364 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t maxsection\_pct =
365     ARG\_DEF(NULL, \textcolor{stringliteral}{"maxsection-pct"}, 1, \textcolor{stringliteral}{"GOP max bitrate (% of target)"});
366 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_twopass\_args[] = \{ &bias\_pct, &minsection\_pct,
367                                               &maxsection\_pct, NULL \};
368 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fwd\_kf\_enabled =
369     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-fwd-kf"}, 1, \textcolor{stringliteral}{"Enable forward reference keyframes"});
370 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_min\_dist =
371     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-min-dist"}, 1, \textcolor{stringliteral}{"Minimum keyframe interval (frames)"});
372 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_max\_dist =
373     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-max-dist"}, 1, \textcolor{stringliteral}{"Maximum keyframe interval (frames)"});
374 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_disabled =
375     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-kf"}, 0, \textcolor{stringliteral}{"Disable keyframe placement"});
376 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *kf\_args[] = \{ &fwd\_kf\_enabled, &kf\_min\_dist,
377                                       &kf\_max\_dist, &kf\_disabled, NULL \};
378 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_dist =
379     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-dist"}, 1, \textcolor{stringliteral}{"S-Frame interval (frames)"});
380 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_mode =
381     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-mode"}, 1, \textcolor{stringliteral}{"S-Frame insertion mode (1..2)"});
382 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t save\_as\_annexb =
383     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 1, \textcolor{stringliteral}{"Save as Annex-B"});
384 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noise\_sens =
385     ARG\_DEF(NULL, \textcolor{stringliteral}{"noise-sensitivity"}, 1, \textcolor{stringliteral}{"Noise sensitivity (frames to blur)"});
386 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sharpness =
387     ARG\_DEF(NULL, \textcolor{stringliteral}{"sharpness"}, 1, \textcolor{stringliteral}{"Loop filter sharpness (0..7)"});
388 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t static\_thresh =
389     ARG\_DEF(NULL, \textcolor{stringliteral}{"static-thresh"}, 1, \textcolor{stringliteral}{"Motion detection threshold"});
390 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t auto\_altref =
391     ARG\_DEF(NULL, \textcolor{stringliteral}{"auto-alt-ref"}, 1, \textcolor{stringliteral}{"Enable automatic alt reference frames"});
392 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_maxframes =
393     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-maxframes"}, 1, \textcolor{stringliteral}{"AltRef max frames (0..15)"});
394 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_strength =
395     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-strength"}, 1, \textcolor{stringliteral}{"AltRef filter strength (0..6)"});
396 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tuning\_enum[] = \{
397   \{ \textcolor{stringliteral}{"psnr"}, AOM\_TUNE\_PSNR \},
398   \{ \textcolor{stringliteral}{"ssim"}, AOM\_TUNE\_SSIM \},
399 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
400   \{ \textcolor{stringliteral}{"cdef-dist"}, AOM\_TUNE\_CDEF\_DIST \},
401   \{ \textcolor{stringliteral}{"daala-dist"}, AOM\_TUNE\_DAALA\_DIST \},
402 \textcolor{preprocessor}{#endif}
403   \{ NULL, 0 \}
404 \};
405 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_metric =
406     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"tune"}, 1, \textcolor{stringliteral}{"Distortion metric tuned with"}, tuning\_enum);
407 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cq\_level =
408     ARG\_DEF(NULL, \textcolor{stringliteral}{"cq-level"}, 1, \textcolor{stringliteral}{"Constant/Constrained Quality level"});
409 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_intra\_rate\_pct =
410     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-intra-rate"}, 1, \textcolor{stringliteral}{"Max I-frame bitrate (pct)"});
411 
412 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
413 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cpu\_used\_av1 =
414     ARG\_DEF(NULL, \textcolor{stringliteral}{"cpu-used"}, 1, \textcolor{stringliteral}{"CPU Used (0..8)"});
415 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rowmtarg =
416     ARG\_DEF(NULL, \textcolor{stringliteral}{"row-mt"}, 1,
417             \textcolor{stringliteral}{"Enable row based multi-threading (0: off, 1: on (default))"});
418 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_cols =
419     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-columns"}, 1, \textcolor{stringliteral}{"Number of tile columns to use, log2"});
420 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_rows =
421     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-rows"}, 1, \textcolor{stringliteral}{"Number of tile rows to use, log2"});
422 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_tpl\_model =
423     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-tpl-model"}, 1,
424             \textcolor{stringliteral}{"RDO based on frame temporal dependency "}
425             \textcolor{stringliteral}{"(0: off, 1: backward source based, 2: forward 2-pass"});
426 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_width =
427     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-width"}, 1, \textcolor{stringliteral}{"Tile widths (comma separated)"});
428 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_height =
429     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-height"}, 1, \textcolor{stringliteral}{"Tile heights (command separated)"});
430 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lossless =
431     ARG\_DEF(NULL, \textcolor{stringliteral}{"lossless"}, 1, \textcolor{stringliteral}{"Lossless mode (0: false (default), 1: true)"});
432 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_cdef =
433     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-cdef"}, 1,
434             \textcolor{stringliteral}{"Enable the constrained directional enhancement filter (0: false, "}
435             \textcolor{stringliteral}{"1: true (default))"});
436 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_restoration = ARG\_DEF(
437     NULL, \textcolor{stringliteral}{"enable-restoration"}, 1,
438     \textcolor{stringliteral}{"Enable the loop restoration filter (0: false (default in Realtime mode), "}
439     \textcolor{stringliteral}{"1: true (default in Non-realtime mode))"});
440 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_rect\_partitions =
441     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-rect-partitions"}, 1,
442             \textcolor{stringliteral}{"Enable rectangular partitions "}
443             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
444 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_ab\_partitions =
445     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-ab-partitions"}, 1,
446             \textcolor{stringliteral}{"Enable ab partitions (0: false, 1: true (default))"});
447 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_1to4\_partitions =
448     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-1to4-partitions"}, 1,
449             \textcolor{stringliteral}{"Enable 1:4 and 4:1 partitions "}
450             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
451 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_partition\_size =
452     ARG\_DEF(NULL, \textcolor{stringliteral}{"min-partition-size"}, 4,
453             \textcolor{stringliteral}{"Set min partition size "}
454             \textcolor{stringliteral}{"(4:4x4, 8:8x8, 16:16x16, 32:32x32, 64:64x64, 128:128x128)"});
455 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_partition\_size =
456     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-partition-size"}, 128,
457             \textcolor{stringliteral}{"Set max partition size "}
458             \textcolor{stringliteral}{"(4:4x4, 8:8x8, 16:16x16, 32:32x32, 64:64x64, 128:128x128)"});
459 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dual\_filter =
460     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dual-filter"}, 1,
461             \textcolor{stringliteral}{"Enable dual filter "}
462             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
463 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_intra\_edge\_filter =
464     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-intra-edge-filter"}, 1,
465             \textcolor{stringliteral}{"Enable intra edge filtering "}
466             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
467 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_order\_hint =
468     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-order-hint"}, 1,
469             \textcolor{stringliteral}{"Enable order hint "}
470             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
471 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_tx64 =
472     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-tx64"}, 1,
473             \textcolor{stringliteral}{"Enable 64-pt transform (0: false, 1: true (default))"});
474 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tx\_size\_search\_method =
475     ARG\_DEF(NULL, \textcolor{stringliteral}{"tx-size-search-method"}, 0,
476             \textcolor{stringliteral}{"Set transform block size search method "}
477             \textcolor{stringliteral}{"(0: Full RD (default), 1: Fast RD, 2: use largest allowed)"});
478 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_flip\_idtx =
479     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-flip-idtx"}, 1,
480             \textcolor{stringliteral}{"Enable extended transform type (0: false, 1: true (default)) "}
481             \textcolor{stringliteral}{"including FLIPADST\_DCT, DCT\_FLIPADST, FLIPADST\_FLIPADST, "}
482             \textcolor{stringliteral}{"ADST\_FLIPADST, FLIPADST\_ADST, IDTX, V\_DCT, H\_DCT, V\_ADST, "}
483             \textcolor{stringliteral}{"H\_ADST, V\_FLIPADST, H\_FLIPADST"});
484 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dist\_wtd\_comp =
485     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dist-wtd-comp"}, 1,
486             \textcolor{stringliteral}{"Enable distance-weighted compound "}
487             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
488 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_masked\_comp =
489     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-masked-comp"}, 1,
490             \textcolor{stringliteral}{"Enable masked (wedge/diff-wtd) compound "}
491             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
492 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_onesided\_comp =
493     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-onesided-comp"}, 1,
494             \textcolor{stringliteral}{"Enable one sided compound "}
495             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
496 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_interintra\_comp =
497     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-interintra-comp"}, 1,
498             \textcolor{stringliteral}{"Enable interintra compound "}
499             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
500 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_smooth\_interintra =
501     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-smooth-interintra"}, 1,
502             \textcolor{stringliteral}{"Enable smooth interintra mode "}
503             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
504 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_diff\_wtd\_comp =
505     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-diff-wtd-comp"}, 1,
506             \textcolor{stringliteral}{"Enable difference-weighted compound "}
507             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
508 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_interinter\_wedge =
509     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-interinter-wedge"}, 1,
510             \textcolor{stringliteral}{"Enable interinter wedge compound "}
511             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
512 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_interintra\_wedge =
513     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-interintra-wedge"}, 1,
514             \textcolor{stringliteral}{"Enable interintra wedge compound "}
515             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
516 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_global\_motion =
517     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-global-motion"}, 1,
518             \textcolor{stringliteral}{"Enable global motion "}
519             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
520 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_warped\_motion =
521     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-warped-motion"}, 1,
522             \textcolor{stringliteral}{"Enable local warped motion "}
523             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
524 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_filter\_intra =
525     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-filter-intra"}, 1,
526             \textcolor{stringliteral}{"Enable filter intra prediction mode "}
527             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
528 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_smooth\_intra =
529     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-smooth-intra"}, 1,
530             \textcolor{stringliteral}{"Enable smooth intra prediction modes "}
531             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
532 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_paeth\_intra =
533     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-paeth-intra"}, 1,
534             \textcolor{stringliteral}{"Enable Paeth intra prediction mode (0: false, 1: true (default))"});
535 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_cfl\_intra =
536     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-cfl-intra"}, 1,
537             \textcolor{stringliteral}{"Enable chroma from luma intra prediction mode "}
538             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
539 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_obmc = ARG\_DEF(
540     NULL, \textcolor{stringliteral}{"enable-obmc"}, 1, \textcolor{stringliteral}{"Enable OBMC (0: false, 1: true (default))"});
541 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_palette =
542     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-palette"}, 1,
543             \textcolor{stringliteral}{"Enable palette prediction mode (0: false, 1: true (default))"});
544 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_intrabc =
545     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-intrabc"}, 1,
546             \textcolor{stringliteral}{"Enable intra block copy prediction mode "}
547             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
548 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_angle\_delta =
549     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-angle-delta"}, 1,
550             \textcolor{stringliteral}{"Enable intra angle delta (0: false, 1: true (default))"});
551 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_trellis\_quant =
552     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-trellis-quant"}, 1,
553             \textcolor{stringliteral}{"Disable trellis optimization of quantized coefficients (0: false "}
554             \textcolor{stringliteral}{"1: true  2: true for rd search 3: true for estimate yrd serch "}
555             \textcolor{stringliteral}{"(default))"});
556 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_qm =
557     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-qm"}, 1,
558             \textcolor{stringliteral}{"Enable quantisation matrices (0: false (default), 1: true)"});
559 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_min = ARG\_DEF(
560     NULL, \textcolor{stringliteral}{"qm-min"}, 1, \textcolor{stringliteral}{"Min quant matrix flatness (0..15), default is 8"});
561 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_max = ARG\_DEF(
562     NULL, \textcolor{stringliteral}{"qm-max"}, 1, \textcolor{stringliteral}{"Max quant matrix flatness (0..15), default is 15"});
563 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t reduced\_tx\_type\_set = ARG\_DEF(
564     NULL, \textcolor{stringliteral}{"reduced-tx-type-set"}, 1, \textcolor{stringliteral}{"Use reduced set of transform types"});
565 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_intra\_dct\_only =
566     ARG\_DEF(NULL, \textcolor{stringliteral}{"use-intra-dct-only"}, 1, \textcolor{stringliteral}{"Use DCT only for INTRA modes"});
567 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_inter\_dct\_only =
568     ARG\_DEF(NULL, \textcolor{stringliteral}{"use-inter-dct-only"}, 1, \textcolor{stringliteral}{"Use DCT only for INTER modes"});
569 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_intra\_default\_tx\_only =
570     ARG\_DEF(NULL, \textcolor{stringliteral}{"use-intra-default-tx-only"}, 1,
571             \textcolor{stringliteral}{"Use Default-transform only for INTRA modes"});
572 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t quant\_b\_adapt =
573     ARG\_DEF(NULL, \textcolor{stringliteral}{"quant-b-adapt"}, 1, \textcolor{stringliteral}{"Use adaptive quantize\_b"});
574 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t coeff\_cost\_upd\_freq =
575     ARG\_DEF(NULL, \textcolor{stringliteral}{"coeff-cost-upd-freq"}, 1,
576             \textcolor{stringliteral}{"Update freq for coeff costs"}
577             \textcolor{stringliteral}{"0: SB, 1: SB Row per Tile, 2: Tile"});
578 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t mode\_cost\_upd\_freq =
579     ARG\_DEF(NULL, \textcolor{stringliteral}{"mode-cost-upd-freq"}, 1,
580             \textcolor{stringliteral}{"Update freq for mode costs"}
581             \textcolor{stringliteral}{"0: SB, 1: SB Row per Tile, 2: Tile"});
582 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
583 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dist\_8x8 =
584     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dist-8x8"}, 1,
585             \textcolor{stringliteral}{"Enable dist-8x8 (0: false (default), 1: true)"});
586 \textcolor{preprocessor}{#endif  // CONFIG\_DIST\_8X8}
587 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t num\_tg = ARG\_DEF(
588     NULL, \textcolor{stringliteral}{"num-tile-groups"}, 1, \textcolor{stringliteral}{"Maximum number of tile groups, default is 1"});
589 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t mtu\_size =
590     ARG\_DEF(NULL, \textcolor{stringliteral}{"mtu-size"}, 1,
591             \textcolor{stringliteral}{"MTU size for a tile group, default is 0 (no MTU targeting), "}
592             \textcolor{stringliteral}{"overrides maximum number of tile groups"});
593 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list timing\_info\_enum[] = \{
594   \{ \textcolor{stringliteral}{"unspecified"}, AOM\_TIMING\_UNSPECIFIED \},
595   \{ \textcolor{stringliteral}{"constant"}, AOM\_TIMING\_EQUAL \},
596   \{ \textcolor{stringliteral}{"model"}, AOM\_TIMING\_DEC\_MODEL \},
597   \{ NULL, 0 \}
598 \};
599 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timing\_info =
600     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"timing-info"}, 1,
601                  \textcolor{stringliteral}{"Signal timing info in the bitstream (model unly works for no "}
602                  \textcolor{stringliteral}{"hidden frames, no super-res yet):"},
603                  timing\_info\_enum);
604 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_test =
605     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-test"}, 1,
606             \textcolor{stringliteral}{"Film grain test vectors (0: none (default), 1: test-1  2: test-2, "}
607             \textcolor{stringliteral}{"... 16: test-16)"});
608 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_table =
609     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-table"}, 1,
610             \textcolor{stringliteral}{"Path to file containing film grain parameters"});
611 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
612 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t denoise\_noise\_level =
613     ARG\_DEF(NULL, \textcolor{stringliteral}{"denoise-noise-level"}, 1,
614             \textcolor{stringliteral}{"Amount of noise (from 0 = don't denoise, to 50)"});
615 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t denoise\_block\_size =
616     ARG\_DEF(NULL, \textcolor{stringliteral}{"denoise-block-size"}, 1, \textcolor{stringliteral}{"Denoise block size (default = 32)"});
617 \textcolor{preprocessor}{#endif}
618 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_ref\_frame\_mvs =
619     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-ref-frame-mvs"}, 1,
620             \textcolor{stringliteral}{"Enable temporal mv prediction (default is 1)"});
621 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_parallel\_decoding =
622     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-parallel"}, 1,
623             \textcolor{stringliteral}{"Enable frame parallel decodability features "}
624             \textcolor{stringliteral}{"(0: false (default), 1: true)"});
625 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t error\_resilient\_mode =
626     ARG\_DEF(NULL, \textcolor{stringliteral}{"error-resilient"}, 1,
627             \textcolor{stringliteral}{"Enable error resilient features "}
628             \textcolor{stringliteral}{"(0: false (default), 1: true)"});
629 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t aq\_mode = ARG\_DEF(
630     NULL, \textcolor{stringliteral}{"aq-mode"}, 1,
631     \textcolor{stringliteral}{"Adaptive quantization mode (0: off (default), 1: variance 2: complexity, "}
632     \textcolor{stringliteral}{"3: cyclic refresh)"});
633 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t deltaq\_mode =
634     ARG\_DEF(NULL, \textcolor{stringliteral}{"deltaq-mode"}, 1,
635             \textcolor{stringliteral}{"Delta qindex mode (0: off (default), 1: deltaq pred efficiency, "}
636             \textcolor{stringliteral}{"2: deltaq perceptual)"});
637 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t deltalf\_mode = ARG\_DEF(
638     NULL, \textcolor{stringliteral}{"delta-lf-mode"}, 1, \textcolor{stringliteral}{"Enable delta-lf-mode (0: off (default), 1: on)"});
639 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_periodic\_boost =
640     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-boost"}, 1,
641             \textcolor{stringliteral}{"Enable frame periodic boost (0: off (default), 1: on)"});
642 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t gf\_cbr\_boost\_pct = ARG\_DEF(
643     NULL, \textcolor{stringliteral}{"gf-cbr-boost"}, 1, \textcolor{stringliteral}{"Boost for Golden Frame in CBR mode (pct)"});
644 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_inter\_rate\_pct =
645     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-inter-rate"}, 1, \textcolor{stringliteral}{"Max P-frame bitrate (pct)"});
646 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_gf\_interval = ARG\_DEF(
647     NULL, \textcolor{stringliteral}{"min-gf-interval"}, 1,
648     \textcolor{stringliteral}{"min gf/arf frame interval (default 0, indicating in-built behavior)"});
649 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_gf\_interval = ARG\_DEF(
650     NULL, \textcolor{stringliteral}{"max-gf-interval"}, 1,
651     \textcolor{stringliteral}{"max gf/arf frame interval (default 0, indicating in-built behavior)"});
652 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t gf\_max\_pyr\_height =
653     ARG\_DEF(NULL, \textcolor{stringliteral}{"gf-max-pyr-height"}, 1,
654             \textcolor{stringliteral}{"maximum height for GF group pyramid structure (0 to 4 (default))"});
655 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_reference\_frames = ARG\_DEF(
656     NULL, \textcolor{stringliteral}{"max-reference-frames"}, 1,
657     \textcolor{stringliteral}{"maximum number of reference frames allowed per frame (3 to 7 (default))"});
658 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t reduced\_reference\_set =
659     ARG\_DEF(NULL, \textcolor{stringliteral}{"reduced-reference-set"}, 1,
660             \textcolor{stringliteral}{"Use reduced set of single and compound references (0: off "}
661             \textcolor{stringliteral}{"(default), 1: on)"});
662 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t target\_seq\_level\_idx =
663     ARG\_DEF(NULL, \textcolor{stringliteral}{"target-seq-level-idx"}, 1,
664             \textcolor{stringliteral}{"Target sequence level index. "}
665             \textcolor{stringliteral}{"Possible values are in the form of \(\backslash\)"ABxy\(\backslash\)"(pad leading zeros if "}
666             \textcolor{stringliteral}{"less than 4 digits). "}
667             \textcolor{stringliteral}{"AB: Operating point(OP) index; "}
668             \textcolor{stringliteral}{"xy: Target level index for the OP. "}
669             \textcolor{stringliteral}{"E.g. \(\backslash\)"0\(\backslash\)" means target level index 0 for the 0th OP; "}
670             \textcolor{stringliteral}{"\(\backslash\)"1021\(\backslash\)" means target level index 21 for the 10th OP."});
671 
672 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list color\_primaries\_enum[] = \{
673   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9a2ebe055c0508a2a2f72b6c192fcce9}{AOM\_CICP\_CP\_BT\_709} \},
674   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
675   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa3ce81eb125550ec2f11a58f183eeaee6}{AOM\_CICP\_CP\_BT\_601} \},
676   \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa5b57cb26f04f4df6585335129392d5e2}{AOM\_CICP\_CP\_BT\_470\_M} \},
677   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8b33dc8483c16048c606d75d9f11e38a}{AOM\_CICP\_CP\_BT\_470\_B\_G} \},
678   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
679   \{ \textcolor{stringliteral}{"film"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8dd6ba5106c22d149a233e73232aeb65}{AOM\_CICP\_CP\_GENERIC\_FILM} \},
680   \{ \textcolor{stringliteral}{"bt2020"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6bb95baf09cd6e1f3596b459712c592a}{AOM\_CICP\_CP\_BT\_2020} \},
681   \{ \textcolor{stringliteral}{"xyz"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6032cae72a729933a6a75e3b943a542c}{AOM\_CICP\_CP\_XYZ} \},
682   \{ \textcolor{stringliteral}{"smpte431"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa54d519c9ac0ca52ebda7caf736530e57}{AOM\_CICP\_CP\_SMPTE\_431} \},
683   \{ \textcolor{stringliteral}{"smpte432"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa227b6e4116ed0266af20b705aebaf661}{AOM\_CICP\_CP\_SMPTE\_432} \},
684   \{ \textcolor{stringliteral}{"ebu3213"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9e74dcb338953bfab3101aa33ea44157}{AOM\_CICP\_CP\_EBU\_3213} \},
685   \{ NULL, 0 \}
686 \};
687 
688 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_color\_primaries = ARG\_DEF\_ENUM(
689     NULL, \textcolor{stringliteral}{"color-primaries"}, 1,
690     \textcolor{stringliteral}{"Color primaries (CICP) of input content:"}, color\_primaries\_enum);
691 
692 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list transfer\_characteristics\_enum[] = \{
693   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
694   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992affe340e422646b7d70ef91edd6a8053c}{AOM\_CICP\_TC\_BT\_709} \},
695   \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a356d6943d11d88e7a42370c1c698c214}{AOM\_CICP\_TC\_BT\_470\_M} \},
696   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7a347c6d5605db0a6ee89cc81dec0b37}{AOM\_CICP\_TC\_BT\_470\_B\_G} \},
697   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a5b51bfcf0f3779a7d907ac45ee4067a4}{AOM\_CICP\_TC\_BT\_601} \},
698   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac3b5e95e3400830c334268fca69a1226}{AOM\_CICP\_TC\_SMPTE\_240} \},
699   \{ \textcolor{stringliteral}{"lin"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a99ebdb0b1a35e0bf25808f851aa80a35}{AOM\_CICP\_TC\_LINEAR} \},
700   \{ \textcolor{stringliteral}{"log100"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a54ec8cfad46215d855696bafe371ffe1}{AOM\_CICP\_TC\_LOG\_100} \},
701   \{ \textcolor{stringliteral}{"log100sq10"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7d79c257042a5958bafa6b5ccfbd96cb}{AOM\_CICP\_TC\_LOG\_100\_SQRT10} \},
702   \{ \textcolor{stringliteral}{"iec61966"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a57f92f410badf8a43b19df18edc9b8b9}{AOM\_CICP\_TC\_IEC\_61966} \},
703   \{ \textcolor{stringliteral}{"bt1361"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac60ca749a2d0ca1c860d82f0825a3e2d}{AOM\_CICP\_TC\_BT\_1361} \},
704   \{ \textcolor{stringliteral}{"srgb"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a94553e773e3d3fb005236ed70eeedfea}{AOM\_CICP\_TC\_SRGB} \},
705   \{ \textcolor{stringliteral}{"bt2020-10bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a1ce5fbca5277266680d70bb7211646d6}{AOM\_CICP\_TC\_BT\_2020\_10\_BIT} \},
706   \{ \textcolor{stringliteral}{"bt2020-12bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992afcc74c6858aefc13c426dd6992198e75}{AOM\_CICP\_TC\_BT\_2020\_12\_BIT} \},
707   \{ \textcolor{stringliteral}{"smpte2084"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ab48fdcc8c2c0350f6423b9c116c1876d}{AOM\_CICP\_TC\_SMPTE\_2084} \},
708   \{ \textcolor{stringliteral}{"hlg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a3d7b83c425c539d1a36fb36e9aebf268}{AOM\_CICP\_TC\_HLG} \},
709   \{ \textcolor{stringliteral}{"smpte428"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a45df590313483af0c614708f346028c4}{AOM\_CICP\_TC\_SMPTE\_428} \},
710   \{ NULL, 0 \}
711 \};
712 
713 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_transfer\_characteristics =
714     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"transfer-characteristics"}, 1,
715                  \textcolor{stringliteral}{"Transfer characteristics (CICP) of input content:"},
716                  transfer\_characteristics\_enum);
717 
718 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list matrix\_coefficients\_enum[] = \{
719   \{ \textcolor{stringliteral}{"identity"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a17489bf0aed544427f7c6bbe4837b212}{AOM\_CICP\_MC\_IDENTITY} \},
720   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa70fd9b88bc91bd0d126aaa07421c49a}{AOM\_CICP\_MC\_BT\_709} \},
721   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a06a4defb1e5d9bb1d2aad092b8656a03}{AOM\_CICP\_MC\_UNSPECIFIED} \},
722   \{ \textcolor{stringliteral}{"fcc73"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae368663c2c2f34683b513e159c5738b9}{AOM\_CICP\_MC\_FCC} \},
723   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae9107262b437659514abdcd928e977db}{AOM\_CICP\_MC\_BT\_470\_B\_G} \},
724   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a0f81310501079cc1184d5265ae2c18a5}{AOM\_CICP\_MC\_BT\_601} \},
725   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
726   \{ \textcolor{stringliteral}{"ycgco"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa2140164b26b42404c376cc921ce27c5}{AOM\_CICP\_MC\_SMPTE\_YCGCO} \},
727   \{ \textcolor{stringliteral}{"bt2020ncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081adf60aa79c6a68f4eb41e1095f8bf7bf6}{AOM\_CICP\_MC\_BT\_2020\_NCL} \},
728   \{ \textcolor{stringliteral}{"bt2020cl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a34148eae7b467eece6af5c90405dde6b}{AOM\_CICP\_MC\_BT\_2020\_CL} \},
729   \{ \textcolor{stringliteral}{"smpte2085"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a3aeb0ed0afc0a92ce758f109cd05ee80}{AOM\_CICP\_MC\_SMPTE\_2085} \},
730   \{ \textcolor{stringliteral}{"chromncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a30661e9d9b70ffe9f51f3bdbfd02865b}{AOM\_CICP\_MC\_CHROMAT\_NCL} \},
731   \{ \textcolor{stringliteral}{"chromcl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa391f9255e4775da0120f7472b417193}{AOM\_CICP\_MC\_CHROMAT\_CL} \},
732   \{ \textcolor{stringliteral}{"ictcp"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a7695b0577d3884a89c578f28f4237aee}{AOM\_CICP\_MC\_ICTCP} \},
733   \{ NULL, 0 \}
734 \};
735 
736 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_matrix\_coefficients = ARG\_DEF\_ENUM(
737     NULL, \textcolor{stringliteral}{"matrix-coefficients"}, 1,
738     \textcolor{stringliteral}{"Matrix coefficients (CICP) of input content:"}, matrix\_coefficients\_enum);
739 
740 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list chroma\_sample\_position\_enum[] = \{
741   \{ \textcolor{stringliteral}{"unknown"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba7843506f3e28f720be0d4f03237fb48c}{AOM\_CSP\_UNKNOWN} \},
742   \{ \textcolor{stringliteral}{"vertical"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73baf95ced9b8288642205301cc51e0b55c6}{AOM\_CSP\_VERTICAL} \},
743   \{ \textcolor{stringliteral}{"colocated"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba01ef7204c2234ef43acfd493d5e18c84}{AOM\_CSP\_COLOCATED} \},
744   \{ NULL, 0 \}
745 \};
746 
747 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_sample\_position =
748     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"chroma-sample-position"}, 1,
749                  \textcolor{stringliteral}{"The chroma sample position when chroma 4:2:0 is signaled:"},
750                  chroma\_sample\_position\_enum);
751 
752 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tune\_content\_enum[] = \{
753   \{ \textcolor{stringliteral}{"default"}, AOM\_CONTENT\_DEFAULT \},
754   \{ \textcolor{stringliteral}{"screen"}, AOM\_CONTENT\_SCREEN \},
755   \{ NULL, 0 \}
756 \};
757 
758 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_content = ARG\_DEF\_ENUM(
759     NULL, \textcolor{stringliteral}{"tune-content"}, 1, \textcolor{stringliteral}{"Tune content type"}, tune\_content\_enum);
760 
761 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cdf\_update\_mode =
762     ARG\_DEF(NULL, \textcolor{stringliteral}{"cdf-update-mode"}, 1,
763             \textcolor{stringliteral}{"CDF update mode for entropy coding "}
764             \textcolor{stringliteral}{"(0: no CDF update; 1: update CDF on all frames(default); "}
765             \textcolor{stringliteral}{"2: selectively update CDF on some frames"});
766 
767 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list superblock\_size\_enum[] = \{
768   \{ \textcolor{stringliteral}{"dynamic"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61aaabb4d9ad771b2fa177ff6fb5437b179}{AOM\_SUPERBLOCK\_SIZE\_DYNAMIC} \},
769   \{ \textcolor{stringliteral}{"64"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64} \},
770   \{ \textcolor{stringliteral}{"128"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a17127133dafcd42b1d792770981d67d0}{AOM\_SUPERBLOCK\_SIZE\_128X128} \},
771   \{ NULL, 0 \}
772 \};
773 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superblock\_size = ARG\_DEF\_ENUM(
774     NULL, \textcolor{stringliteral}{"sb-size"}, 1, \textcolor{stringliteral}{"Superblock size to use"}, superblock\_size\_enum);
775 
776 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t set\_tier\_mask =
777     ARG\_DEF(NULL, \textcolor{stringliteral}{"set-tier-mask"}, 1,
778             \textcolor{stringliteral}{"Set bit mask to specify which tier each of the 32 possible "}
779             \textcolor{stringliteral}{"operating points conforms to. "}
780             \textcolor{stringliteral}{"Bit value 0(defualt): Main Tier; 1: High Tier."});
781 
782 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *av1\_args[] = \{ &cpu\_used\_av1,
783                                        &auto\_altref,
784                                        &sharpness,
785                                        &static\_thresh,
786                                        &rowmtarg,
787                                        &tile\_cols,
788                                        &tile\_rows,
789                                        &enable\_tpl\_model,
790                                        &arnr\_maxframes,
791                                        &arnr\_strength,
792                                        &tune\_metric,
793                                        &cq\_level,
794                                        &max\_intra\_rate\_pct,
795                                        &max\_inter\_rate\_pct,
796                                        &gf\_cbr\_boost\_pct,
797                                        &lossless,
798                                        &enable\_cdef,
799                                        &enable\_restoration,
800                                        &enable\_rect\_partitions,
801                                        &enable\_ab\_partitions,
802                                        &enable\_1to4\_partitions,
803                                        &min\_partition\_size,
804                                        &max\_partition\_size,
805                                        &enable\_dual\_filter,
806                                        &enable\_intra\_edge\_filter,
807                                        &enable\_order\_hint,
808                                        &enable\_tx64,
809                                        &tx\_size\_search\_method,
810                                        &enable\_flip\_idtx,
811                                        &enable\_dist\_wtd\_comp,
812                                        &enable\_masked\_comp,
813                                        &enable\_onesided\_comp,
814                                        &enable\_interintra\_comp,
815                                        &enable\_smooth\_interintra,
816                                        &enable\_diff\_wtd\_comp,
817                                        &enable\_interinter\_wedge,
818                                        &enable\_interintra\_wedge,
819                                        &enable\_global\_motion,
820                                        &enable\_warped\_motion,
821                                        &enable\_filter\_intra,
822                                        &enable\_smooth\_intra,
823                                        &enable\_paeth\_intra,
824                                        &enable\_cfl\_intra,
825                                        &enable\_obmc,
826                                        &enable\_palette,
827                                        &enable\_intrabc,
828                                        &enable\_angle\_delta,
829                                        &disable\_trellis\_quant,
830                                        &enable\_qm,
831                                        &qm\_min,
832                                        &qm\_max,
833                                        &reduced\_tx\_type\_set,
834                                        &use\_intra\_dct\_only,
835                                        &use\_inter\_dct\_only,
836                                        &use\_intra\_default\_tx\_only,
837                                        &quant\_b\_adapt,
838                                        &coeff\_cost\_upd\_freq,
839                                        &mode\_cost\_upd\_freq,
840 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
841                                        &enable\_dist\_8x8,
842 \textcolor{preprocessor}{#endif}
843                                        &frame\_parallel\_decoding,
844                                        &error\_resilient\_mode,
845                                        &aq\_mode,
846                                        &deltaq\_mode,
847                                        &deltalf\_mode,
848                                        &frame\_periodic\_boost,
849                                        &noise\_sens,
850                                        &tune\_content,
851                                        &cdf\_update\_mode,
852                                        &input\_color\_primaries,
853                                        &input\_transfer\_characteristics,
854                                        &input\_matrix\_coefficients,
855                                        &input\_chroma\_sample\_position,
856                                        &min\_gf\_interval,
857                                        &max\_gf\_interval,
858                                        &gf\_max\_pyr\_height,
859                                        &superblock\_size,
860                                        &num\_tg,
861                                        &mtu\_size,
862                                        &timing\_info,
863                                        &film\_grain\_test,
864                                        &film\_grain\_table,
865 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
866                                        &denoise\_noise\_level,
867                                        &denoise\_block\_size,
868 \textcolor{preprocessor}{#endif  // CONFIG\_DENOISE}
869                                        &max\_reference\_frames,
870                                        &reduced\_reference\_set,
871                                        &enable\_ref\_frame\_mvs,
872                                        &target\_seq\_level\_idx,
873                                        &set\_tier\_mask,
874                                        &bitdeptharg,
875                                        &inbitdeptharg,
876                                        &input\_chroma\_subsampling\_x,
877                                        &input\_chroma\_subsampling\_y,
878                                        &sframe\_dist,
879                                        &sframe\_mode,
880                                        &save\_as\_annexb,
881                                        NULL \};
882 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} av1\_arg\_ctrl\_map[] = \{ \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED},
883                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF},
884                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0df0d30e82bb9683f3131138dfa2949a}{AOME\_SET\_SHARPNESS},
885                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa4f58f6a86b710e403daeac055738111}{AOME\_SET\_STATIC\_THRESHOLD},
886                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a095d0817d339940aa2578924a840fc84}{AV1E\_SET\_ROW\_MT},
887                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS},
888                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS},
889                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a174ffbc2e91a020a8225900e38894137}{AV1E\_SET\_ENABLE\_TPL\_MODEL},
890                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a327fb270f37bbb008b0f146542ce7483}{AOME\_SET\_ARNR\_MAXFRAMES},
891                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5affd2c213f24a12d13bb51e31be993e60}{AOME\_SET\_ARNR\_STRENGTH},
892                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aba539b6646278e7ff40f67f38639d294}{AOME\_SET\_TUNING},
893                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL},
894                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9e1965ffa40d2d87556b65748c63adcc}{AOME\_SET\_MAX\_INTRA\_BITRATE\_PCT},
895                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a54b7c950e51f39a3cb7344a2665b9929}{AV1E\_SET\_MAX\_INTER\_BITRATE\_PCT},
896                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ade327180f01d27d22abd94c1f0a8bc9e}{AV1E\_SET\_GF\_CBR\_BOOST\_PCT},
897                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS},
898                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a6879fe104e23de00f034ed11eb605031}{AV1E\_SET\_ENABLE\_CDEF},
899                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2ea70b4b379e701a4b3b7cc33eb05e65}{AV1E\_SET\_ENABLE\_RESTORATION},
900                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af3db44e9871c69defc5ae2cc6c5e3ba0}{AV1E\_SET\_ENABLE\_RECT\_PARTITIONS},
901                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a3f494511b35631e4d400f4df9a48c6dc}{AV1E\_SET\_ENABLE\_AB\_PARTITIONS},
902                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ab2b627e9fad54fd84b18e73d8f6a8a51}{AV1E\_SET\_ENABLE\_1TO4\_PARTITIONS},
903                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a4c1444fdafd3577606cef60afb33124c}{AV1E\_SET\_MIN\_PARTITION\_SIZE},
904                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ab15141c333da6ddb99c5f2aeea934958}{AV1E\_SET\_MAX\_PARTITION\_SIZE},
905                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a45867a101866f7ad1a67e7d72f84054a}{AV1E\_SET\_ENABLE\_DUAL\_FILTER},
906                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a518cc32bbf169f8e9d4d71e7c1193748}{AV1E\_SET\_ENABLE\_INTRA\_EDGE\_FILTER},
907                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad0eaf349d653c8357acbba84ad95d5e6}{AV1E\_SET\_ENABLE\_ORDER\_HINT},
908                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ab6d4110cee235e35452d0beb89a28604}{AV1E\_SET\_ENABLE\_TX64},
909                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a37bc192f2194b5c19350a096f59aa51d}{AV1E\_SET\_TX\_SIZE\_SEARCH\_METHOD},
910                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a6c1d6fd0a0607d07cb648e4fe6702780}{AV1E\_SET\_ENABLE\_FLIP\_IDTX},
911                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a80d59744d531d9e0d48c8274792b69dc}{AV1E\_SET\_ENABLE\_DIST\_WTD\_COMP},
912                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a643067b985c437490d6248decad39235}{AV1E\_SET\_ENABLE\_MASKED\_COMP},
913                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adff1eda391fbe14b50ed48633dda01dc}{AV1E\_SET\_ENABLE\_ONESIDED\_COMP},
914                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a4032b6c7ad5f4499af95ddaab863d3d6}{AV1E\_SET\_ENABLE\_INTERINTRA\_COMP},
915                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa15748a927789e02f586d2408eaa78fe}{AV1E\_SET\_ENABLE\_SMOOTH\_INTERINTRA},
916                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a951b38c88fb632d63568da3cce275ecd}{AV1E\_SET\_ENABLE\_DIFF\_WTD\_COMP},
917                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a013aa12c1a51471d2f2f401d6abcb40d}{AV1E\_SET\_ENABLE\_INTERINTER\_WEDGE},
918                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8b3e315575be2741071813f5a3830b79}{AV1E\_SET\_ENABLE\_INTERINTRA\_WEDGE},
919                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad4da3bb77e25bac4a0afc2135617cbd9}{AV1E\_SET\_ENABLE\_GLOBAL\_MOTION},
920                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a4c4ae7f4158f795667b16c99fcdc5dd3}{AV1E\_SET\_ENABLE\_WARPED\_MOTION},
921                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9774262de47ffd2bb7d674bb55951a7e}{AV1E\_SET\_ENABLE\_FILTER\_INTRA},
922                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0a1d54150968c5c20b410bc29dc0caa4}{AV1E\_SET\_ENABLE\_SMOOTH\_INTRA},
923                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a25f7c646aaec0702964c1fb1bf16e298}{AV1E\_SET\_ENABLE\_PAETH\_INTRA},
924                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a993e0e437aa0d152fe654ba0ab46f9d2}{AV1E\_SET\_ENABLE\_CFL\_INTRA},
925                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa51bc0690a7d51765a01afa015ec2077}{AV1E\_SET\_ENABLE\_OBMC},
926                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a98d0e84130317b6c072c2deac106dede}{AV1E\_SET\_ENABLE\_PALETTE},
927                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a3e59c51f12c7350fee92c1c0d4901ab0}{AV1E\_SET\_ENABLE\_INTRABC},
928                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a3155057080db493c868eb2d42d435b61}{AV1E\_SET\_ENABLE\_ANGLE\_DELTA},
929                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a374b5581d0b68d5f8cc3e3f73495cfbb}{AV1E\_SET\_DISABLE\_TRELLIS\_QUANT},
930                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae63993934cdc5aa36efeec4df87a577e}{AV1E\_SET\_ENABLE\_QM},
931                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae611944ba148b6446d4387dd9b452917}{AV1E\_SET\_QM\_MIN},
932                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad897674e1b68b24ec14a01a4e3edacc7}{AV1E\_SET\_QM\_MAX},
933                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc82eae151e4a5050dbc324b5d16be2d}{AV1E\_SET\_REDUCED\_TX\_TYPE\_SET},
934                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a56dd8bdd23f09e24e2afea7633f20e74}{AV1E\_SET\_INTRA\_DCT\_ONLY},
935                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac3dcd39257d82c1be99a8752bef6f20b}{AV1E\_SET\_INTER\_DCT\_ONLY},
936                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a335eed63dd36dd6e9a83a462c3c15fe1}{AV1E\_SET\_INTRA\_DEFAULT\_TX\_ONLY},
937                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a953968db8a041da6fe727add815ad53e}{AV1E\_SET\_QUANT\_B\_ADAPT},
938                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a542a607e7d8c6a3d8244136b3e09da4b}{AV1E\_SET\_COEFF\_COST\_UPD\_FREQ},
939                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afb9a186506424be1020cdd8c79342b7a}{AV1E\_SET\_MODE\_COST\_UPD\_FREQ},
940 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
941                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a7ef16c780349c5fee8281f1e5b4a6718}{AV1E\_SET\_ENABLE\_DIST\_8X8},
942 \textcolor{preprocessor}{#endif}
943                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING},
944                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa0d049453fced5f8079861b16e356c69}{AV1E\_SET\_ERROR\_RESILIENT\_MODE},
945                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17bd297efc31082157785d68fc5a6067}{AV1E\_SET\_AQ\_MODE},
946                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad26eda6211bf3d5fe4f5999ec52b264b}{AV1E\_SET\_DELTAQ\_MODE},
947                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ab2d0e42bcf19974859e61d8709c5ae09}{AV1E\_SET\_DELTALF\_MODE},
948                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a737368591a37417b108c0706f7510885}{AV1E\_SET\_FRAME\_PERIODIC\_BOOST},
949                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8d415cd6976ea5860206e1d3cd3dd222}{AV1E\_SET\_NOISE\_SENSITIVITY},
950                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2625f566fd5c2675eb2bcd40af858652}{AV1E\_SET\_TUNE\_CONTENT},
951                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a277526a4a9b8c413e870ee17ff986e87}{AV1E\_SET\_CDF\_UPDATE\_MODE},
952                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af64e990728fe37287bac0874d77b22db}{AV1E\_SET\_COLOR\_PRIMARIES},
953                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a336fc3607a5987f9077c634f07b3cd53}{AV1E\_SET\_TRANSFER\_CHARACTERISTICS},
954                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0111ed659d2cd11827ac5cd1f3d774b0}{AV1E\_SET\_MATRIX\_COEFFICIENTS},
955                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc5bb5cf57ba1a1193a0593225e881ff}{AV1E\_SET\_CHROMA\_SAMPLE\_POSITION},
956                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a31bcfcb7057884ceb831146c90086ddd}{AV1E\_SET\_MIN\_GF\_INTERVAL},
957                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0355cea227ab76f9bd77028a39bbfca8}{AV1E\_SET\_MAX\_GF\_INTERVAL},
958                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a685f831a5a5d08f9b5a14209d55ac129}{AV1E\_SET\_GF\_MAX\_PYRAMID\_HEIGHT},
959                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
960                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG},
961                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a353037d84b6c47ac0138fa843b70a2bb}{AV1E\_SET\_MTU},
962                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a857e822046c62a4c774b1d16c4e453dd}{AV1E\_SET\_TIMING\_INFO\_TYPE},
963                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a437e6b282a2395b4b08a9acde3e41cfb}{AV1E\_SET\_FILM\_GRAIN\_TEST\_VECTOR},
964                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
965 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
966                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a54fe460f126a7566aa627cd82826faf0}{AV1E\_SET\_DENOISE\_NOISE\_LEVEL},
967                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae113c7e68a6c39b872a268ed6cdf6d10}{AV1E\_SET\_DENOISE\_BLOCK\_SIZE},
968 \textcolor{preprocessor}{#endif  // CONFIG\_DENOISE}
969                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adaa8c4b0f736003b552d1d7d68877f6f}{AV1E\_SET\_MAX\_REFERENCE\_FRAMES},
970                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17fe8deb975a641c65d1dce6b5e3a4e0}{AV1E\_SET\_REDUCED\_REFERENCE\_SET},
971                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a5e82346d8463bf758967abb0d03ebc88}{AV1E\_SET\_ENABLE\_REF\_FRAME\_MVS},
972                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc032ee5a8dc3f51ab88b64737590f1b}{AV1E\_SET\_TARGET\_SEQ\_LEVEL\_IDX},
973                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8a9265ce765bdcf9df119a7e5c7b3cc7}{AV1E\_SET\_TIER\_MASK},
974                                         0 \};
975 \textcolor{preprocessor}{#endif  // CONFIG\_AV1\_ENCODER}
976 
977 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *no\_args[] = \{ NULL \};
978 
979 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
980   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> -o dst\_filename src\_filename \(\backslash\)n"},
981           exec\_name);
982 
983   \textcolor{keywordflow}{if} (shorthelp) \{
984     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
985     \textcolor{keywordflow}{return};
986   \}
987 
988   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nOptions:\(\backslash\)n"});
989   arg\_show\_usage(fout, main\_args);
990   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nEncoder Global Options:\(\backslash\)n"});
991   arg\_show\_usage(fout, global\_args);
992   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nRate Control Options:\(\backslash\)n"});
993   arg\_show\_usage(fout, rc\_args);
994   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nTwopass Rate Control Options:\(\backslash\)n"});
995   arg\_show\_usage(fout, rc\_twopass\_args);
996   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nKeyframe Placement Options:\(\backslash\)n"});
997   arg\_show\_usage(fout, kf\_args);
998 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
999   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nAV1 Specific Options:\(\backslash\)n"});
1000   arg\_show\_usage(fout, av1\_args);
1001 \textcolor{preprocessor}{#endif}
1002   fprintf(fout,
1003           \textcolor{stringliteral}{"\(\backslash\)nStream timebase (--timebase):\(\backslash\)n"}
1004           \textcolor{stringliteral}{"  The desired precision of timestamps in the output, expressed\(\backslash\)n"}
1005           \textcolor{stringliteral}{"  in fractional seconds. Default is 1/1000.\(\backslash\)n"});
1006   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded encoders:\(\backslash\)n\(\backslash\)n"});
1007 
1008   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
1009   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_encoder; ++i) \{
1010     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} encoder = get\_aom\_encoder\_by\_index(i);
1011     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *defstr = (i == (num\_encoder - 1)) ? \textcolor{stringliteral}{"(default)"} : \textcolor{stringliteral}{""};
1012     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s %s\(\backslash\)n"}, encoder->name,
1013             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()), defstr);
1014   \}
1015   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)n        "});
1016   fprintf(fout, \textcolor{stringliteral}{"Use --codec to switch to a non-default encoder.\(\backslash\)n\(\backslash\)n"});
1017 \}
1018 
1019 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
1020   show\_help(stderr, 1);
1021   exit(EXIT\_FAILURE);
1022 \}
1023 
1024 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1025 \textcolor{preprocessor}{#define ARG\_CTRL\_CNT\_MAX NELEMENTS(av1\_arg\_ctrl\_map)}
1026 \textcolor{preprocessor}{#endif}
1027 
1028 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
1029 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} stereo\_format\_t;
1030 \textcolor{keyword}{struct }WebmOutputContext \{
1031   \textcolor{keywordtype}{int} debug;
1032 \};
1033 \textcolor{preprocessor}{#endif}
1034 
1035 \textcolor{comment}{/* Per-stream configuration */}
1036 \textcolor{keyword}{struct }stream\_config \{
1037   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} cfg;
1038   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *out\_fn;
1039   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *stats\_fn;
1040   stereo\_format\_t stereo\_fmt;
1041   \textcolor{keywordtype}{int} arg\_ctrls[ARG\_CTRL\_CNT\_MAX][2];
1042   \textcolor{keywordtype}{int} arg\_ctrl\_cnt;
1043   \textcolor{keywordtype}{int} write\_webm;
1044   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *film\_grain\_filename;
1045   \textcolor{keywordtype}{int} write\_ivf;
1046   \textcolor{comment}{// whether to use 16bit internal buffers}
1047   \textcolor{keywordtype}{int} use\_16bit\_internal;
1048 \};
1049 
1050 \textcolor{keyword}{struct }stream\_state \{
1051   \textcolor{keywordtype}{int} index;
1052   \textcolor{keyword}{struct }stream\_state *next;
1053   \textcolor{keyword}{struct }stream\_config config;
1054   FILE *file;
1055   \textcolor{keyword}{struct }rate\_hist *rate\_hist;
1056   \textcolor{keyword}{struct }WebmOutputContext webm\_ctx;
1057   uint64\_t psnr\_sse\_total;
1058   uint64\_t psnr\_samples\_total;
1059   \textcolor{keywordtype}{double} psnr\_totals[4];
1060   \textcolor{keywordtype}{int} psnr\_count;
1061   \textcolor{keywordtype}{int} counts[64];
1062   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} encoder;
1063   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_out;
1064   uint64\_t cx\_time;
1065   \textcolor{keywordtype}{size\_t} nbytes;
1066   stats\_io\_t stats;
1067   \textcolor{keyword}{struct }\hyperlink{structaom__image}{aom\_image} *img;
1068   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
1069   \textcolor{keywordtype}{int} mismatch\_seen;
1070   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chroma\_subsampling\_x;
1071   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chroma\_subsampling\_y;
1072 \};
1073 
1074 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_positive\_rational(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg,
1075                                        \textcolor{keyword}{struct} \hyperlink{structaom__rational}{aom\_rational} *rat) \{
1076   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} < 0) \{
1077     rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} *= -1;
1078     rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} *= -1;
1079   \}
1080 
1081   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} < 0) die(\textcolor{stringliteral}{"Error: %s must be positive\(\backslash\)n"}, msg);
1082 
1083   \textcolor{keywordflow}{if} (!rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den}) die(\textcolor{stringliteral}{"Error: %s has zero denominator\(\backslash\)n"}, msg);
1084 \}
1085 
1086 \textcolor{comment}{/* Parses global config arguments into the AvxEncoderConfig. Note that}
1087 \textcolor{comment}{ * argv is modified and overwrites all parsed arguments.}
1088 \textcolor{comment}{ */}
1089 \textcolor{keyword}{static} \textcolor{keywordtype}{void} parse\_global\_config(\textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} argc,
1090                                 \textcolor{keywordtype}{char} ***argv) \{
1091   \textcolor{keywordtype}{char} **argi, **argj;
1092   \textcolor{keyword}{struct }arg arg;
1093   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
1094   \textcolor{keywordtype}{char} **argv\_local = (\textcolor{keywordtype}{char} **)*argv;
1095 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1096   \textcolor{keywordtype}{int} argc\_local = argc;
1097 \textcolor{preprocessor}{#endif}
1098   \textcolor{keywordflow}{if} (num\_encoder < 1) die(\textcolor{stringliteral}{"Error: no valid encoder available\(\backslash\)n"});
1099 
1100   \textcolor{comment}{/* Initialize default parameters */}
1101   memset(global, 0, \textcolor{keyword}{sizeof}(*global));
1102   global->codec = get\_aom\_encoder\_by\_index(num\_encoder - 1);
1103   global->passes = 0;
1104   global->color\_type = I420;
1105   global->csp = \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba7843506f3e28f720be0d4f03237fb48c}{AOM\_CSP\_UNKNOWN};
1106 
1107 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1108   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cfg = NULL;
1109   \textcolor{keywordtype}{int} cfg\_included = 0;
1110 \textcolor{preprocessor}{#endif}
1111   \textcolor{keywordflow}{for} (argi = argj = argv\_local; (*argj = *argi); argi += arg.argv\_step) \{
1112     arg.argv\_step = 1;
1113 
1114 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1115     \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_cfg, argi)) \{
1116       \textcolor{keywordflow}{if} (cfg\_included) \textcolor{keywordflow}{continue};
1117       cfg = arg.val;
1118 
1119       arg\_cfg(&argc\_local, &argv\_local, cfg);
1120 
1121       *argj = *argi = *argv\_local;
1122       argj = argi = argv\_local;
1123       *argv = argv\_local;
1124       cfg\_included = 1;
1125       \textcolor{keywordflow}{continue};
1126     \}
1127 \textcolor{preprocessor}{#endif}
1128     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
1129       show\_help(stdout, 0);
1130       exit(EXIT\_SUCCESS);
1131     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
1132       global->codec = get\_aom\_encoder\_by\_name(arg.val);
1133       \textcolor{keywordflow}{if} (!global->codec)
1134         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
1135     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &passes, argi)) \{
1136       global->passes = arg\_parse\_uint(&arg);
1137 
1138       \textcolor{keywordflow}{if} (global->passes < 1 || global->passes > 2)
1139         die(\textcolor{stringliteral}{"Error: Invalid number of passes (%d)\(\backslash\)n"}, global->passes);
1140     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pass\_arg, argi)) \{
1141       global->pass = arg\_parse\_uint(&arg);
1142 
1143       \textcolor{keywordflow}{if} (global->pass < 1 || global->pass > 2)
1144         die(\textcolor{stringliteral}{"Error: Invalid pass selected (%d)\(\backslash\)n"}, global->pass);
1145     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_sample\_position, argi)) \{
1146       global->csp = arg\_parse\_enum(&arg);
1147       \textcolor{comment}{/* Flag is used by later code as well, preserve it. */}
1148       argj++;
1149     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &usage, argi))
1150       global->usage = arg\_parse\_uint(&arg);
1151     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &good\_dl, argi))
1152       global->usage = \hyperlink{group__encoder_ga03ca3defc61e1d70c34e9d94e7cee823}{AOM\_USAGE\_GOOD\_QUALITY};  \textcolor{comment}{// Good quality usage}
1153     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rt\_dl, argi))
1154       global->usage = \hyperlink{group__encoder_gae2cc24d3083099df8eb60ad65f81c62f}{AOM\_USAGE\_REALTIME};  \textcolor{comment}{// Real-time usage}
1155     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi))
1156       global->color\_type = YV12;
1157     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi))
1158       global->color\_type = I420;
1159     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i422, argi))
1160       global->color\_type = I422;
1161     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i444, argi))
1162       global->color\_type = I444;
1163     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &quietarg, argi))
1164       global->quiet = 1;
1165     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi))
1166       global->verbose = 1;
1167     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limit, argi))
1168       global->limit = arg\_parse\_uint(&arg);
1169     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skip, argi))
1170       global->skip\_frames = arg\_parse\_uint(&arg);
1171     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &psnrarg, argi))
1172       global->show\_psnr = 1;
1173     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &recontest, argi))
1174       global->test\_decode = arg\_parse\_enum\_or\_int(&arg);
1175     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framerate, argi)) \{
1176       global->framerate = arg\_parse\_rational(&arg);
1177       validate\_positive\_rational(arg.name, &global->framerate);
1178       global->have\_framerate = 1;
1179     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &debugmode, argi))
1180       global->debug = 1;
1181     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &q\_hist\_n, argi))
1182       global->show\_q\_hist\_buckets = arg\_parse\_uint(&arg);
1183     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rate\_hist\_n, argi))
1184       global->show\_rate\_hist\_buckets = arg\_parse\_uint(&arg);
1185     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warnings, argi))
1186       global->disable\_warnings = 1;
1187     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warning\_prompt, argi))
1188       global->disable\_warning\_prompt = 1;
1189     \textcolor{keywordflow}{else}
1190       argj++;
1191   \}
1192 
1193   \textcolor{keywordflow}{if} (global->pass) \{
1194     \textcolor{comment}{/* DWIM: Assume the user meant passes=2 if pass=2 is specified */}
1195     \textcolor{keywordflow}{if} (global->pass > global->passes) \{
1196       warn(\textcolor{stringliteral}{"Assuming --pass=%d implies --passes=%d\(\backslash\)n"}, global->pass,
1197            global->pass);
1198       global->passes = global->pass;
1199     \}
1200   \}
1201   \textcolor{comment}{/* Validate global config */}
1202   \textcolor{keywordflow}{if} (global->passes == 0) \{
1203 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1204     \textcolor{comment}{// Make default AV1 passes = 2 until there is a better quality 1-pass}
1205     \textcolor{comment}{// encoder}
1206     \textcolor{keywordflow}{if} (global->codec != NULL && global->codec->name != NULL)
1207       global->passes = (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0 &&
1208                         global->usage != \hyperlink{group__encoder_gae2cc24d3083099df8eb60ad65f81c62f}{AOM\_USAGE\_REALTIME})
1209                            ? 2
1210                            : 1;
1211 \textcolor{preprocessor}{#else}
1212     global->passes = 1;
1213 \textcolor{preprocessor}{#endif}
1214   \}
1215 
1216   \textcolor{keywordflow}{if} (global->usage == \hyperlink{group__encoder_gae2cc24d3083099df8eb60ad65f81c62f}{AOM\_USAGE\_REALTIME} && global->passes > 1) \{
1217     warn(\textcolor{stringliteral}{"Enforcing one-pass encoding in realtime mode\(\backslash\)n"});
1218     global->passes = 1;
1219   \}
1220 \}
1221 
1222 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input,
1223                             \hyperlink{aom__image_8h_a48f259fc7774b1c799b3ebe7530c19bd}{aom\_chroma\_sample\_position\_t} csp) \{
1224   \textcolor{comment}{/* Parse certain options from the input file, if possible */}
1225   input->file = strcmp(input->filename, \textcolor{stringliteral}{"-"}) ? fopen(input->filename, \textcolor{stringliteral}{"rb"})
1226                                              : set\_binary\_mode(stdin);
1227 
1228   \textcolor{keywordflow}{if} (!input->file) fatal(\textcolor{stringliteral}{"Failed to open input file"});
1229 
1230   \textcolor{keywordflow}{if} (!fseeko(input->file, 0, SEEK\_END)) \{
1231     \textcolor{comment}{/* Input file is seekable. Figure out how long it is, so we can get}
1232 \textcolor{comment}{     * progress info.}
1233 \textcolor{comment}{     */}
1234     input->length = ftello(input->file);
1235     rewind(input->file);
1236   \}
1237 
1238   \textcolor{comment}{/* Default to 1:1 pixel aspect ratio. */}
1239   input->pixel\_aspect\_ratio.numerator = 1;
1240   input->pixel\_aspect\_ratio.denominator = 1;
1241 
1242   \textcolor{comment}{/* For RAW input sources, these bytes will applied on the first frame}
1243 \textcolor{comment}{   *  in read\_frame().}
1244 \textcolor{comment}{   */}
1245   input->detect.buf\_read = fread(input->detect.buf, 1, 4, input->file);
1246   input->detect.position = 0;
1247 
1248   \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && file\_is\_y4m(input->detect.buf)) \{
1249     \textcolor{keywordflow}{if} (y4m\_input\_open(&input->y4m, input->file, input->detect.buf, 4, csp,
1250                        input->only\_i420) >= 0) \{
1251       input->file\_type = FILE\_TYPE\_Y4M;
1252       input->width = input->y4m.pic\_w;
1253       input->height = input->y4m.pic\_h;
1254       input->pixel\_aspect\_ratio.numerator = input->y4m.par\_n;
1255       input->pixel\_aspect\_ratio.denominator = input->y4m.par\_d;
1256       input->framerate.numerator = input->y4m.fps\_n;
1257       input->framerate.denominator = input->y4m.fps\_d;
1258       input->fmt = input->y4m.aom\_fmt;
1259       input->bit\_depth = input->y4m.bit\_depth;
1260     \} \textcolor{keywordflow}{else}
1261       fatal(\textcolor{stringliteral}{"Unsupported Y4M stream."});
1262   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && fourcc\_is\_ivf(input->detect.buf)) \{
1263     fatal(\textcolor{stringliteral}{"IVF is not supported as input."});
1264   \} \textcolor{keywordflow}{else} \{
1265     input->file\_type = FILE\_TYPE\_RAW;
1266   \}
1267 \}
1268 
1269 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input) \{
1270   fclose(input->file);
1271   \textcolor{keywordflow}{if} (input->file\_type == FILE\_TYPE\_Y4M) y4m\_input\_close(&input->y4m);
1272 \}
1273 
1274 \textcolor{keyword}{static} \textcolor{keyword}{struct }stream\_state *new\_stream(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1275                                        \textcolor{keyword}{struct} stream\_state *prev) \{
1276   \textcolor{keyword}{struct }stream\_state *stream;
1277 
1278   stream = calloc(1, \textcolor{keyword}{sizeof}(*stream));
1279   \textcolor{keywordflow}{if} (stream == NULL) \{
1280     fatal(\textcolor{stringliteral}{"Failed to allocate new stream."});
1281   \}
1282 
1283   \textcolor{keywordflow}{if} (prev) \{
1284     memcpy(stream, prev, \textcolor{keyword}{sizeof}(*stream));
1285     stream->index++;
1286     prev->next = stream;
1287   \} \textcolor{keywordflow}{else} \{
1288     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
1289 
1290     \textcolor{comment}{/* Populate encoder configuration */}
1291     res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(global->codec->codec\_interface(),
1292                                        &stream->config.cfg, global->usage);
1293     \textcolor{keywordflow}{if} (res) fatal(\textcolor{stringliteral}{"Failed to get config: %s\(\backslash\)n"}, \hyperlink{group__codec_ga83c6525528574d1a88e73a9f605c9115}{aom\_codec\_err\_to\_string}(res));
1294 
1295     \textcolor{comment}{/* Change the default timebase to a high enough value so that the}
1296 \textcolor{comment}{     * encoder will always create strictly increasing timestamps.}
1297 \textcolor{comment}{     */}
1298     stream->config.cfg.g\_timebase.den = 1000;
1299 
1300     \textcolor{comment}{/* Never use the library's default resolution, require it be parsed}
1301 \textcolor{comment}{     * from the file or set on the command line.}
1302 \textcolor{comment}{     */}
1303     stream->config.cfg.g\_w = 0;
1304     stream->config.cfg.g\_h = 0;
1305 
1306     \textcolor{comment}{/* Initialize remaining stream parameters */}
1307     stream->config.write\_webm = 1;
1308     stream->config.write\_ivf = 0;
1309 
1310 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1311     stream->config.stereo\_fmt = STEREO\_FORMAT\_MONO;
1312     stream->webm\_ctx.last\_pts\_ns = -1;
1313     stream->webm\_ctx.writer = NULL;
1314     stream->webm\_ctx.segment = NULL;
1315 \textcolor{preprocessor}{#endif}
1316 
1317     \textcolor{comment}{/* Allows removal of the application version from the EBML tags */}
1318     stream->webm\_ctx.debug = global->debug;
1319   \}
1320 
1321   \textcolor{comment}{/* Output files must be specified for each stream */}
1322   stream->config.out\_fn = NULL;
1323 
1324   stream->next = NULL;
1325   \textcolor{keywordflow}{return} stream;
1326 \}
1327 
1328 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_config\_arg\_ctrls(\textcolor{keyword}{struct} stream\_config *config, \textcolor{keywordtype}{int} key,
1329                                  \textcolor{keyword}{const} \textcolor{keyword}{struct} arg *arg) \{
1330   \textcolor{keywordtype}{int} j;
1331   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE}) \{
1332     config->film\_grain\_filename = arg->val;
1333     \textcolor{keywordflow}{return};
1334   \}
1335 
1336   \textcolor{comment}{// For target level, the settings should accumulate rather than overwrite,}
1337   \textcolor{comment}{// so we simply append it.}
1338   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc032ee5a8dc3f51ab88b64737590f1b}{AV1E\_SET\_TARGET\_SEQ\_LEVEL\_IDX}) \{
1339     j = config->arg\_ctrl\_cnt;
1340     assert(j < (\textcolor{keywordtype}{int})ARG\_CTRL\_CNT\_MAX);
1341     config->arg\_ctrls[j][0] = key;
1342     config->arg\_ctrls[j][1] = arg\_parse\_enum\_or\_int(arg);
1343     ++config->arg\_ctrl\_cnt;
1344     \textcolor{keywordflow}{return};
1345   \}
1346 
1347   \textcolor{comment}{/* Point either to the next free element or the first instance of this}
1348 \textcolor{comment}{   * control.}
1349 \textcolor{comment}{   */}
1350   \textcolor{keywordflow}{for} (j = 0; j < config->arg\_ctrl\_cnt; j++)
1351     \textcolor{keywordflow}{if} (config->arg\_ctrls[j][0] == key) \textcolor{keywordflow}{break};
1352 
1353   \textcolor{comment}{/* Update/insert */}
1354   assert(j < (\textcolor{keywordtype}{int})ARG\_CTRL\_CNT\_MAX);
1355   config->arg\_ctrls[j][0] = key;
1356   config->arg\_ctrls[j][1] = arg\_parse\_enum\_or\_int(arg);
1357 
1358   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF} && config->arg\_ctrls[j][1] > 1) \{
1359     warn(\textcolor{stringliteral}{"auto-alt-ref > 1 is deprecated... setting auto-alt-ref=1\(\backslash\)n"});
1360     config->arg\_ctrls[j][1] = 1;
1361   \}
1362   \textcolor{keywordflow}{if} (j == config->arg\_ctrl\_cnt) config->arg\_ctrl\_cnt++;
1363 \}
1364 
1365 \textcolor{keyword}{static} \textcolor{keywordtype}{int} parse\_stream\_params(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1366                                \textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{char} **argv) \{
1367   \textcolor{keywordtype}{char} **argi, **argj;
1368   \textcolor{keyword}{struct }arg arg;
1369   \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t **ctrl\_args = no\_args;
1370   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} *ctrl\_args\_map = NULL;
1371   \textcolor{keyword}{struct }stream\_config *config = &stream->config;
1372   \textcolor{keywordtype}{int} eos\_mark\_found = 0;
1373   \textcolor{keywordtype}{int} webm\_forced = 0;
1374 
1375   \textcolor{comment}{// Handle codec specific options}
1376   \textcolor{keywordflow}{if} (0) \{
1377 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1378   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1379     \textcolor{comment}{// TODO(jingning): Reuse AV1 specific encoder configuration parameters.}
1380     \textcolor{comment}{// Consider to expand this set for AV1 encoder control.}
1381     ctrl\_args = av1\_args;
1382     ctrl\_args\_map = av1\_arg\_ctrl\_map;
1383 \textcolor{preprocessor}{#endif}
1384   \}
1385 
1386   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1387     arg.argv\_step = 1;
1388 
1389     \textcolor{comment}{/* Once we've found an end-of-stream marker (--) we want to continue}
1390 \textcolor{comment}{     * shifting arguments but not consuming them.}
1391 \textcolor{comment}{     */}
1392     \textcolor{keywordflow}{if} (eos\_mark\_found) \{
1393       argj++;
1394       \textcolor{keywordflow}{continue};
1395     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(*argj, \textcolor{stringliteral}{"--"})) \{
1396       eos\_mark\_found = 1;
1397       \textcolor{keywordflow}{continue};
1398     \}
1399 
1400     \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
1401       config->out\_fn = arg.val;
1402       \textcolor{keywordflow}{if} (!webm\_forced) \{
1403         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} out\_fn\_len = strlen(config->out\_fn);
1404         \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1405             !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".ivf"})) \{
1406           config->write\_webm = 0;
1407           config->write\_ivf = 1;
1408         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1409                    !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".obu"})) \{
1410           config->write\_webm = 0;
1411           config->write\_ivf = 0;
1412         \}
1413       \}
1414     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fpf\_name, argi)) \{
1415       config->stats\_fn = arg.val;
1416     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_webm, argi)) \{
1417 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1418       config->write\_webm = 1;
1419       webm\_forced = 1;
1420 \textcolor{preprocessor}{#else}
1421       die(\textcolor{stringliteral}{"Error: --webm specified but webm is disabled."});
1422 \textcolor{preprocessor}{#endif}
1423     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_ivf, argi)) \{
1424       config->write\_webm = 0;
1425       config->write\_ivf = 1;
1426     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_obu, argi)) \{
1427       config->write\_webm = 0;
1428       config->write\_ivf = 0;
1429     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threads, argi)) \{
1430       config->cfg.g\_threads = arg\_parse\_uint(&arg);
1431     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &profile, argi)) \{
1432       config->cfg.g\_profile = arg\_parse\_uint(&arg);
1433     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &width, argi)) \{
1434       config->cfg.g\_w = arg\_parse\_uint(&arg);
1435     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &height, argi)) \{
1436       config->cfg.g\_h = arg\_parse\_uint(&arg);
1437     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_width, argi)) \{
1438       config->cfg.g\_forced\_max\_frame\_width = arg\_parse\_uint(&arg);
1439     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_height, argi)) \{
1440       config->cfg.g\_forced\_max\_frame\_height = arg\_parse\_uint(&arg);
1441     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bitdeptharg, argi)) \{
1442       config->cfg.g\_bit\_depth = arg\_parse\_enum\_or\_int(&arg);
1443     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &inbitdeptharg, argi)) \{
1444       config->cfg.g\_input\_bit\_depth = arg\_parse\_uint(&arg);
1445     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_subsampling\_x, argi)) \{
1446       stream->chroma\_subsampling\_x = arg\_parse\_uint(&arg);
1447     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_subsampling\_y, argi)) \{
1448       stream->chroma\_subsampling\_y = arg\_parse\_uint(&arg);
1449 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1450     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &stereo\_mode, argi)) \{
1451       config->stereo\_fmt = arg\_parse\_enum\_or\_int(&arg);
1452 \textcolor{preprocessor}{#endif}
1453     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &timebase, argi)) \{
1454       config->cfg.g\_timebase = arg\_parse\_rational(&arg);
1455       validate\_positive\_rational(arg.name, &config->cfg.g\_timebase);
1456     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &global\_error\_resilient, argi)) \{
1457       config->cfg.g\_error\_resilient = arg\_parse\_uint(&arg);
1458     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &lag\_in\_frames, argi)) \{
1459       config->cfg.g\_lag\_in\_frames = arg\_parse\_uint(&arg);
1460       \textcolor{keywordflow}{if} (global->usage == \hyperlink{group__encoder_gae2cc24d3083099df8eb60ad65f81c62f}{AOM\_USAGE\_REALTIME} &&
1461           config->cfg.rc\_end\_usage == \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a14b6057d61c61e6117f5af16dcf89b0c}{AOM\_CBR} &&
1462           config->cfg.g\_lag\_in\_frames != 0) \{
1463         warn(\textcolor{stringliteral}{"non-zero %s option ignored in realtime CBR mode.\(\backslash\)n"}, arg.name);
1464         config->cfg.g\_lag\_in\_frames = 0;
1465       \}
1466     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &large\_scale\_tile, argi)) \{
1467       config->cfg.large\_scale\_tile = arg\_parse\_uint(&arg);
1468       \textcolor{keywordflow}{if} (config->cfg.large\_scale\_tile) global->codec = get\_aom\_lst\_encoder();
1469     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &monochrome, argi)) \{
1470       config->cfg.monochrome = 1;
1471     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &full\_still\_picture\_hdr, argi)) \{
1472       config->cfg.full\_still\_picture\_hdr = 1;
1473     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &dropframe\_thresh, argi)) \{
1474       config->cfg.rc\_dropframe\_thresh = arg\_parse\_uint(&arg);
1475     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_mode, argi)) \{
1476       config->cfg.rc\_resize\_mode = arg\_parse\_uint(&arg);
1477     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_denominator, argi)) \{
1478       config->cfg.rc\_resize\_denominator = arg\_parse\_uint(&arg);
1479     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_kf\_denominator, argi)) \{
1480       config->cfg.rc\_resize\_kf\_denominator = arg\_parse\_uint(&arg);
1481     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_mode, argi)) \{
1482       config->cfg.rc\_superres\_mode = arg\_parse\_uint(&arg);
1483     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_denominator, argi)) \{
1484       config->cfg.rc\_superres\_denominator = arg\_parse\_uint(&arg);
1485     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_denominator, argi)) \{
1486       config->cfg.rc\_superres\_kf\_denominator = arg\_parse\_uint(&arg);
1487     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_qthresh, argi)) \{
1488       config->cfg.rc\_superres\_qthresh = arg\_parse\_uint(&arg);
1489     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_qthresh, argi)) \{
1490       config->cfg.rc\_superres\_kf\_qthresh = arg\_parse\_uint(&arg);
1491     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &end\_usage, argi)) \{
1492       config->cfg.rc\_end\_usage = arg\_parse\_enum\_or\_int(&arg);
1493     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &target\_bitrate, argi)) \{
1494       config->cfg.rc\_target\_bitrate = arg\_parse\_uint(&arg);
1495     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &min\_quantizer, argi)) \{
1496       config->cfg.rc\_min\_quantizer = arg\_parse\_uint(&arg);
1497     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &max\_quantizer, argi)) \{
1498       config->cfg.rc\_max\_quantizer = arg\_parse\_uint(&arg);
1499     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &undershoot\_pct, argi)) \{
1500       config->cfg.rc\_undershoot\_pct = arg\_parse\_uint(&arg);
1501     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &overshoot\_pct, argi)) \{
1502       config->cfg.rc\_overshoot\_pct = arg\_parse\_uint(&arg);
1503     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_sz, argi)) \{
1504       config->cfg.rc\_buf\_sz = arg\_parse\_uint(&arg);
1505     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_initial\_sz, argi)) \{
1506       config->cfg.rc\_buf\_initial\_sz = arg\_parse\_uint(&arg);
1507     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_optimal\_sz, argi)) \{
1508       config->cfg.rc\_buf\_optimal\_sz = arg\_parse\_uint(&arg);
1509     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bias\_pct, argi)) \{
1510       config->cfg.rc\_2pass\_vbr\_bias\_pct = arg\_parse\_uint(&arg);
1511       \textcolor{keywordflow}{if} (global->passes < 2)
1512         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1513     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &minsection\_pct, argi)) \{
1514       config->cfg.rc\_2pass\_vbr\_minsection\_pct = arg\_parse\_uint(&arg);
1515 
1516       \textcolor{keywordflow}{if} (global->passes < 2)
1517         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1518     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &maxsection\_pct, argi)) \{
1519       config->cfg.rc\_2pass\_vbr\_maxsection\_pct = arg\_parse\_uint(&arg);
1520 
1521       \textcolor{keywordflow}{if} (global->passes < 2)
1522         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1523     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fwd\_kf\_enabled, argi)) \{
1524       config->cfg.fwd\_kf\_enabled = arg\_parse\_uint(&arg);
1525     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_min\_dist, argi)) \{
1526       config->cfg.kf\_min\_dist = arg\_parse\_uint(&arg);
1527     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_max\_dist, argi)) \{
1528       config->cfg.kf\_max\_dist = arg\_parse\_uint(&arg);
1529     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_disabled, argi)) \{
1530       config->cfg.kf\_mode = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
1531     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_dist, argi)) \{
1532       config->cfg.sframe\_dist = arg\_parse\_uint(&arg);
1533     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_mode, argi)) \{
1534       config->cfg.sframe\_mode = arg\_parse\_uint(&arg);
1535     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &save\_as\_annexb, argi)) \{
1536       config->cfg.save\_as\_annexb = arg\_parse\_uint(&arg);
1537     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_width, argi)) \{
1538       config->cfg.tile\_width\_count =
1539           arg\_parse\_list(&arg, config->cfg.tile\_widths, \hyperlink{aom__encoder_8h_a3ec4904ea175471a03d10705f384d07c}{MAX\_TILE\_WIDTHS});
1540     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_height, argi)) \{
1541       config->cfg.tile\_height\_count =
1542           arg\_parse\_list(&arg, config->cfg.tile\_heights, \hyperlink{aom__encoder_8h_a446aae868ff07f3971d9e84b6602a890}{MAX\_TILE\_HEIGHTS});
1543 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1544     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &ext\_partition, argi)) \{
1545       config->cfg.cfg.ext\_partition = !!arg\_parse\_uint(&arg) > 0;
1546 \textcolor{preprocessor}{#endif}
1547     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (global->usage == \hyperlink{group__encoder_gae2cc24d3083099df8eb60ad65f81c62f}{AOM\_USAGE\_REALTIME} &&
1548                arg\_match(&arg, &enable\_restoration, argi)) \{
1549       \textcolor{keywordflow}{if} (arg\_parse\_uint(&arg) == 1) \{
1550         warn(\textcolor{stringliteral}{"non-zero %s option ignored in realtime mode.\(\backslash\)n"}, arg.name);
1551       \}
1552     \} \textcolor{keywordflow}{else} \{
1553       \textcolor{keywordtype}{int} i, match = 0;
1554       \textcolor{keywordflow}{for} (i = 0; ctrl\_args[i]; i++) \{
1555         \textcolor{keywordflow}{if} (arg\_match(&arg, ctrl\_args[i], argi)) \{
1556           match = 1;
1557           \textcolor{keywordflow}{if} (ctrl\_args\_map) \{
1558             set\_config\_arg\_ctrls(config, ctrl\_args\_map[i], &arg);
1559           \}
1560         \}
1561       \}
1562       \textcolor{keywordflow}{if} (!match) argj++;
1563     \}
1564   \}
1565   config->use\_16bit\_internal =
1566       config->cfg.g\_bit\_depth > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH;
1567   \textcolor{keywordflow}{return} eos\_mark\_found;
1568 \}
1569 
1570 \textcolor{preprocessor}{#define FOREACH\_STREAM(iterator, list)                 \(\backslash\)}
1571 \textcolor{preprocessor}{  for (struct stream\_state *iterator = list; iterator; \(\backslash\)}
1572 \textcolor{preprocessor}{       iterator = iterator->next)}
1573 
1574 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_stream\_config(\textcolor{keyword}{const} \textcolor{keyword}{struct} stream\_state *stream,
1575                                    \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1576   \textcolor{keyword}{const} \textcolor{keyword}{struct }stream\_state *streami;
1577   (void)global;
1578 
1579   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w || !stream->config.cfg.g\_h)
1580     fatal(
1581         \textcolor{stringliteral}{"Stream %d: Specify stream dimensions with --width (-w) "}
1582         \textcolor{stringliteral}{" and --height (-h)"},
1583         stream->index);
1584 
1585   \textcolor{comment}{/* Even if bit depth is set on the command line flag to be lower,}
1586 \textcolor{comment}{   * it is upgraded to at least match the input bit depth.}
1587 \textcolor{comment}{   */}
1588   assert(stream->config.cfg.g\_input\_bit\_depth <=
1589          (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth);
1590 
1591   \textcolor{keywordflow}{for} (streami = stream; streami; streami = streami->next) \{
1592     \textcolor{comment}{/* All streams require output files */}
1593     \textcolor{keywordflow}{if} (!streami->config.out\_fn)
1594       fatal(\textcolor{stringliteral}{"Stream %d: Output file is required (specify with -o)"},
1595             streami->index);
1596 
1597     \textcolor{comment}{/* Check for two streams outputting to the same file */}
1598     \textcolor{keywordflow}{if} (streami != stream) \{
1599       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.out\_fn;
1600       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.out\_fn;
1601       \textcolor{keywordflow}{if} (!strcmp(a, b) && strcmp(a, \textcolor{stringliteral}{"/dev/null"}) && strcmp(a, \textcolor{stringliteral}{":nul"}))
1602         fatal(\textcolor{stringliteral}{"Stream %d: duplicate output file (from stream %d)"},
1603               streami->index, stream->index);
1604     \}
1605 
1606     \textcolor{comment}{/* Check for two streams sharing a stats file. */}
1607     \textcolor{keywordflow}{if} (streami != stream) \{
1608       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.stats\_fn;
1609       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.stats\_fn;
1610       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1611         fatal(\textcolor{stringliteral}{"Stream %d: duplicate stats file (from stream %d)"},
1612               streami->index, stream->index);
1613     \}
1614   \}
1615 \}
1616 
1617 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_stream\_dimensions(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w,
1618                                   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h) \{
1619   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w) \{
1620     \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h)
1621       stream->config.cfg.g\_w = w;
1622     \textcolor{keywordflow}{else}
1623       stream->config.cfg.g\_w = w * stream->config.cfg.g\_h / h;
1624   \}
1625   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h) \{
1626     stream->config.cfg.g\_h = h * stream->config.cfg.g\_w / w;
1627   \}
1628 \}
1629 
1630 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_type\_to\_string(\textcolor{keyword}{enum} VideoFileType t) \{
1631   \textcolor{keywordflow}{switch} (t) \{
1632     \textcolor{keywordflow}{case} FILE\_TYPE\_RAW: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"RAW"};
1633     \textcolor{keywordflow}{case} FILE\_TYPE\_Y4M: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Y4M"};
1634     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1635   \}
1636 \}
1637 
1638 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *image\_format\_to\_string(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} f) \{
1639   \textcolor{keywordflow}{switch} (f) \{
1640     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I420"};
1641     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I422"};
1642     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I444"};
1643     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"YV12"};
1644     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca6d845490a6333fca3ac22cc1105deadd}{AOM\_IMG\_FMT\_YV1216}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"YV1216"};
1645     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42016"};
1646     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42216"};
1647     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I44416"};
1648     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1649   \}
1650 \}
1651 
1652 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_stream\_config(\textcolor{keyword}{struct} stream\_state *stream,
1653                                \textcolor{keyword}{struct} AvxEncoderConfig *global,
1654                                \textcolor{keyword}{struct} AvxInputContext *input) \{
1655 \textcolor{preprocessor}{#define SHOW(field) \(\backslash\)}
1656 \textcolor{preprocessor}{  fprintf(stderr, "    %-28s = %d\(\backslash\)n", #field, stream->config.cfg.field)}
1657 
1658   \textcolor{keywordflow}{if} (stream->index == 0) \{
1659     fprintf(stderr, \textcolor{stringliteral}{"Codec: %s\(\backslash\)n"},
1660             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(global->codec->codec\_interface()));
1661     fprintf(stderr, \textcolor{stringliteral}{"Source file: %s File Type: %s Format: %s\(\backslash\)n"},
1662             input->filename, file\_type\_to\_string(input->file\_type),
1663             image\_format\_to\_string(input->fmt));
1664   \}
1665   \textcolor{keywordflow}{if} (stream->next || stream->index)
1666     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nStream Index: %d\(\backslash\)n"}, stream->index);
1667   fprintf(stderr, \textcolor{stringliteral}{"Destination file: %s\(\backslash\)n"}, stream->config.out\_fn);
1668   fprintf(stderr, \textcolor{stringliteral}{"Coding path: %s\(\backslash\)n"},
1669           stream->config.use\_16bit\_internal ? \textcolor{stringliteral}{"HBD"} : \textcolor{stringliteral}{"LBD"});
1670   fprintf(stderr, \textcolor{stringliteral}{"Encoder parameters:\(\backslash\)n"});
1671 
1672   SHOW(g\_usage);
1673   SHOW(g\_threads);
1674   SHOW(g\_profile);
1675   SHOW(g\_w);
1676   SHOW(g\_h);
1677   SHOW(g\_bit\_depth);
1678   SHOW(g\_input\_bit\_depth);
1679   SHOW(g\_timebase.num);
1680   SHOW(g\_timebase.den);
1681   SHOW(g\_error\_resilient);
1682   SHOW(g\_pass);
1683   SHOW(g\_lag\_in\_frames);
1684   SHOW(large\_scale\_tile);
1685   SHOW(rc\_dropframe\_thresh);
1686   SHOW(rc\_resize\_mode);
1687   SHOW(rc\_resize\_denominator);
1688   SHOW(rc\_resize\_kf\_denominator);
1689   SHOW(rc\_superres\_mode);
1690   SHOW(rc\_superres\_denominator);
1691   SHOW(rc\_superres\_kf\_denominator);
1692   SHOW(rc\_superres\_qthresh);
1693   SHOW(rc\_superres\_kf\_qthresh);
1694   SHOW(rc\_end\_usage);
1695   SHOW(rc\_target\_bitrate);
1696   SHOW(rc\_min\_quantizer);
1697   SHOW(rc\_max\_quantizer);
1698   SHOW(rc\_undershoot\_pct);
1699   SHOW(rc\_overshoot\_pct);
1700   SHOW(rc\_buf\_sz);
1701   SHOW(rc\_buf\_initial\_sz);
1702   SHOW(rc\_buf\_optimal\_sz);
1703   SHOW(rc\_2pass\_vbr\_bias\_pct);
1704   SHOW(rc\_2pass\_vbr\_minsection\_pct);
1705   SHOW(rc\_2pass\_vbr\_maxsection\_pct);
1706   SHOW(fwd\_kf\_enabled);
1707   SHOW(kf\_mode);
1708   SHOW(kf\_min\_dist);
1709   SHOW(kf\_max\_dist);
1710 \}
1711 
1712 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1713                              \textcolor{keyword}{struct} AvxEncoderConfig *global,
1714                              \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxRational *pixel\_aspect\_ratio) \{
1715   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fn = stream->config.out\_fn;
1716   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1717 
1718   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1719 
1720   stream->file = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"wb"}) : set\_binary\_mode(stdout);
1721 
1722   \textcolor{keywordflow}{if} (!stream->file) fatal(\textcolor{stringliteral}{"Failed to open output file"});
1723 
1724   \textcolor{keywordflow}{if} (stream->config.write\_webm && fseek(stream->file, 0, SEEK\_CUR))
1725     fatal(\textcolor{stringliteral}{"WebM output to pipes not supported."});
1726 
1727 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1728   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1729     stream->webm\_ctx.stream = stream->file;
1730     \textcolor{keywordflow}{if} (write\_webm\_file\_header(&stream->webm\_ctx, &stream->encoder, cfg,
1731                                stream->config.stereo\_fmt, global->codec->fourcc,
1732                                pixel\_aspect\_ratio) != 0) \{
1733       fatal(\textcolor{stringliteral}{"WebM writer initialization failed."});
1734     \}
1735   \}
1736 \textcolor{preprocessor}{#else}
1737   (void)pixel\_aspect\_ratio;
1738 \textcolor{preprocessor}{#endif}
1739 
1740   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1741     ivf\_write\_file\_header(stream->file, cfg, global->codec->fourcc, 0);
1742   \}
1743 \}
1744 
1745 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1746                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fourcc) \{
1747   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1748 
1749   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1750 
1751 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1752   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1753     \textcolor{keywordflow}{if} (write\_webm\_file\_footer(&stream->webm\_ctx) != 0) \{
1754       fatal(\textcolor{stringliteral}{"WebM writer finalization failed."});
1755     \}
1756   \}
1757 \textcolor{preprocessor}{#endif}
1758 
1759   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1760     \textcolor{keywordflow}{if} (!fseek(stream->file, 0, SEEK\_SET))
1761       ivf\_write\_file\_header(stream->file, &stream->config.cfg, fourcc,
1762                             stream->frames\_out);
1763   \}
1764 
1765   fclose(stream->file);
1766 \}
1767 
1768 \textcolor{keyword}{static} \textcolor{keywordtype}{void} setup\_pass(\textcolor{keyword}{struct} stream\_state *stream,
1769                        \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} pass) \{
1770   \textcolor{keywordflow}{if} (stream->config.stats\_fn) \{
1771     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->stats, stream->config.stats\_fn, pass))
1772       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1773   \} \textcolor{keywordflow}{else} \{
1774     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->stats, pass))
1775       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1776   \}
1777 
1778   stream->config.cfg.g\_pass = global->passes == 2
1779                                   ? pass ? \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS} : 
      \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}
1780                                   : \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a1b4b8ee9c1910fc59ac9dfd9700f3f02}{AOM\_RC\_ONE\_PASS};
1781   \textcolor{keywordflow}{if} (pass) \{
1782     stream->config.cfg.rc\_twopass\_stats\_in = stats\_get(&stream->stats);
1783   \}
1784 
1785   stream->cx\_time = 0;
1786   stream->nbytes = 0;
1787   stream->frames\_out = 0;
1788 \}
1789 
1790 \textcolor{keyword}{static} \textcolor{keywordtype}{void} initialize\_encoder(\textcolor{keyword}{struct} stream\_state *stream,
1791                                \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1792   \textcolor{keywordtype}{int} i;
1793   \textcolor{keywordtype}{int} flags = 0;
1794 
1795   flags |= global->show\_psnr ? \hyperlink{group__encoder_gae722c9f9ba9b4ca8dba6bbe7c0692024}{AOM\_CODEC\_USE\_PSNR} : 0;
1796   flags |= stream->config.use\_16bit\_internal ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH} : 0;
1797 
1798   \textcolor{comment}{/* Construct Encoder Context */}
1799   \hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&stream->encoder, global->codec->codec\_interface(),
1800                      &stream->config.cfg, flags);
1801   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to initialize encoder"});
1802 
1803   \textcolor{comment}{/* Note that we bypass the aom\_codec\_control wrapper macro because}
1804 \textcolor{comment}{   * we're being clever to store the control IDs in an array. Real}
1805 \textcolor{comment}{   * applications will want to make use of the enumerations directly}
1806 \textcolor{comment}{   */}
1807   \textcolor{keywordflow}{for} (i = 0; i < stream->config.arg\_ctrl\_cnt; i++) \{
1808     \textcolor{keywordtype}{int} ctrl = stream->config.arg\_ctrls[i][0];
1809     \textcolor{keywordtype}{int} value = stream->config.arg\_ctrls[i][1];
1810     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, ctrl, value))
1811       fprintf(stderr, \textcolor{stringliteral}{"Error: Tried to set control %d = %d\(\backslash\)n"}, ctrl, value);
1812 
1813     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to control codec"});
1814   \}
1815   \textcolor{keywordflow}{if} (stream->config.film\_grain\_filename) \{
1816     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
1817                        stream->config.film\_grain\_filename);
1818   \}
1819 
1820 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1821   \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF) \{
1822     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(global->codec->name);
1823     \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
1824     \hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&stream->decoder, decoder->codec\_interface(), &
      \hyperlink{structaom__codec__enc__cfg_a91c4b8e91211a9cea98a8003ef2e4e65}{cfg}, 0);
1825 
1826     \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1827       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE},
1828                         stream->config.cfg.large\_scale\_tile);
1829       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_mode"});
1830 
1831       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB},
1832                         stream->config.cfg.save\_as\_annexb);
1833       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set is\_annexb"});
1834 
1835       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, -1);
1836       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_row"});
1837 
1838       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, AV1\_SET\_DECODE\_TILE\_COL, -1);
1839       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_col"});
1840     \}
1841   \}
1842 \textcolor{preprocessor}{#endif}
1843 \}
1844 
1845 \textcolor{keyword}{static} \textcolor{keywordtype}{void} encode\_frame(\textcolor{keyword}{struct} stream\_state *stream,
1846                          \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keyword}{struct} \hyperlink{structaom__image}{aom\_image} *img,
1847                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_in) \{
1848   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} frame\_start, next\_frame\_start;
1849   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1850   \textcolor{keyword}{struct }aom\_usec\_timer timer;
1851 
1852   frame\_start =
1853       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in - 1) * global->framerate.den) /
1854       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1855   next\_frame\_start =
1856       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in)*global->framerate.den) /
1857       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1858 
1859   \textcolor{comment}{/* Scale if necessary */}
1860   \textcolor{keywordflow}{if} (img) \{
1861     \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) &&
1862         (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1863       \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
1864         fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 inputs\(\backslash\)n"}, exec\_name);
1865         exit(EXIT\_FAILURE);
1866       \}
1867 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1868       \textcolor{keywordflow}{if} (!stream->img) \{
1869         stream->img =
1870             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1871       \}
1872       I420Scale\_16(
1873           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_Y] / 2,
1874           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2,
1875           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2,
1876           img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16\_t *)stream->img->planes[AOM\_PLANE\_Y],
1877           stream->img->stride[AOM\_PLANE\_Y] / 2,
1878           (uint16\_t *)stream->img->planes[AOM\_PLANE\_U],
1879           stream->img->stride[AOM\_PLANE\_U] / 2,
1880           (uint16\_t *)stream->img->planes[AOM\_PLANE\_V],
1881           stream->img->stride[AOM\_PLANE\_V] / 2, stream->img->d\_w,
1882           stream->img->d\_h, kFilterBox);
1883       img = stream->img;
1884 \textcolor{preprocessor}{#else}
1885       stream->encoder.err = 1;
1886       ctx\_exit\_on\_error(&stream->encoder,
1887                         \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1888                         \textcolor{stringliteral}{"libyuv is required for scaling but is currently "}
1889                         \textcolor{stringliteral}{"disabled.\(\backslash\)n"}
1890                         \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running "}
1891                         \textcolor{stringliteral}{"cmake.\(\backslash\)n"},
1892                         stream->index);
1893 \textcolor{preprocessor}{#endif}
1894     \}
1895   \}
1896   \textcolor{keywordflow}{if} (img && (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1897     \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) \{
1898       fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 8bpp inputs\(\backslash\)n"}, exec\_name);
1899       exit(EXIT\_FAILURE);
1900     \}
1901 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1902     \textcolor{keywordflow}{if} (!stream->img)
1903       stream->img =
1904           \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1905     I420Scale(
1906         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1907         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
1908         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
1909         stream->img->planes[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], stream->img->stride[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1910         stream->img->planes[AOM\_PLANE\_U], stream->img->stride[AOM\_PLANE\_U],
1911         stream->img->planes[AOM\_PLANE\_V], stream->img->stride[AOM\_PLANE\_V],
1912         stream->img->d\_w, stream->img->d\_h, kFilterBox);
1913     img = stream->img;
1914 \textcolor{preprocessor}{#else}
1915     stream->encoder.err = 1;
1916     ctx\_exit\_on\_error(&stream->encoder,
1917                       \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1918                       \textcolor{stringliteral}{"Scaling disabled in this configuration. \(\backslash\)n"}
1919                       \textcolor{stringliteral}{"To enable, configure with --enable-libyuv\(\backslash\)n"},
1920                       stream->index);
1921 \textcolor{preprocessor}{#endif}
1922   \}
1923 
1924   aom\_usec\_timer\_start(&timer);
1925   \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(&stream->encoder, img, frame\_start,
1926                    (uint32\_t)(next\_frame\_start - frame\_start), 0);
1927   aom\_usec\_timer\_mark(&timer);
1928   stream->cx\_time += aom\_usec\_timer\_elapsed(&timer);
1929   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Stream %d: Failed to encode frame"},
1930                     stream->index);
1931 \}
1932 
1933 \textcolor{keyword}{static} \textcolor{keywordtype}{void} update\_quantizer\_histogram(\textcolor{keyword}{struct} stream\_state *stream) \{
1934   \textcolor{keywordflow}{if} (stream->config.cfg.g\_pass != \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \{
1935     \textcolor{keywordtype}{int} q;
1936 
1937     \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17b924cadd3c942f9e57fe6fc4d5e2ab}{AOME\_GET\_LAST\_QUANTIZER\_64}, &q);
1938     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to read quantizer"});
1939     stream->counts[q]++;
1940   \}
1941 \}
1942 
1943 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_cx\_data(\textcolor{keyword}{struct} stream\_state *stream,
1944                         \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} *got\_data) \{
1945   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt;
1946   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1947   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
1948 
1949   *got\_data = 0;
1950   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(&stream->encoder, &iter))) \{
1951     \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} fsize = 0;
1952     \textcolor{keyword}{static} FileOffset ivf\_header\_pos = 0;
1953 
1954     \textcolor{keywordflow}{switch} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind}) \{
1955       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}:
1956         ++stream->frames\_out;
1957         \textcolor{keywordflow}{if} (!global->quiet)
1958           fprintf(stderr, \textcolor{stringliteral}{" %6luF"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
1959 
1960         update\_rate\_histogram(stream->rate\_hist, cfg, pkt);
1961 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1962         \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1963           \textcolor{keywordflow}{if} (write\_webm\_block(&stream->webm\_ctx, cfg, pkt) != 0) \{
1964             fatal(\textcolor{stringliteral}{"WebM writer failed."});
1965           \}
1966         \}
1967 \textcolor{preprocessor}{#endif}
1968         \textcolor{keywordflow}{if} (!stream->config.write\_webm) \{
1969           \textcolor{keywordflow}{if} (stream->config.write\_ivf) \{
1970             \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.partition\_id <= 0) \{
1971               ivf\_header\_pos = ftello(stream->file);
1972               fsize = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1973 
1974               ivf\_write\_frame\_header(stream->file, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts, fsize);
1975             \} \textcolor{keywordflow}{else} \{
1976               fsize += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1977 
1978               \textcolor{keyword}{const} FileOffset currpos = ftello(stream->file);
1979               fseeko(stream->file, ivf\_header\_pos, SEEK\_SET);
1980               ivf\_write\_frame\_size(stream->file, fsize);
1981               fseeko(stream->file, currpos, SEEK\_SET);
1982             \}
1983           \}
1984 
1985           (void)fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
1986                        stream->file);
1987         \}
1988         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1989 
1990         *got\_data = 1;
1991 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1992         \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF && !stream->mismatch\_seen) \{
1993           \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&stream->decoder, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
1994                            pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL);
1995           \textcolor{keywordflow}{if} (stream->decoder.err) \{
1996             warn\_or\_exit\_on\_error(&stream->decoder,
1997                                   global->test\_decode == TEST\_DECODE\_FATAL,
1998                                   \textcolor{stringliteral}{"Failed to decode frame %d in stream %d"},
1999                                   stream->frames\_out + 1, stream->index);
2000             stream->mismatch\_seen = stream->frames\_out + 1;
2001           \}
2002         \}
2003 \textcolor{preprocessor}{#endif}
2004         \textcolor{keywordflow}{break};
2005       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}:
2006         stream->frames\_out++;
2007         stats\_write(&stream->stats, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf},
2008                     pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz});
2009         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
2010         \textcolor{keywordflow}{break};
2011       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda3293bb764f30c11e9583510029578b75}{AOM\_CODEC\_PSNR\_PKT}:
2012 
2013         \textcolor{keywordflow}{if} (global->show\_psnr) \{
2014           \textcolor{keywordtype}{int} i;
2015 
2016           stream->psnr\_sse\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.sse[0];
2017           stream->psnr\_samples\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.samples[0];
2018           \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
2019             \textcolor{keywordflow}{if} (!global->quiet)
2020               fprintf(stderr, \textcolor{stringliteral}{"%.3f "}, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i]);
2021             stream->psnr\_totals[i] += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i];
2022           \}
2023           stream->psnr\_count++;
2024         \}
2025 
2026         \textcolor{keywordflow}{break};
2027       \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2028     \}
2029   \}
2030 \}
2031 
2032 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_psnr(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{double} peak, int64\_t bps) \{
2033   \textcolor{keywordtype}{int} i;
2034   \textcolor{keywordtype}{double} ovpsnr;
2035 
2036   \textcolor{keywordflow}{if} (!stream->psnr\_count) \textcolor{keywordflow}{return};
2037 
2038   fprintf(stderr, \textcolor{stringliteral}{"Stream %d PSNR (Overall/Avg/Y/U/V)"}, stream->index);
2039   ovpsnr = sse\_to\_psnr((\textcolor{keywordtype}{double})stream->psnr\_samples\_total, peak,
2040                        (\textcolor{keywordtype}{double})stream->psnr\_sse\_total);
2041   fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, ovpsnr);
2042 
2043   \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
2044     fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, stream->psnr\_totals[i] / stream->psnr\_count);
2045   \}
2046   \textcolor{keywordflow}{if} (bps > 0) \{
2047     fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" bps"}, bps);
2048   \}
2049   fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" ms"}, stream->cx\_time / 1000);
2050   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
2051 \}
2052 
2053 \textcolor{keyword}{static} \textcolor{keywordtype}{float} usec\_to\_fps(uint64\_t usec, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames) \{
2054   \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float})(usec > 0 ? frames * 1000000.0 / (float)usec : 0);
2055 \}
2056 
2057 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_decode(\textcolor{keyword}{struct} stream\_state *stream,
2058                         \textcolor{keyword}{enum} TestDecodeFatality fatal) \{
2059   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
2060 
2061   \textcolor{keywordflow}{if} (stream->mismatch\_seen) \textcolor{keywordflow}{return};
2062 
2063   \textcolor{comment}{/* Get the internal reference frame */}
2064   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      enc\_img);
2065   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      dec\_img);
2066 
2067   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
2068       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
2069     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
2070       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
2071       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2072                     enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
2073       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
2074       enc\_img = enc\_hbd\_img;
2075     \}
2076     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
2077       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
2078       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2079                     dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
2080       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
2081       dec\_img = dec\_hbd\_img;
2082     \}
2083   \}
2084 
2085   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
2086   ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
2087 
2088   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
2089     \textcolor{keywordtype}{int} y[4], u[4], v[4];
2090     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
2091       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
2092     \} \textcolor{keywordflow}{else} \{
2093       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
2094     \}
2095     stream->decoder.err = 1;
2096     warn\_or\_exit\_on\_error(&stream->decoder, fatal == TEST\_DECODE\_FATAL,
2097                           \textcolor{stringliteral}{"Stream %d: Encode/decode mismatch on frame %d at"}
2098                           \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
2099                           \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
2100                           \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
2101                           stream->index, stream->frames\_out, y[0], y[1], y[2],
2102                           y[3], u[0], u[1], u[2], u[3], v[0], v[1], v[2], v[3]);
2103     stream->mismatch\_seen = stream->frames\_out;
2104   \}
2105 
2106   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
2107   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
2108 \}
2109 
2110 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_time(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *label, int64\_t etl) \{
2111   int64\_t hours;
2112   int64\_t mins;
2113   int64\_t secs;
2114 
2115   \textcolor{keywordflow}{if} (etl >= 0) \{
2116     hours = etl / 3600;
2117     etl -= hours * 3600;
2118     mins = etl / 60;
2119     etl -= mins * 60;
2120     secs = etl;
2121 
2122     fprintf(stderr, \textcolor{stringliteral}{"[%3s %2"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{"] "}, label,
2123             hours, mins, secs);
2124   \} \textcolor{keywordflow}{else} \{
2125     fprintf(stderr, \textcolor{stringliteral}{"[%3s  unknown] "}, label);
2126   \}
2127 \}
2128 
2129 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
2130   \textcolor{keywordtype}{int} pass;
2131   \hyperlink{structaom__image}{aom\_image\_t} raw;
2132   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
2133   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
2134   \textcolor{keywordtype}{int} use\_16bit\_internal = 0;
2135   \textcolor{keywordtype}{int} input\_shift = 0;
2136   \textcolor{keywordtype}{int} frame\_avail, got\_data;
2137 
2138   \textcolor{keyword}{struct }AvxInputContext input;
2139   \textcolor{keyword}{struct }AvxEncoderConfig global;
2140   \textcolor{keyword}{struct }stream\_state *streams = NULL;
2141   \textcolor{keywordtype}{char} **argv, **argi;
2142   uint64\_t cx\_time = 0;
2143   \textcolor{keywordtype}{int} stream\_cnt = 0;
2144   \textcolor{keywordtype}{int} res = 0;
2145   \textcolor{keywordtype}{int} profile\_updated = 0;
2146 
2147   memset(&input, 0, \textcolor{keyword}{sizeof}(input));
2148   exec\_name = argv\_[0];
2149 
2150   \textcolor{comment}{/* Setup default input stream settings */}
2151   input.framerate.numerator = 30;
2152   input.framerate.denominator = 1;
2153   input.only\_i420 = 1;
2154   input.bit\_depth = 0;
2155 
2156   \textcolor{comment}{/* First parse the global configuration values, because we want to apply}
2157 \textcolor{comment}{   * other parameters on top of the default configuration provided by the}
2158 \textcolor{comment}{   * codec.}
2159 \textcolor{comment}{   */}
2160   argv = argv\_dup(argc - 1, argv\_ + 1);
2161   parse\_global\_config(&global, argc, &argv);
2162 
2163 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
2164   \textcolor{keywordflow}{if} (argc < 2) usage\_exit();
2165 \textcolor{preprocessor}{#else}
2166   \textcolor{keywordflow}{if} (argc < 3) usage\_exit();
2167 \textcolor{preprocessor}{#endif}
2168 
2169   \textcolor{keywordflow}{switch} (global.color\_type) \{
2170     \textcolor{keywordflow}{case} I420: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}; \textcolor{keywordflow}{break};
2171     \textcolor{keywordflow}{case} I422: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}; \textcolor{keywordflow}{break};
2172     \textcolor{keywordflow}{case} I444: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}; \textcolor{keywordflow}{break};
2173     \textcolor{keywordflow}{case} YV12: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}; \textcolor{keywordflow}{break};
2174   \}
2175 
2176   \{
2177     \textcolor{comment}{/* Now parse each stream's parameters. Using a local scope here}
2178 \textcolor{comment}{     * due to the use of 'stream' as loop variable in FOREACH\_STREAM}
2179 \textcolor{comment}{     * loops}
2180 \textcolor{comment}{     */}
2181     \textcolor{keyword}{struct }stream\_state *stream = NULL;
2182 
2183     \textcolor{keywordflow}{do} \{
2184       stream = new\_stream(&global, stream);
2185       stream\_cnt++;
2186       \textcolor{keywordflow}{if} (!streams) streams = stream;
2187     \} \textcolor{keywordflow}{while} (parse\_stream\_params(&global, stream, argv));
2188   \}
2189 
2190   \textcolor{comment}{/* Check for unrecognized options */}
2191   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
2192     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && argi[0][1])
2193       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
2194 
2195   FOREACH\_STREAM(stream, streams) \{
2196     check\_encoder\_config(global.disable\_warning\_prompt, &global,
2197                          &stream->config.cfg);
2198 
2199     \textcolor{comment}{// If large\_scale\_tile = 1, only support to output to ivf format.}
2200     \textcolor{keywordflow}{if} (stream->config.cfg.large\_scale\_tile && !stream->config.write\_ivf)
2201       die(\textcolor{stringliteral}{"only support ivf output format while large-scale-tile=1\(\backslash\)n"});
2202   \}
2203 
2204   \textcolor{comment}{/* Handle non-option arguments */}
2205   input.filename = argv[0];
2206 
2207   \textcolor{keywordflow}{if} (!input.filename) \{
2208     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
2209     usage\_exit();
2210   \}
2211 
2212   \textcolor{comment}{/* Decide if other chroma subsamplings than 4:2:0 are supported */}
2213   \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) input.only\_i420 = 0;
2214 
2215   \textcolor{keywordflow}{for} (pass = global.pass ? global.pass - 1 : 0; pass < global.passes; pass++) \{
2216     \textcolor{keywordtype}{int} frames\_in = 0, seen\_frames = 0;
2217     int64\_t estimated\_time\_left = -1;
2218     int64\_t average\_rate = -1;
2219     int64\_t lagged\_count = 0;
2220 
2221     open\_input\_file(&input, global.csp);
2222 
2223     \textcolor{comment}{/* If the input file doesn't specify its w/h (raw files), try to get}
2224 \textcolor{comment}{     * the data from the first stream's configuration.}
2225 \textcolor{comment}{     */}
2226     \textcolor{keywordflow}{if} (!input.width || !input.height) \{
2227       FOREACH\_STREAM(stream, streams) \{
2228         \textcolor{keywordflow}{if} (stream->config.cfg.g\_w && stream->config.cfg.g\_h) \{
2229           input.width = stream->config.cfg.g\_w;
2230           input.height = stream->config.cfg.g\_h;
2231           \textcolor{keywordflow}{break};
2232         \}
2233       \};
2234     \}
2235 
2236     \textcolor{comment}{/* Update stream configurations from the input file's parameters */}
2237     \textcolor{keywordflow}{if} (!input.width || !input.height)
2238       fatal(
2239           \textcolor{stringliteral}{"Specify stream dimensions with --width (-w) "}
2240           \textcolor{stringliteral}{" and --height (-h)"});
2241 
2242     \textcolor{comment}{/* If input file does not specify bit-depth but input-bit-depth parameter}
2243 \textcolor{comment}{     * exists, assume that to be the input bit-depth. However, if the}
2244 \textcolor{comment}{     * input-bit-depth paramter does not exist, assume the input bit-depth}
2245 \textcolor{comment}{     * to be the same as the codec bit-depth.}
2246 \textcolor{comment}{     */}
2247     \textcolor{keywordflow}{if} (!input.bit\_depth) \{
2248       FOREACH\_STREAM(stream, streams) \{
2249         \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth)
2250           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
2251         \textcolor{keywordflow}{else}
2252           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth =
2253               (int)stream->config.cfg.g\_bit\_depth;
2254       \}
2255       \textcolor{keywordflow}{if} (input.bit\_depth > 8) input.fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
2256     \} \textcolor{keywordflow}{else} \{
2257       FOREACH\_STREAM(stream, streams) \{
2258         stream->config.cfg.g\_input\_bit\_depth = input.bit\_depth;
2259       \}
2260     \}
2261 
2262     FOREACH\_STREAM(stream, streams) \{
2263       \textcolor{keywordflow}{if} (input.fmt != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && input.fmt != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
2264         \textcolor{comment}{/* Automatically upgrade if input is non-4:2:0 but a 4:2:0 profile}
2265 \textcolor{comment}{           was selected. */}
2266         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
2267           \textcolor{keywordflow}{case} 0:
2268             \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2269                                          input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2270               \textcolor{keywordflow}{if} (!stream->config.cfg.monochrome) \{
2271                 stream->config.cfg.g\_profile = 1;
2272                 profile\_updated = 1;
2273               \}
2274             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2275                        input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2276               stream->config.cfg.g\_profile = 2;
2277               profile\_updated = 1;
2278             \}
2279             \textcolor{keywordflow}{break};
2280           \textcolor{keywordflow}{case} 1:
2281             \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2282                 input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2283               stream->config.cfg.g\_profile = 2;
2284               profile\_updated = 1;
2285             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2286                        (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2287                         input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2288               stream->config.cfg.g\_profile = 0;
2289               profile\_updated = 1;
2290             \}
2291             \textcolor{keywordflow}{break};
2292           \textcolor{keywordflow}{case} 2:
2293             \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2294                                          input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2295               stream->config.cfg.g\_profile = 1;
2296               profile\_updated = 1;
2297             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2298                        (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2299                         input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2300               stream->config.cfg.g\_profile = 0;
2301               profile\_updated = 1;
2302             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 &&
2303                        input.file\_type == FILE\_TYPE\_Y4M) \{
2304               \textcolor{comment}{// Note that here the input file values for chroma subsampling}
2305               \textcolor{comment}{// are used instead of those from the command line.}
2306               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a283dd3f4387e5f3a754fea0d206b1cb0}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_X},
2307                                 input.y4m.dst\_c\_dec\_h >> 1);
2308               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a501a9453d5790f32c001e9877d3db40c}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_Y},
2309                                 input.y4m.dst\_c\_dec\_v >> 1);
2310             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 &&
2311                        input.file\_type == FILE\_TYPE\_RAW) \{
2312               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a283dd3f4387e5f3a754fea0d206b1cb0}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_X},
2313                                 stream->chroma\_subsampling\_x);
2314               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a501a9453d5790f32c001e9877d3db40c}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_Y},
2315                                 stream->chroma\_subsampling\_y);
2316             \}
2317             \textcolor{keywordflow}{break};
2318           \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2319         \}
2320       \}
2321       \textcolor{comment}{/* Automatically set the codec bit depth to match the input bit depth.}
2322 \textcolor{comment}{       * Upgrade the profile if required. */}
2323       \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth >
2324           (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth) \{
2325         stream->config.cfg.g\_bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
2326         \textcolor{keywordflow}{if} (!global.quiet) \{
2327           fprintf(stderr,
2328                   \textcolor{stringliteral}{"Warning: automatically updating bit depth to %d to "}
2329                   \textcolor{stringliteral}{"match input format.\(\backslash\)n"},
2330                   stream->config.cfg.g\_input\_bit\_depth);
2331         \}
2332       \}
2333       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 10) \{
2334         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
2335           \textcolor{keywordflow}{case} 0:
2336           \textcolor{keywordflow}{case} 1:
2337             stream->config.cfg.g\_profile = 2;
2338             profile\_updated = 1;
2339             \textcolor{keywordflow}{break};
2340           \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2341         \}
2342       \}
2343       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 8) \{
2344         stream->config.use\_16bit\_internal = 1;
2345       \}
2346       \textcolor{keywordflow}{if} (profile\_updated && !global.quiet) \{
2347         fprintf(stderr,
2348                 \textcolor{stringliteral}{"Warning: automatically updating to profile %d to "}
2349                 \textcolor{stringliteral}{"match input format.\(\backslash\)n"},
2350                 stream->config.cfg.g\_profile);
2351       \}
2352       \textcolor{comment}{/* Set limit */}
2353       stream->config.cfg.g\_limit = global.limit;
2354     \}
2355 
2356     FOREACH\_STREAM(stream, streams) \{
2357       set\_stream\_dimensions(stream, input.width, input.height);
2358     \}
2359     FOREACH\_STREAM(stream, streams) \{ validate\_stream\_config(stream, &global); \}
2360 
2361     \textcolor{comment}{/* Ensure that --passes and --pass are consistent. If --pass is set and}
2362 \textcolor{comment}{     * --passes=2, ensure --fpf was set.}
2363 \textcolor{comment}{     */}
2364     \textcolor{keywordflow}{if} (global.pass && global.passes == 2) \{
2365       FOREACH\_STREAM(stream, streams) \{
2366         \textcolor{keywordflow}{if} (!stream->config.stats\_fn)
2367           die(\textcolor{stringliteral}{"Stream %d: Must specify --fpf when --pass=%d"}
2368               \textcolor{stringliteral}{" and --passes=2\(\backslash\)n"},
2369               stream->index, global.pass);
2370       \}
2371     \}
2372 
2373 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
2374     FOREACH\_STREAM(stream, streams) \{
2375       \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
2376         stream->config.write\_webm = 0;
2377         stream->config.write\_ivf = 0;
2378         warn(\textcolor{stringliteral}{"aomenc compiled w/o WebM support. Writing OBU stream."});
2379       \}
2380     \}
2381 \textcolor{preprocessor}{#endif}
2382 
2383     \textcolor{comment}{/* Use the frame rate from the file only if none was specified}
2384 \textcolor{comment}{     * on the command-line.}
2385 \textcolor{comment}{     */}
2386     \textcolor{keywordflow}{if} (!global.have\_framerate) \{
2387       global.framerate.num = input.framerate.numerator;
2388       global.framerate.den = input.framerate.denominator;
2389     \}
2390     FOREACH\_STREAM(stream, streams) \{
2391       stream->config.cfg.g\_timebase.den = global.framerate.num;
2392       stream->config.cfg.g\_timebase.num = global.framerate.den;
2393     \}
2394     \textcolor{comment}{/* Show configuration */}
2395     \textcolor{keywordflow}{if} (global.verbose && pass == 0) \{
2396       FOREACH\_STREAM(stream, streams) \{
2397         show\_stream\_config(stream, &global, &input);
2398       \}
2399     \}
2400 
2401     \textcolor{keywordflow}{if} (pass == (global.pass ? global.pass - 1 : 0)) \{
2402       \textcolor{keywordflow}{if} (input.file\_type == FILE\_TYPE\_Y4M)
2403         \textcolor{comment}{/*The Y4M reader does its own allocation.}
2404 \textcolor{comment}{          Just initialize this here to avoid problems if we never read any}
2405 \textcolor{comment}{          frames.*/}
2406         memset(&raw, 0, \textcolor{keyword}{sizeof}(raw));
2407       \textcolor{keywordflow}{else}
2408         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, input.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, input.width, input.height, 32);
2409 
2410       FOREACH\_STREAM(stream, streams) \{
2411         stream->rate\_hist =
2412             init\_rate\_histogram(&stream->config.cfg, &global.framerate);
2413       \}
2414     \}
2415 
2416     FOREACH\_STREAM(stream, streams) \{ setup\_pass(stream, &global, pass); \}
2417     FOREACH\_STREAM(stream, streams) \{ initialize\_encoder(stream, &global); \}
2418     FOREACH\_STREAM(stream, streams) \{
2419       open\_output\_file(stream, &global, &input.pixel\_aspect\_ratio);
2420     \}
2421 
2422     \textcolor{keywordflow}{if} (strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0 ||
2423         strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
2424       \textcolor{comment}{// Check to see if at least one stream uses 16 bit internal.}
2425       \textcolor{comment}{// Currently assume that the bit\_depths for all streams using}
2426       \textcolor{comment}{// highbitdepth are the same.}
2427       FOREACH\_STREAM(stream, streams) \{
2428         \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal) \{
2429           use\_16bit\_internal = 1;
2430         \}
2431         input\_shift = (int)stream->config.cfg.g\_bit\_depth -
2432                       stream->config.cfg.g\_input\_bit\_depth;
2433       \};
2434     \}
2435 
2436     frame\_avail = 1;
2437     got\_data = 0;
2438 
2439     \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
2440       \textcolor{keyword}{struct }aom\_usec\_timer timer;
2441 
2442       \textcolor{keywordflow}{if} (!global.limit || frames\_in < global.limit) \{
2443         frame\_avail = read\_frame(&input, &raw);
2444 
2445         \textcolor{keywordflow}{if} (frame\_avail) frames\_in++;
2446         seen\_frames =
2447             frames\_in > global.skip\_frames ? frames\_in - global.skip\_frames : 0;
2448 
2449         \textcolor{keywordflow}{if} (!global.quiet) \{
2450           \textcolor{keywordtype}{float} fps = usec\_to\_fps(cx\_time, seen\_frames);
2451           fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d "}, pass + 1, global.passes);
2452 
2453           \textcolor{keywordflow}{if} (stream\_cnt == 1)
2454             fprintf(stderr, \textcolor{stringliteral}{"frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B "}, frames\_in,
2455                     streams->frames\_out, (int64\_t)streams->nbytes);
2456           \textcolor{keywordflow}{else}
2457             fprintf(stderr, \textcolor{stringliteral}{"frame %4d "}, frames\_in);
2458 
2459           fprintf(stderr, \textcolor{stringliteral}{"%7"} PRId64 \textcolor{stringliteral}{" %s %.2f %s "},
2460                   cx\_time > 9999999 ? cx\_time / 1000 : cx\_time,
2461                   cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"}, fps >= 1.0 ? fps : fps * 60,
2462                   fps >= 1.0 ? \textcolor{stringliteral}{"fps"} : \textcolor{stringliteral}{"fpm"});
2463           print\_time(\textcolor{stringliteral}{"ETA"}, estimated\_time\_left);
2464         \}
2465 
2466       \} \textcolor{keywordflow}{else} \{
2467         frame\_avail = 0;
2468       \}
2469 
2470       \textcolor{keywordflow}{if} (frames\_in > global.skip\_frames) \{
2471         \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
2472         \textcolor{keywordflow}{if} (input\_shift || (use\_16bit\_internal && input.bit\_depth == 8)) \{
2473           assert(use\_16bit\_internal);
2474           \textcolor{comment}{// Input bit depth and stream bit depth do not match, so up}
2475           \textcolor{comment}{// shift frame to stream bit depth}
2476           \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
2477             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2478                           input.width, input.height, 32);
2479             allocated\_raw\_shift = 1;
2480           \}
2481           aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
2482           frame\_to\_encode = &raw\_shift;
2483         \} \textcolor{keywordflow}{else} \{
2484           frame\_to\_encode = &raw;
2485         \}
2486         aom\_usec\_timer\_start(&timer);
2487         \textcolor{keywordflow}{if} (use\_16bit\_internal) \{
2488           assert(frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH});
2489           FOREACH\_STREAM(stream, streams) \{
2490             \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal)
2491               encode\_frame(stream, &global,
2492                            frame\_avail ? frame\_to\_encode : NULL, frames\_in);
2493             \textcolor{keywordflow}{else}
2494               assert(0);
2495           \};
2496         \} \textcolor{keywordflow}{else} \{
2497           assert((frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) == 0);
2498           FOREACH\_STREAM(stream, streams) \{
2499             encode\_frame(stream, &global, frame\_avail ? frame\_to\_encode : NULL,
2500                          frames\_in);
2501           \}
2502         \}
2503         aom\_usec\_timer\_mark(&timer);
2504         cx\_time += aom\_usec\_timer\_elapsed(&timer);
2505 
2506         FOREACH\_STREAM(stream, streams) \{ update\_quantizer\_histogram(stream); \}
2507 
2508         got\_data = 0;
2509         FOREACH\_STREAM(stream, streams) \{
2510           get\_cx\_data(stream, &global, &got\_data);
2511         \}
2512 
2513         \textcolor{keywordflow}{if} (!got\_data && input.length && streams != NULL &&
2514             !streams->frames\_out) \{
2515           lagged\_count = global.limit ? seen\_frames : ftello(input.file);
2516         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.length) \{
2517           int64\_t remaining;
2518           int64\_t rate;
2519 
2520           \textcolor{keywordflow}{if} (global.limit) \{
2521             \textcolor{keyword}{const} int64\_t frame\_in\_lagged = (seen\_frames - lagged\_count) * 1000;
2522 
2523             rate = cx\_time ? frame\_in\_lagged * (int64\_t)1000000 / cx\_time : 0;
2524             remaining = 1000 * (global.limit - global.skip\_frames -
2525                                 seen\_frames + lagged\_count);
2526           \} \textcolor{keywordflow}{else} \{
2527             \textcolor{keyword}{const} int64\_t input\_pos = ftello(input.file);
2528             \textcolor{keyword}{const} int64\_t input\_pos\_lagged = input\_pos - lagged\_count;
2529             \textcolor{keyword}{const} int64\_t input\_limit = input.length;
2530 
2531             rate = cx\_time ? input\_pos\_lagged * (int64\_t)1000000 / cx\_time : 0;
2532             remaining = input\_limit - input\_pos + lagged\_count;
2533           \}
2534 
2535           average\_rate =
2536               (average\_rate <= 0) ? rate : (average\_rate * 7 + rate) / 8;
2537           estimated\_time\_left = average\_rate ? remaining / average\_rate : -1;
2538         \}
2539 
2540         \textcolor{keywordflow}{if} (got\_data && global.test\_decode != TEST\_DECODE\_OFF) \{
2541           FOREACH\_STREAM(stream, streams) \{
2542             test\_decode(stream, global.test\_decode);
2543           \}
2544         \}
2545       \}
2546 
2547       fflush(stdout);
2548       \textcolor{keywordflow}{if} (!global.quiet) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)033[K"});
2549     \}
2550 
2551     \textcolor{keywordflow}{if} (stream\_cnt > 1) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
2552 
2553     \textcolor{keywordflow}{if} (!global.quiet) \{
2554       FOREACH\_STREAM(stream, streams) \{
2555         \textcolor{keyword}{const} int64\_t bpf =
2556             seen\_frames ? (int64\_t)(stream->nbytes * 8 / seen\_frames) : 0;
2557         \textcolor{keyword}{const} int64\_t bps = bpf * global.framerate.num / global.framerate.den;
2558         fprintf(stderr,
2559                 \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B %7"} PRId64
2560                 \textcolor{stringliteral}{"b/f %7"} PRId64
2561                 \textcolor{stringliteral}{"b/s"}
2562                 \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" %s (%.2f fps)\(\backslash\)033[K\(\backslash\)n"},
2563                 pass + 1, global.passes, frames\_in, stream->frames\_out,
2564                 (int64\_t)stream->nbytes, bpf, bps,
2565                 stream->cx\_time > 9999999 ? stream->cx\_time / 1000
2566                                           : stream->cx\_time,
2567                 stream->cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"},
2568                 usec\_to\_fps(stream->cx\_time, seen\_frames));
2569       \}
2570     \}
2571 
2572     \textcolor{keywordflow}{if} (global.show\_psnr) \{
2573       \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) \{
2574         FOREACH\_STREAM(stream, streams) \{
2575           int64\_t bps = 0;
2576           \textcolor{keywordflow}{if} (stream->psnr\_count && seen\_frames && global.framerate.den) \{
2577             bps = (int64\_t)stream->nbytes * 8 * (int64\_t)global.framerate.num /
2578                   global.framerate.den / seen\_frames;
2579           \}
2580           show\_psnr(stream, (1 << stream->config.cfg.g\_input\_bit\_depth) - 1,
2581                     bps);
2582         \}
2583       \} \textcolor{keywordflow}{else} \{
2584         FOREACH\_STREAM(stream, streams) \{ show\_psnr(stream, 255.0, 0); \}
2585       \}
2586     \}
2587 
2588     FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->encoder); \}
2589 
2590     \textcolor{keywordflow}{if} (global.test\_decode != TEST\_DECODE\_OFF) \{
2591       FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->decoder); \}
2592     \}
2593 
2594     close\_input\_file(&input);
2595 
2596     \textcolor{keywordflow}{if} (global.test\_decode == TEST\_DECODE\_FATAL) \{
2597       FOREACH\_STREAM(stream, streams) \{ res |= stream->mismatch\_seen; \}
2598     \}
2599     FOREACH\_STREAM(stream, streams) \{
2600       close\_output\_file(stream, global.codec->fourcc);
2601     \}
2602 
2603     FOREACH\_STREAM(stream, streams) \{
2604       stats\_close(&stream->stats, global.passes - 1);
2605     \}
2606 
2607     \textcolor{keywordflow}{if} (global.pass) \textcolor{keywordflow}{break};
2608   \}
2609 
2610   \textcolor{keywordflow}{if} (global.show\_q\_hist\_buckets) \{
2611     FOREACH\_STREAM(stream, streams) \{
2612       show\_q\_histogram(stream->counts, global.show\_q\_hist\_buckets);
2613     \}
2614   \}
2615 
2616   \textcolor{keywordflow}{if} (global.show\_rate\_hist\_buckets) \{
2617     FOREACH\_STREAM(stream, streams) \{
2618       show\_rate\_histogram(stream->rate\_hist, &stream->config.cfg,
2619                           global.show\_rate\_hist\_buckets);
2620     \}
2621   \}
2622   FOREACH\_STREAM(stream, streams) \{ destroy\_rate\_histogram(stream->rate\_hist); \}
2623 
2624 \textcolor{preprocessor}{#if CONFIG\_INTERNAL\_STATS}
2625   \textcolor{comment}{/* TODO(jkoleszar): This doesn't belong in this executable. Do it for now,}
2626 \textcolor{comment}{   * to match some existing utilities.}
2627 \textcolor{comment}{   */}
2628   \textcolor{keywordflow}{if} (!(global.pass == 1 && global.passes == 2)) \{
2629     FOREACH\_STREAM(stream, streams) \{
2630       FILE *f = fopen(\textcolor{stringliteral}{"opsnr.stt"}, \textcolor{stringliteral}{"a"});
2631       \textcolor{keywordflow}{if} (stream->mismatch\_seen) \{
2632         fprintf(f, \textcolor{stringliteral}{"First mismatch occurred in frame %d\(\backslash\)n"},
2633                 stream->mismatch\_seen);
2634       \} \textcolor{keywordflow}{else} \{
2635         fprintf(f, \textcolor{stringliteral}{"No mismatch detected in recon buffers\(\backslash\)n"});
2636       \}
2637       fclose(f);
2638     \}
2639   \}
2640 \textcolor{preprocessor}{#endif}
2641 
2642   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
2643   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
2644   free(argv);
2645   free(streams);
2646   \textcolor{keywordflow}{return} res ? EXIT\_FAILURE : EXIT\_SUCCESS;
2647 \}
\end{DoxyCodeInclude}
 